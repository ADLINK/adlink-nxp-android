From 8b1a1f9700ef3fd00c9fa3c3de52bff3b4de711e Mon Sep 17 00:00:00 2001
From: shiva-adlink <shivashankar.t@adlinktech.com>
Date: Tue, 17 Jun 2025 17:47:14 +0530
Subject: [PATCH] sp2-imx8mp: Add Kernel support

Signed-off-by: shiva-adlink <shivashankar.t@adlinktech.com>
---
 .../boot/dts/freescale/10inch-overlay.dts     |   81 ++
 .../boot/dts/freescale/23inch-overlay.dts     |   82 ++
 .../arm64/boot/dts/freescale/7dsi-overlay.dts |   49 +
 .../boot/dts/freescale/7inch-overlay.dts      |   85 ++
 .../boot/dts/freescale/7rlcd-overlay.dts      |   49 +
 arch/arm64/boot/dts/freescale/Makefile        |    6 +
 .../dts/freescale/awcm276mapur-overlay.dts    |   88 ++
 .../dts/freescale/awcm276masur-overlay.dts    |  116 ++
 .../boot/dts/freescale/cma400mb-overlay.dts   |   25 +
 .../boot/dts/freescale/cma750mb-overlay.dts   |   25 +
 .../boot/dts/freescale/cma950mb-overlay.dts   |   25 +
 .../arm64/boot/dts/freescale/eth0-overlay.dts |   19 +
 .../arm64/boot/dts/freescale/eth1-overlay.dts |   19 +
 arch/arm64/boot/dts/freescale/imx8mp.dtsi     |   18 +-
 .../dts/freescale/snd-sgtl5000-overlay.dts    |   27 +
 arch/arm64/boot/dts/freescale/sp2imx8mp.dts   | 1283 +++++++++++++++++
 arch/arm64/configs/a14.fragment               |  165 +++
 arch/arm64/configs/sp2imx8mp_gki.fragment     |  164 +++
 drivers/char/tpm/Kconfig                      |   27 +-
 drivers/char/tpm/Makefile                     |    2 +-
 drivers/char/tpm/eventlog/acpi.c              |   18 +-
 drivers/char/tpm/st33zp24/i2c.c               |    9 +-
 drivers/char/tpm/st33zp24/spi.c               |    9 +-
 drivers/char/tpm/st33zp24/st33zp24.c          |  125 +-
 drivers/char/tpm/st33zp24/st33zp24.h          |    2 +-
 drivers/char/tpm/tpm-chip.c                   |  130 +-
 drivers/char/tpm/tpm-interface.c              |   36 +-
 drivers/char/tpm/tpm-sysfs.c                  |    3 -
 drivers/char/tpm/tpm.h                        |   75 -
 drivers/char/tpm/tpm1-cmd.c                   |    7 +-
 drivers/char/tpm/tpm2-cmd.c                   |   16 -
 drivers/char/tpm/tpm_crb.c                    |  131 +-
 drivers/char/tpm/tpm_ftpm_tee.c               |   10 +-
 drivers/char/tpm/tpm_i2c_atmel.c              |    3 +-
 drivers/char/tpm/tpm_i2c_infineon.c           |    4 +-
 drivers/char/tpm/tpm_i2c_nuvoton.c            |    3 +-
 drivers/char/tpm/tpm_ppi.c                    |    2 +-
 drivers/char/tpm/tpm_tis.c                    |   94 +-
 drivers/char/tpm/tpm_tis_core.c               |  473 +++---
 drivers/char/tpm/tpm_tis_core.h               |   71 +-
 drivers/char/tpm/tpm_tis_i2c.c                |  460 +++---
 drivers/char/tpm/tpm_tis_i2c_cr50.c           |   29 +-
 drivers/char/tpm/tpm_tis_spi.h                |    4 +
 drivers/char/tpm/tpm_tis_spi_cr50.c           |   27 +-
 drivers/char/tpm/tpm_tis_spi_main.c           |   48 +-
 drivers/char/tpm/tpm_tis_synquacer.c          |   98 +-
 drivers/char/tpm/tpm_vtpm_proxy.c             |    2 +-
 drivers/char/tpm/xen-tpmfront.c               |   26 +-
 drivers/gpu/drm/panel/panel-ilitek-ili9881c.c |  463 +++++-
 drivers/gpu/drm/panel/panel-lvds.c            |   69 +-
 drivers/gpu/drm/panel/panel-simple.c          |  131 +-
 drivers/net/phy/realtek.c                     |   23 +
 drivers/usb/dwc3/core.c                       |    3 +-
 drivers/usb/dwc3/core.h                       |    1 +
 drivers/video/backlight/pwm_bl.c              |   20 +-
 include/linux/pwm_backlight.h                 |    3 +
 sound/soc/codecs/sgtl5000.c                   |   36 +-
 sp2-imx8mp.dts                                | 1262 ++++++++++++++++
 sp2imx8mp_gki.fragment                        |  137 ++
 59 files changed, 5257 insertions(+), 1161 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/10inch-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/23inch-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/7dsi-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/7inch-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/7rlcd-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/awcm276mapur-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/awcm276masur-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/cma400mb-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/cma750mb-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/cma950mb-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/eth0-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/eth1-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/snd-sgtl5000-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/sp2imx8mp.dts
 create mode 100644 arch/arm64/configs/a14.fragment
 create mode 100644 arch/arm64/configs/sp2imx8mp_gki.fragment
 create mode 100644 sp2-imx8mp.dts
 create mode 100644 sp2imx8mp_gki.fragment

diff --git a/arch/arm64/boot/dts/freescale/10inch-overlay.dts b/arch/arm64/boot/dts/freescale/10inch-overlay.dts
new file mode 100644
index 000000000000..abf46c42413a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/10inch-overlay.dts
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			lvds_backlight {
+				pre-pwm-on-delay-ms = <200>;
+				post-pwm-on-delay-ms = <25>;
+				pwm-off-delay-ms = <10>;
+				post-pwm-off-delay-ms = <200>;
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/";
+		__overlay__ {
+			lvds0_panel {
+				compatible = "am,am1280800wutzqw", "panel-lvds";
+
+				height-mm = <135>;
+				width-mm = <217>;
+
+				post-prepare-delay-ms = <30>;
+				pre-disable-delay-ms = <15>;
+				post-unprepare-delay-ms = <500>;
+
+				status = "okay";
+
+				panel-timing {
+					clock-frequency = <72400000>;
+					hactive = <1280>;
+					vactive = <800>;
+					hback-porch = <80>;
+					hfront-porch = <70>;
+					vback-porch = <10>;
+					vfront-porch = <10>;
+					hsync-len = <10>;
+					vsync-len = <3>;
+					de-active = <1>;
+					pixelclk-active = <1>;
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ldb>;
+		__overlay__ {
+			status = "okay";
+			lvds-channel@0 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&lcdif2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&ldb_phy>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/23inch-overlay.dts b/arch/arm64/boot/dts/freescale/23inch-overlay.dts
new file mode 100644
index 000000000000..59f8c92a8304
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/23inch-overlay.dts
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			lvds_backlight {
+				pre-pwm-on-delay-ms = <200>;
+				post-pwm-on-delay-ms = <25>;
+				pwm-off-delay-ms = <10>;
+				post-pwm-off-delay-ms = <200>;
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/";
+		__overlay__ {
+			lvds0_panel {
+				compatible = "auo,p238hvt", "panel-lvds";
+
+				height-mm = <296>;
+				width-mm = <527>;
+
+				post-prepare-delay-ms = <30>;
+				pre-disable-delay-ms = <15>;
+				post-unprepare-delay-ms = <500>;
+
+				status = "okay";
+
+				panel-timing {
+					clock-frequency = <142400000>;
+					hactive = <1920>;
+					vactive = <1080>;
+					hback-porch = <100>;
+					hfront-porch = <80>;
+					vback-porch = <40>;
+					vfront-porch = <10>;
+					hsync-len = <1>;
+					vsync-len = <1>;
+					de-active = <1>;
+					pixelclk-active = <1>;
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ldb>;
+		__overlay__ {
+			fsl,dual-channel;
+			status = "okay";
+			lvds-channel@0 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&lcdif2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&ldb_phy>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/7dsi-overlay.dts b/arch/arm64/boot/dts/freescale/7dsi-overlay.dts
new file mode 100644
index 000000000000..ca15bab5894d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/7dsi-overlay.dts
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			lvds_backlight {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi_dsi>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+			panel@0 {
+				compatible = "ampire,am-8001280gtzqw", "ilitek,ili9881c";
+				reg = <0>;
+				power-supply = <&reg_lvds_blpwr>;
+				reset-gpios = <&gpio4 27 1>; /* GPIO_ACTIVE_LOW */
+				backlight = <&lvds_backlight>;
+				/* enum mipi_dsi_pixel_format { MIPI_DSI_FMT_RGB888, MIPI_DSI_FMT_RGB666, MIPI_DSI_FMT_RGB666_PACKED, MIPI_DSI_FMT_RGB565, }; */
+				dsi-format = <2>;
+				flip-horizontal;
+				flip-vertical;
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&lcdif1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/7inch-overlay.dts b/arch/arm64/boot/dts/freescale/7inch-overlay.dts
new file mode 100644
index 000000000000..b757a4bf1b6d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/7inch-overlay.dts
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			lvds_backlight {
+				pre-pwm-on-delay-ms = <160>;
+				post-pwm-on-delay-ms = <25>;
+				pwm-off-delay-ms = <10>;
+				post-pwm-off-delay-ms = <110>;
+				skip-blpwr-off;
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/";
+		__overlay__ {
+			lvds0_panel {
+				compatible = "am,1024600DTZQW", "panel-lvds";
+
+				height-mm = <86>;
+				width-mm = <154>;
+
+				post-prepare-delay-ms = <30>;
+				pre-disable-delay-ms = <15>;
+				post-unprepare-delay-ms = <1000>;
+
+				power-supply = <&reg_lvds_blpwr>;
+				skip-blpwr-off;
+
+				status = "okay";
+
+				panel-timing {
+					clock-frequency = <51200000>;
+					hactive = <1024>;
+					vactive = <600>;
+					hback-porch = <150>;
+					hfront-porch = <150>;
+					vback-porch = <15>;
+					vfront-porch = <15>;
+					hsync-len = <20>;
+					vsync-len = <5>;
+					de-active = <1>;
+					pixelclk-active = <1>;
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&ldb>;
+		__overlay__ {
+			status = "okay";
+			lvds-channel@0 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&lcdif2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&ldb_phy>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/7rlcd-overlay.dts b/arch/arm64/boot/dts/freescale/7rlcd-overlay.dts
new file mode 100644
index 000000000000..347793eee0f0
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/7rlcd-overlay.dts
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			lvds_backlight {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi_dsi>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "okay";
+			panel@0 {
+				compatible = "hsd,p0711t";
+				reg = <0>;
+				power-supply = <&reg_lvds_blpwr>;
+				reset-gpios = <&gpio4 27 1>; /* GPIO_ACTIVE_LOW */
+				backlight = <&lvds_backlight>;
+				/* enum mipi_dsi_pixel_format { MIPI_DSI_FMT_RGB888, MIPI_DSI_FMT_RGB666, MIPI_DSI_FMT_RGB666_PACKED, MIPI_DSI_FMT_RGB565, }; */
+				dsi-format = <2>;
+				flip-horizontal;
+				flip-vertical;
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&lcdif1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 2f6fe17cb6f7..a33dbcf41d11 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -112,6 +112,10 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mn-ab2.dtb imx8mn-ddr3l-ab2.dtb imx8mn-ddr4-ab2.dt
 dtb-$(CONFIG_ARCH_MXC) += imx8mn-evk-iqaudio-dacplus.dtb imx8mn-evk-iqaudio-dacpro.dtb imx8mn-evk-hifiberry-dacplus.dtb \
 			  imx8mn-evk-hifiberry-dac2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk.dtb imx8mp-evk-rm67191.dtb imx8mp-evk-it6263-lvds-dual-channel.dtb \
+		 	  sp2imx8mp.dtb 10inch-overlay.dtbo 23inch-overlay.dtbo 7dsi-overlay.dtbo \
+                          7inch-overlay.dtbo 7rlcd-overlay.dtbo awcm276mapur-overlay.dtbo \
+                          awcm276masur-overlay.dtbo cma400mb-overlay.dtbo cma750mb-overlay.dtbo \
+                          cma950mb-overlay.dtbo eth0-overlay.dtbo eth1-overlay.dtbo snd-sgtl5000-overlay.dtbo \
 			  imx8mp-evk-pcie-ep.dtb  imx8mp-evk-rpmsg.dtb imx8mp-evk-ecspi-slave.dtb \
 			  imx8mp-evk-jdi-wuxga-lvds-panel.dtb imx8mp-evk-flexcan2.dtb \
 			  imx8mp-evk-root.dtb imx8mp-evk-inmate.dtb imx8mp-evk-ov2775.dtb \
@@ -425,3 +429,5 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-powersave-non-rpmsg.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-powersave.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8ulp-watch.dtb imx8ulp-evk-lpd.dtb imx8ulp-evk-g1120b0mipi.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mm-evk-iw612.dtb
+
+DTC_FLAGS += -@ -H epapr
diff --git a/arch/arm64/boot/dts/freescale/awcm276mapur-overlay.dts b/arch/arm64/boot/dts/freescale/awcm276mapur-overlay.dts
new file mode 100644
index 000000000000..57d8dbcfb9ea
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/awcm276mapur-overlay.dts
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			pcie0_refclk: clock-pcie {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency = <100000000>;
+			};
+
+			reg_pcie0: regulator-pcie {
+				compatible = "regulator-fixed";
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_pcie0_reg>;
+				regulator-name = "MPCIE_3V3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&gpio2 6 0>; /* GPIO_ACTIVE_HIGH = 0 */
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pcie_phy>;
+		__overlay__ {
+			fsl,refclk-pad-mode = <1>; /* IMX8_PCIE_REFCLK_PAD_INPUT = 1 */
+			clocks = <&pcie0_refclk>;
+			clock-names = "ref";
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&pcie>;
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_pcie>;
+			fsl,refclk-pad-mode = <1>;
+			disable-gpio = <&gpio2 6 1>;  /* GPIO_ACTIVE_LOW = 1 */
+			reset-gpio = <&gpio2 7 1>;  /* GPIO_ACTIVE_LOW = 1 */
+			host-wake-gpios = <&gpio5 21 8>; /* IRQ_TYPE_LEVEL_LOW = 8 */
+			vpcie-supply = <&reg_pcie0>;
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&iomuxc>;
+		__overlay__ {
+			pinctrl_pcie: pciegrp {
+				fsl,pins = <
+					/* MX8MP_IOMUXC_I2C4_SCL__PCIE_CLKREQ_B - open drain, pull up */
+					0x218 0x478 0x5A0 0x2 0x0	0x61
+					/* MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07 - PCIe Reset */
+					0x0A8 0x308 0x000 0x5 0x0	0x41
+					/* MX8MP_IOMUXC_I2C4_SDA__GPIO5_IO21 - PCIe Wakeup */
+					0x21C 0x47C 0x000 0x5 0x0	0x1c4
+				>;
+			};
+
+			pinctrl_pcie0_reg: pcie0reggrp {
+				fsl,pins = <
+					/* MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06 - PCIe disable */
+					0x0A4 0x304 0x000 0x5 0x0	0x41		>;
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&usdhc1>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/awcm276masur-overlay.dts b/arch/arm64/boot/dts/freescale/awcm276masur-overlay.dts
new file mode 100644
index 000000000000..bb73a9029f48
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/awcm276masur-overlay.dts
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			usdhc1_pwrseq: usdhc1_pwrseq {
+				compatible = "mmc-pwrseq-simple";
+				reset-gpios = <&gpio2 6 1>; /* GPIO_ACTIVE_LOW = 1 */
+			};
+
+			reg_ex_sdio_3v: regulator-ex-sdio-3v {
+				compatible = "regulator-fixed";
+				regulator-name = "ex-sdio-3V";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&usdhc1>;
+		__overlay__ {
+			pinctrl-names = "default", "state_100mhz", "state_200mhz";
+			pinctrl-0 = <&pinctrl_usdhc1>;
+			pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+			pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+			keep-power-in-suspend;
+			non-removable;
+			wakeup-source;
+			vmmc-supply = <&reg_ex_sdio_3v>;
+			mmc-pwrseq = <&usdhc1_pwrseq>;
+			fsl,sdio-async-interrupt-enabled;
+			status = "okay";
+
+			wifi_wake_host {
+				compatible = "nxp,wifi-wake-host";
+				interrupt-parent = <&gpio2>;
+				interrupts = <9 8>; /* IRQ_TYPE_LEVEL_LOW = 8 */
+				interrupt-names = "host-wake";
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&iomuxc>;
+		__overlay__ {
+			pinctrl_usdhc1: usdhc1grp {
+				fsl,pins = <
+					/* MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK */
+					0x08C 0x2EC 0x000 0x0 0x0	0x190
+					/* MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	*/
+					0x090 0x2F0 0x000 0x0 0x0	0x1d0
+					/* MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0 */
+					0x094 0x2F4 0x000 0x0 0x0	0x1d0
+					/* MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1 */
+					0x098 0x2F8 0x000 0x0 0x0	0x1d0
+					/* MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2 */
+					0x09C 0x2FC 0x000 0x0 0x0	0x1d0
+					/* MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3 */
+					0x0A0 0x300 0x000 0x0 0x0	0x1d0
+					/* MX8MP_IOMUXC_SD1_RESET_B__GPIO2_IO10 */
+					0x0B4 0x314 0x000 0x5 0x0	0x10
+				>;
+			};
+
+			pinctrl_usdhc1_100mhz: usdhc1grp-100mhz {
+				fsl,pins = <
+					0x08C 0x2EC 0x000 0x0 0x0	0x194
+					0x090 0x2F0 0x000 0x0 0x0	0x1d4
+					0x094 0x2F4 0x000 0x0 0x0	0x1d4
+					0x098 0x2F8 0x000 0x0 0x0	0x1d4
+					0x09C 0x2FC 0x000 0x0 0x0	0x1d4
+					0x0A0 0x300 0x000 0x0 0x0	0x1d4
+					0x0B4 0x314 0x000 0x5 0x0	0x10
+				>;
+			};
+
+			pinctrl_usdhc1_200mhz: usdhc1grp-200mhz {
+				fsl,pins = <
+					0x08C 0x2EC 0x000 0x0 0x0	0x196
+					0x090 0x2F0 0x000 0x0 0x0	0x1d6
+					0x094 0x2F4 0x000 0x0 0x0	0x1d6
+					0x098 0x2F8 0x000 0x0 0x0	0x1d6
+					0x09C 0x2FC 0x000 0x0 0x0	0x1d6
+					0x0A0 0x300 0x000 0x0 0x0	0x1d6
+					0x0B4 0x314 0x000 0x5 0x0	0x10
+				>;
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&pcie>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@4 {
+		target = <&pcie_phy>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/cma400mb-overlay.dts b/arch/arm64/boot/dts/freescale/cma400mb-overlay.dts
new file mode 100644
index 000000000000..0f22fcb6ca9a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/cma400mb-overlay.dts
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reserved-memory {
+				linux,cma {
+					/* 40000000 = 1073741824 (1GiB) */
+					/* 20000000 =  536870912 (512MiB) */
+					size = <0 0x1A000000>; /* 256+128MiB+32MiB (416MiB) */
+				};
+			};
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/cma750mb-overlay.dts b/arch/arm64/boot/dts/freescale/cma750mb-overlay.dts
new file mode 100644
index 000000000000..747594658caf
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/cma750mb-overlay.dts
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reserved-memory {
+				linux,cma {
+					/* 40000000 = 1073741824 (1GiB) */
+					/* 20000000 =  536870912 (500MiB) */
+					size = <0 0x30000000>; /* 1073741824 - 268435456 (250MiB) = 805306368 (750MiB) */
+				};
+			};
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/cma950mb-overlay.dts b/arch/arm64/boot/dts/freescale/cma950mb-overlay.dts
new file mode 100644
index 000000000000..62e7c6028467
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/cma950mb-overlay.dts
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reserved-memory {
+				linux,cma {
+					/* 40000000 = 1073741824 (1GiB) */
+					/* 20000000 =  536870912 (500MiB) */
+					size = <0 0x3c000000>; /* 1GiB - 50331648 (50MiB) = 950 MiB */
+				};
+			};
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/eth0-overlay.dts b/arch/arm64/boot/dts/freescale/eth0-overlay.dts
new file mode 100644
index 000000000000..fb86eea3730d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/eth0-overlay.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&fec>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/eth1-overlay.dts b/arch/arm64/boot/dts/freescale/eth1-overlay.dts
new file mode 100644
index 000000000000..3f25ac25c5a1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/eth1-overlay.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&eqos>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/freescale/imx8mp.dtsi b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
index 18477e6e0e2f..6206a07700c1 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
@@ -217,14 +217,14 @@ ocram: ocram@900000 {
 		linux,cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0 0x3c000000>;
+			size = <0 0x20000000>;
 			alloc-ranges = <0 0x40000000 0 0xC0000000>;
 			linux,cma-default;
 		};
 
-		gpu_reserved: gpu_reserved@100000000 {
+		gpu_reserved: gpu_reserved@B0000000 {
 			no-map;
-			reg = <0x1 0x00000000 0 0x10000000>;
+			reg = <0 0xB0000000 0 0x02000000>;
 		};
 
 		dsp_reserved: dsp@92400000 {
@@ -343,11 +343,11 @@ busfreq { /* BUSFREQ */
 			 <&clk IMX8MP_SYS_PLL2_333M>, <&clk IMX8MP_CLK_NOC>,
 			 <&clk IMX8MP_CLK_AHB>, <&clk IMX8MP_CLK_MAIN_AXI>,
 			 <&clk IMX8MP_CLK_24M>, <&clk IMX8MP_SYS_PLL1_800M>,
-			 <&clk IMX8MP_DRAM_PLL>, <&clk IMX8MP_CLK_GIC>;
+			 <&clk IMX8MP_DRAM_PLL>;
 		clock-names = "dram_pll", "dram_alt_src", "dram_apb_src", "dram_apb_pre_div",
 			      "dram_core", "dram_alt_root", "sys_pll1_40m", "sys_pll1_100m",
 			      "sys_pll2_333m", "noc_div", "ahb_div", "main_axi_src", "osc_24m",
-			      "sys_pll1_800m", "dram_pll_div", "gic_div";
+			       "sys_pll1_800m", "dram_pll_div";
 	};
 
 	power-domains {
@@ -381,13 +381,13 @@ cpu-thermal {
 			thermal-sensors = <&tmu 0>;
 			trips {
 				cpu_alert0: trip0 {
-					temperature = <85000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 
 				cpu_crit0: trip1 {
-					temperature = <95000>;
+					temperature = <105000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
@@ -411,13 +411,13 @@ soc-thermal {
 			thermal-sensors = <&tmu 1>;
 			trips {
 				soc_alert0: trip0 {
-					temperature = <85000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 
 				soc_crit0: trip1 {
-					temperature = <95000>;
+					temperature = <105000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
diff --git a/arch/arm64/boot/dts/freescale/snd-sgtl5000-overlay.dts b/arch/arm64/boot/dts/freescale/snd-sgtl5000-overlay.dts
new file mode 100644
index 000000000000..3c5a615a08fd
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/snd-sgtl5000-overlay.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 ADLINK Technology Corp.
+ *
+ * Author: Po Cheng <po.cheng@adlinktech.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			sound {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&sgtl5000>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/sp2imx8mp.dts b/arch/arm64/boot/dts/freescale/sp2imx8mp.dts
new file mode 100644
index 000000000000..a05f781c4dc8
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/sp2imx8mp.dts
@@ -0,0 +1,1283 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/phy/phy-imx8-pcie.h>
+#include <dt-bindings/usb/pd.h>
+#include "imx8mp.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	model = "ADLINK Smart Panel - IMX8MP board";
+	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		status_led {
+			label = "green:sys-status";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on"; /* LED GREEN */
+		};
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0xc0000000>,
+		      <0x1 0x00000000 0 0xc0000000>;
+	};
+
+	/* 25MHz reference crystal */
+	ref25m: ref25xtal {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <25000000>;
+	};
+
+	reg_lvds_blpwr: regulator-lvds-pwr {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_lvds_bl_pwr>;
+		regulator-name = "vdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio3 20 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_usb0_pwr_en: regulator-usb0pwren {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb0_pwr_en>;
+		regulator-name = "usb0-pwr-en";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_keys>;
+
+		wakeup {
+			label = "Wake-Up";
+			gpios = <&gpio1 7 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WAKEUP>;
+			debounce-interval = <10>;
+			wakeup-source;
+		};
+	};
+
+	extcon_usb0: extcon-usb-idvbus-grp0 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&gpio1 10 GPIO_ACTIVE_LOW>; /* GPIO1_IO10 */
+		// vbus-gpio = <&gpio1 15 GPIO_ACTIVE_LOW>; /* GPIO1_IO15 */
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_ext_audio_3v: regulator-ext-audio-3v {
+		compatible = "regulator-fixed";
+		regulator-name = "ext-audio-3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	reg_ext_audio_1v8: regulator-ext-audio-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "+V1.8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	ex_audio_clk: sgtl5000_19M {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <19200000>; /* 19.2MHz */
+	};
+
+	reg_speaker_amp: regulator-audio-amplifier {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usbhub_spkamp>;
+		regulator-name = "speaker-amp";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpios = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx-audio-hdmi";
+		model = "audio-hdmi";
+		audio-cpu = <&aud2htx>;
+		hdmi-out;
+		constraint-rate = <44100>,
+				<88200>,
+				<176400>,
+				<32000>,
+				<48000>,
+				<96000>,
+				<192000>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-sgtl5000";
+		model = "audio-sgtl5000";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_hpdet>;
+		hp-det-gpio = <&gpio4 20 GPIO_ACTIVE_LOW>;
+		codec-master;
+		ssi-controller = <&sai3>;
+		audio-codec = <&sgtl5000>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT",
+			"Ext Spk", "LINE_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <3>;
+		status = "disabled";
+	};
+
+	lvds_backlight: lvds_backlight {
+		compatible = "pwm-backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_bl_en>;
+		enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		power-supply = <&reg_lvds_blpwr>;
+		pwms = <&pwm2 0 100000 0>;
+		status = "disabled";
+
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+				     10 11 12 13 14 15 16 17 18 19
+				     20 21 22 23 24 25 26 27 28 29
+				     30 31 32 33 34 35 36 37 38 39
+				     40 41 42 43 44 45 46 47 48 49
+				     50 51 52 53 54 55 56 57 58 59
+				     60 61 62 63 64 65 66 67 68 69
+				     70 71 72 73 74 75 76 77 78 79
+				     80 81 82 83 84 85 86 87 88 89
+				     90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+	};
+
+	lvds0_panel {
+		backlight = <&lvds_backlight>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_lvds_vdd>;
+		enable-gpios = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+
+		data-mapping = "vesa-24";
+		status = "disabled";
+
+		port {
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+
+	pwm-beeper {
+		compatible = "pwm-beeper";
+		pwms = <&pwm4 0 500000 0>;
+	};
+};
+
+&A53_0 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_1 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_2 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_3 {
+	cpu-supply = <&buck2>;
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio1_hog>;
+
+	gpio-line-names =       \
+		"", "USB_MUX_SEL", "", "", "", "", "", "",  \
+		"", "", "", "", "", "", "", "",      \
+		"", "", "", "", "", "", "", "", \
+		"", "", "", "", "", "", "", "";
+};
+
+&gpio4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio4_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"UART_MODE0", "UART_MODE1", "", "", "HWID_2", "HWID_3", "", "";
+/*
+	uart_mode0 {
+		gpios = <&gpio4 24 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE0";
+	};
+
+	uart_mode1 {
+		gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE1";
+	};
+
+	hwid_2 {
+		gpios = <&gpio4 28 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_2";
+	};
+
+	hwid_3 {
+		gpios = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_3";
+	};
+*/
+};
+
+&gpio5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio5_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "HWID_1", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "";
+/*
+	hwid_1 {
+		gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_1";
+	};
+*/
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_bl_pwm2>;
+	status = "okay";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_buzz_pwm4>;
+	status = "okay";
+};
+
+&aud2htx {
+	status = "okay";
+};
+
+&ecspi2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2 &pinctrl_ecspi2_cs>;
+	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	spidev1: spi@0 {
+		reg = <0>;
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <500000>;
+	};
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	snps,force_thresh_dma_mode;
+	snps,mtl-tx-config = <&mtl_tx_setup>;
+	snps,mtl-rx-config = <&mtl_rx_setup>;
+	status = "okay";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			eee-broken-1000t;
+			reset-gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,clkout-disable;
+		};
+	};
+
+	mtl_tx_setup: tx-queues-config {
+		snps,tx-queues-to-use = <5>;
+		snps,tx-sched-sp;
+
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+		};
+
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+		};
+
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+		};
+
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+		};
+
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+		};
+	};
+
+	mtl_rx_setup: rx-queues-config {
+		snps,rx-queues-to-use = <5>;
+		snps,rx-sched-sp;
+
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+			snps,map-to-dma-channel = <0>;
+		};
+
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+			snps,map-to-dma-channel = <1>;
+		};
+
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+			snps,map-to-dma-channel = <2>;
+		};
+
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+			snps,map-to-dma-channel = <3>;
+		};
+
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+			snps,map-to-dma-channel = <4>;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <2>;
+			eee-broken-1000t;
+			reset-gpios = <&gpio4 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,aldps-enable;
+			realtek,clkout-disable;
+			interrupt-parent = <&gpio4>;
+			interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+			wakeup-source;
+		};
+	};
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic@25 {
+		compatible = "nxp,pca9450c";
+		reg = <0x25>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_pmic>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		regulators {
+			buck1: BUCK1 {
+				regulator-name = "BUCK1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2: BUCK2 {
+				regulator-name = "BUCK2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+				nxp,dvs-run-voltage = <950000>;
+				nxp,dvs-standby-voltage = <850000>;
+			};
+
+			buck4: BUCK4{
+				regulator-name = "BUCK4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5: BUCK5{
+				regulator-name = "BUCK5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6: BUCK6 {
+				regulator-name = "BUCK6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1: LDO1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2: LDO2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3: LDO3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4: LDO4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5: LDO5 {
+				regulator-name = "LDO5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	/* RTC: PCF85063A */
+	rtc: pcf85063a@51 {
+		compatible = "nxp,pcf85063a";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rtc>;
+		quartz-load-femtofarads = <12500>;
+		reg = <0x51>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+
+	/* Comment to show an external PCIe CLK GEN: PI6CG33202C-ZDIEX */
+	/* pcieclk0: pi6cg33202@6a {
+		reg = <0x6a>;
+		compatible = "pi,6cg33202";
+	}; */
+
+};
+
+&i2c3 {
+	clock-frequency = <300000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	/* TPM: ST33HTPH2X32AHD5 */
+	tpm: st33htph77@2e {
+		compatible = "st,st33htpm-i2c";
+		reg = <0x2e>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_tpm>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>;
+		tpm-reset = <&gpio1 6 GPIO_ACTIVE_LOW>;
+		default-guard-time;
+		status = "okay";
+	};
+
+	/* sgtl5000 audio codec */
+	sgtl5000: audio-codec@a {
+		compatible = "fsl,sgtl5000";
+		#sound-dai-cells = <0>;
+		reg = <0x0a>;
+		micbias-voltage-m-volts = <2250>;
+		VDDA-supply = <&reg_ext_audio_3v>;
+		VDDIO-supply = <&reg_ext_audio_1v8>;
+		VDDD-supply = <&reg_ext_audio_1v8>;
+		clocks = <&ex_audio_clk>;
+		status = "disabled";
+	};
+
+	eeprom@50 {
+		compatible = "atmel,24c256";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x50>;
+		pagesize = <64>;
+		size = <32768>;
+		address-width = <16>;
+	};
+};
+
+&i2c6 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6>;
+	status = "okay";
+
+	/* SX1509 */
+	sx1509: gpioext0@3f {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3f>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio3>;
+		interrupts = <21 IRQ_TYPE_EDGE_FALLING>;
+
+		gpio-line-names =	\
+		"DI0", "DI1", "DI2", "DI3", "DO0", "DO1", "DO2", "DO3",	\
+		"", "", "", "", "", "", "", "";
+
+		status = "okay";
+
+		/* GPIO Expander 0 Mapping :
+		 * 0: CN_DI0, 1: CN_DI1, 2: CN_DI2, 3: CN_DI3,
+		 * 4: CN_DO0, 5: CN_DO1, 6: CN_DO2, 7: CN_DO3
+		 * 8~15: N/A
+		 */
+	};
+};
+
+&irqsteer_hdmi {
+	status = "okay";
+};
+
+&hdmi_blk_ctrl {
+	status = "okay";
+};
+
+&hdmi_pavi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&hdmiphy {
+	status = "okay";
+};
+
+&lcdif1 {
+	status = "disabled";
+};
+
+&lcdif2 {
+	status = "disabled";
+};
+
+&lcdif3 {
+	status = "okay";
+
+	thres-low  = <1 2>;             /* (FIFO * 1 / 2) */
+	thres-high = <3 4>;             /* (FIFO * 3 / 4) */
+};
+
+&ldb {
+	/* fsl,dual-channel; */
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+
+		port@1 {
+			reg = <1>;
+
+			lvds_out: endpoint {
+				remote-endpoint = <&panel_lvds_in>;
+			};
+		};
+	};
+};
+
+&ldb_phy {
+	status = "okay";
+};
+
+&mipi_dsi {
+	/delete-node/ panel@0;
+};
+
+&snvs_pwrkey {
+	status = "okay";
+};
+
+&easrc {
+	fsl,asrc-rate  = <48000>;
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	/* fsl,sai-mclk-direction-output; */
+	status = "okay";
+};
+
+&xcvr {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&sdma2 {
+	status = "okay";
+};
+
+&uart1 { /* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+
+&uart2 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	//vbus-power-supply = <&ptn5110>;
+	fsl,phy-tx-vref-tune = <0xe>;
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vboost-level = <2>; /* set amplitude to 1.04v */
+	fsl,phy-comp-dis-tune = <7>;
+	fsl,pcs-tx-deemph-3p5db = <0x21>;
+	fsl,phy-pcs-tx-swing-full = <0x7f>;
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb0_id>;
+	dr_mode = "otg";
+	// NOTE: don't set usb-role-switch to enable extcon
+	// (patch core.c to enable extcon fn in drd.c)
+	//usb-role-switch;
+	// NOTE: dual role, not real OTG for imx8mp, no host-negocitation or session-request
+	hnp-disable;
+	srp-disable;
+	extcon = <&extcon_usb0>;
+	otg-rev = <0x0200>;
+	status = "okay";
+};
+
+&usb3_phy1 {
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vref-tune = <0xb>;
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+/* RS485 only */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/* SP399E RS232/RS422/RS485 */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usdhc2 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC2>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&usdhc3 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC3>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+/*
+fsl,pins = <PIN_FUNC_ID CONFIG>,
+  - PIN_FUNC_ID is a pin (5-values) working on a specific function (MUX control)
+  - CONFIG is the pad setting (1-value) like pull-up for this pin. (PAD control)
+  see iomux-v3.h
+*/
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c3
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c3
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000019
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000019
+
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23	0x00000106	// I2C6_INT#
+			MX8MP_IOMUXC_SD1_DATA6__GPIO2_IO08	0x00000106	// M.2 BT wakeup
+			MX8MP_IOMUXC_SD1_DATA7__GPIO2_IO09	0x00000106	// M.2 SDIO wakeup
+		>;
+	};
+
+	pinctrl_rtc: rtcgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD1__GPIO3_IO22	0x80  /* RTC intr */
+		>;
+	};
+
+	pinctrl_bl_pwm2: blpwm2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
+		>;
+	};
+
+	pinctrl_buzz_pwm4: buzzpwm4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXFS__PWM4_OUT	0x116
+		>;
+	};
+
+	pinctrl_tpm: tpmgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DQS__GPIO3_IO14		0xd6	// TPM IRQ
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x156	// TPM reset
+		>;
+	};
+
+	pinctrl_usbhub_spkamp: usbhubspkampgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12		0x146	//HUB_RESET or AUDIO_AMP
+		>;
+	};
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC				0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22				0x19		//ENET RESET
+			MX8MP_IOMUXC_SAI2_RXFS__GPIO4_IO21				0x00000106	//ENET INT
+			MX8MP_IOMUXC_GPIO1_IO08__ENET_QOS_1588_EVENT0_IN		0x106
+			MX8MP_IOMUXC_GPIO1_IO09__ENET_QOS_1588_EVENT0_OUT		0x106
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			MX8MP_IOMUXC_SAI1_RXD1__GPIO4_IO03		0x00000106	//ENET1 INT
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x19		//ENET1_RESET
+			MX8MP_IOMUXC_SAI1_RXC__ENET1_1588_EVENT0_OUT	0x00000106
+			MX8MP_IOMUXC_SAI1_RXFS__ENET1_1588_EVENT0_IN	0x00000106
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX		0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX		0x154
+		>;
+	};
+
+	pinctrl_ecspi2: ecspi2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi2_cs: ecspi2cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x140
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c6: i2c6grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__I2C6_SCL	0x400001c2
+			MX8MP_IOMUXC_UART4_TXD__I2C6_SDA	0x400001c2
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
+		>;
+	};
+
+	pinctrl_reg_bl_en: regblengrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO00__GPIO1_IO00	0x16
+		>;
+	};
+
+	pinctrl_reg_lvds_vdd: reglvdsvddgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27	0x16
+		>;
+	};
+
+	pinctrl_reg_lvds_bl_pwr: reglvdsblpwrgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXC__GPIO3_IO20	0x106
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC	0xd6
+			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK	0xd6
+			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK	0xd6
+		>;
+	};
+
+	pinctrl_i2c2_irq: i2c2irqgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD6__GPIO4_IO18	0x1c4
+		>;
+	};
+
+	pinctrl_i2c3_irq: i2c3irqgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4
+		>;
+	};
+
+	pinctrl_gpio_keys: gpiokeysgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO07__GPIO1_IO07	0x80 // FUNCTION_INT
+		>;
+	};
+
+	pinctrl_hpdet: hpdetgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x1C6
+		>;
+	};
+
+	pinctrl_usb0_pwr_en: usb0pwrengrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO14__GPIO1_IO14	0x16
+		>;
+	};
+
+	pinctrl_gpio1_hog: gpio1hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO01__GPIO1_IO01	0x19	// GPIO_USB_MUX_SEL(Need check boot status is high or low)
+		>;
+	};
+
+	pinctrl_gpio4_hog: gpio4hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_TXFS__GPIO4_IO24	0x19	// UART_MODE0
+			MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25	0x19	// UART_MODE1
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28	0x80	// HWID_2
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29	0x80	// HWID_3
+		>;
+	};
+
+	pinctrl_gpio5_hog: gpio5hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05	0x00000106	// HWID_1
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+			MX8MP_IOMUXC_UART3_RXD__UART1_DCE_CTS	0x140
+			MX8MP_IOMUXC_UART3_TXD__UART1_DCE_RTS	0x140
+		>;
+	};
+
+	pinctrl_usb0_id: usb0-id-grp {
+		fsl,pins = <
+			// MX8MP_IOMUXC_GPIO1_IO10__USB1_ID		0x19 // DNU - do not use
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10		0x19
+		>;
+	};
+
+	pinctrl_usb0_oc: usb0-oc-grp {
+		fsl,pins = <
+			// MX8MP_IOMUXC_GPIO1_IO15__USB2_OC		0x19
+			MX8MP_IOMUXC_GPIO1_IO15__GPIO1_IO15		0x19
+		>;
+	};
+
+//	pinctrl_usb1_oc: usb1ocgrp {
+//		fsl,pins = <
+//			MX8MP_IOMUXC_GPIO1_IO13__USB1_OC		0x19
+//		>;
+//	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x140
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x140
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SCLK__UART3_DCE_RX		0x140
+			MX8MP_IOMUXC_ECSPI1_MOSI__UART3_DCE_TX		0x140
+			MX8MP_IOMUXC_ECSPI1_SS0__UART3_DCE_RTS		0x140
+			MX8MP_IOMUXC_ECSPI1_MISO__UART3_DCE_CTS		0x140
+		>;
+	};
+
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA00__UART4_DCE_RX		0x140
+			MX8MP_IOMUXC_NAND_DATA01__UART4_DCE_TX		0x140
+			MX8MP_IOMUXC_NAND_DATA02__UART4_DCE_CTS		0x140
+			MX8MP_IOMUXC_NAND_DATA03__UART4_DCE_RTS		0x140
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12	0x1c4
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0x166
+		>;
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_vc8000e {
+	status = "okay";
+};
+
+&vpu_v4l2 {
+	status = "okay";
+};
+
+&gpu_3d {
+	status = "okay";
+};
+
+&gpu_2d {
+	status = "okay";
+};
+
+&ml_vipsi {
+	status = "okay";
+};
+
+&mix_gpu_ml {
+	status = "okay";
+};
+
+#include "imx8mp-android.dtsi"
diff --git a/arch/arm64/configs/a14.fragment b/arch/arm64/configs/a14.fragment
new file mode 100644
index 000000000000..da80920fe16a
--- /dev/null
+++ b/arch/arm64/configs/a14.fragment
@@ -0,0 +1,165 @@
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX8M=m
+CONFIG_IMX8M_BLK_CTRL=m
+CONFIG_MXC_CLK=m
+CONFIG_CLK_IMX8MP=m
+CONFIG_DEVICE_THERMAL=m
+CONFIG_IMX8MM_THERMAL=m
+CONFIG_IMX8M_PM_DOMAINS=m
+CONFIG_IMX_GPCV2_PM_DOMAINS=m
+CONFIG_PINCTRL_IMX=m
+CONFIG_PINCTRL_IMX8MP=m
+CONFIG_SERIAL_IMX=m
+CONFIG_SERIAL_IMX_CONSOLE=m
+CONFIG_IMX2_WDT=m
+CONFIG_I2C_IMX=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_REGULATOR_PCA9450=m
+CONFIG_PWM_IMX27=m
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_MMC_SDHCI_ESDHC_IMX=m
+CONFIG_PHY_FSL_IMX8MP_LVDS=m
+CONFIG_PHY_SAMSUNG_HDMI_PHY=m
+CONFIG_MXC_GPU_VIV=m
+CONFIG_IMX8MM_LCDIF_CORE=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_IMX_CDNS_MHDP=m
+CONFIG_DRM_CDNS_HDCP=m
+CONFIG_DRM_IMX8MP_LDB=m
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=m
+CONFIG_DRM_ITE_IT6263=m
+CONFIG_DRM_IMX_SEC_DSIM=m
+CONFIG_DRM_DW_HDMI_CEC=m
+CONFIG_DRM_DW_HDMI_GP_AUDIO=m
+CONFIG_DRM_IMX_HDMI=m
+CONFIG_DRM_IMX=m
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_IMX_LCDIFV3_CORE=m
+CONFIG_PHY_FSL_IMX8MQ_USB=m
+CONFIG_USB_DWC3_IMX8MP=m
+CONFIG_TYPEC_SWITCH_GPIO=m
+
+CONFIG_IMX_SDMA=m
+CONFIG_SND_SOC_IMX_CARD=m
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_EASRC=m
+CONFIG_SND_SOC_SGTL5000=m
+CONFIG_SND_SOC_WM8962=m
+CONFIG_SND_SOC_FSL_ASOC_CARD=m
+CONFIG_SND_SOC_BT_SCO=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_AUD2HTX=m
+CONFIG_SND_SOC_IMX_HDMI=m
+CONFIG_IMX_DSP_REMOTEPROC=m
+CONFIG_DMABUF_HEAPS_DSP=m
+
+CONFIG_IMX_MBOX=m
+CONFIG_IMX_LPA_CTRL=m
+CONFIG_I2C_RPBUS=m
+CONFIG_SND_SOC_IMX_RPMSG=m
+CONFIG_SND_SOC_IMX_PCM512X_RPMSG=m
+CONFIG_IMX_REMOTEPROC=m
+CONFIG_SND_SOC_IMX_SGTL5000=m
+CONFIG_SND_SOC_RPMSG_PCM512X=m
+CONFIG_SND_SOC_RPMSG_PCM512X_I2C=m
+CONFIG_SND_SOC_FSL_RPMSG=m
+CONFIG_SND_SOC_TPA6130A2=m
+CONFIG_SND_SOC_SOF_OF=m
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_IMX8M=m
+CONFIG_SND_SOC_SOF_IMX_TOPLEVEL=y
+CONFIG_IMX_DSP=m
+
+CONFIG_RTC_DRV_SNVS=m
+
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C=m
+CONFIG_KEYBOARD_SNVS_PWRKEY=m
+
+CONFIG_PHY_FSL_IMX8M_PCIE=m
+CONFIG_PCI_IMX6=m
+
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_IMX_CAPTURE=m
+
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_ETHERNET=y
+CONFIG_FEC=m
+CONFIG_STMMAC_ETH=m
+CONFIG_DWMAC_IMX8=m
+# CONFIG_PAGE_POOL_STATS is not set
+CONFIG_REALTEK_PHY=m
+
+CONFIG_TRUSTY=m
+CONFIG_TRUSTY_CRASH_IS_PANIC=y
+
+# CONFIG_MXC_HANTRO is not set
+CONFIG_MXC_HANTRO_VC8000E=m
+CONFIG_MXC_HANTRO_845=m
+CONFIG_MXC_HANTRO_V4L2=m
+
+# CONFIG_BATTERY_DUMMY is not set
+
+CONFIG_RESET_IMX7=m
+CONFIG_IMX8M_BUSFREQ=m
+CONFIG_IMX_IRQSTEER=m
+CONFIG_GPIO_MXC=m
+CONFIG_TIMER_IMX_SYS_CTR=m
+
+CONFIG_FPGA=y
+
+CONFIG_NVMEM_IMX_OCOTP=m
+CONFIG_CPUFREQ_DT=m
+CONFIG_ARM_IMX_CPUFREQ_DT=m
+
+# CONFIG_ARM64_BTI_KERNEL is not set
+
+CONFIG_DMABUF_HEAPS_SYSTEM=m
+CONFIG_DMABUF_HEAPS_CMA=m
+CONFIG_DMABUF_IMX=m
+
+# CONFIG_IMX_SEC_ENCLAVE is not set
+# CONFIG_IMX_RPMSG_TTY is not set
+CONFIG_ZRAM=m
+CONFIG_ZSMALLOC=m
+
+# CONFIG_DEBUG_INFO_BTF_MODULES is not set
+
+CONFIG_FSL_IMX8_DDR_PMU=m
+# CONFIG_SOC_IMX9 is not set
+# CONFIG_MODULE_SIG_ALL is not set
+CONFIG_IMX_GKI_FIX=y
+#adlink
+CONFIG_SYSFS=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_EXTCON_USB_GPIO=m
+CONFIG_RTC_DRV_PCF85063=y
+CONFIG_PINCTRL_SX150X=y
+CONFIG_MTD=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_ARCH_LAYERSCAPE=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_EEPROM_AT24=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+# CONFIG_DRM_PANEL_LVDS=m
+CONFIG_FW_LOADER=y
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_INPUT_PWM_BEEPER=y
+#CONFIG_TCG_TPM=m
+#CONFIG_TCG_TIS_CORE=m
+#CONFIG_TCG_TIS_I2C=m
diff --git a/arch/arm64/configs/sp2imx8mp_gki.fragment b/arch/arm64/configs/sp2imx8mp_gki.fragment
new file mode 100644
index 000000000000..bf7929e8c300
--- /dev/null
+++ b/arch/arm64/configs/sp2imx8mp_gki.fragment
@@ -0,0 +1,164 @@
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX8M=m
+CONFIG_MXC_CLK=m
+CONFIG_CLK_IMX8MP=m
+CONFIG_DEVICE_THERMAL=m
+CONFIG_IMX8MM_THERMAL=m
+CONFIG_IMX8M_PM_DOMAINS=m
+CONFIG_IMX_GPCV2_PM_DOMAINS=m
+CONFIG_PINCTRL_IMX=m
+CONFIG_PINCTRL_IMX8MP=m
+CONFIG_SERIAL_IMX=m
+CONFIG_SERIAL_IMX_CONSOLE=m
+CONFIG_IMX2_WDT=m
+CONFIG_I2C_IMX=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_REGULATOR_PCA9450=m
+CONFIG_PWM_IMX27=m
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_MMC_SDHCI_ESDHC_IMX=m
+CONFIG_PHY_FSL_IMX8MP_LVDS=m
+CONFIG_PHY_SAMSUNG_HDMI_PHY=m
+CONFIG_MXC_GPU_VIV=m
+CONFIG_IMX8MM_LCDIF_CORE=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_IMX_CDNS_MHDP=m
+CONFIG_DRM_CDNS_HDCP=m
+CONFIG_DRM_IMX8MP_LDB=m
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=m
+CONFIG_DRM_ITE_IT6263=m
+CONFIG_DRM_IMX_SEC_DSIM=m
+CONFIG_DRM_DW_HDMI_CEC=m
+CONFIG_DRM_DW_HDMI_GP_AUDIO=m
+CONFIG_DRM_IMX_HDMI=m
+CONFIG_DRM_IMX=m
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_IMX_LCDIFV3_CORE=m
+CONFIG_PHY_FSL_IMX8MQ_USB=m
+CONFIG_USB_DWC3_IMX8MP=m
+CONFIG_TYPEC_SWITCH_GPIO=m
+
+CONFIG_IMX_SDMA=m
+CONFIG_SND_SOC_IMX_CARD=m
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_EASRC=m
+CONFIG_SND_SOC_SGTL5000=m
+CONFIG_SND_SOC_FSL_ASOC_CARD=m
+CONFIG_SND_SOC_BT_SCO=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_AUD2HTX=m
+CONFIG_SND_SOC_IMX_HDMI=m
+CONFIG_IMX_DSP_REMOTEPROC=m
+CONFIG_DMABUF_HEAPS_DSP=m
+
+CONFIG_IMX_MBOX=m
+CONFIG_IMX_LPA_CTRL=m
+CONFIG_I2C_RPBUS=m
+CONFIG_SND_SOC_IMX_RPMSG=m
+CONFIG_SND_SOC_IMX_PCM512X_RPMSG=m
+CONFIG_IMX_REMOTEPROC=m
+CONFIG_SND_SOC_IMX_SGTL5000=m
+CONFIG_SND_SOC_RPMSG_PCM512X=m
+CONFIG_SND_SOC_RPMSG_PCM512X_I2C=m
+CONFIG_SND_SOC_FSL_RPMSG=m
+CONFIG_SND_SOC_TPA6130A2=m
+CONFIG_SND_SOC_SOF_OF=m
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_IMX8M=m
+CONFIG_SND_SOC_SOF_IMX_TOPLEVEL=y
+CONFIG_IMX_DSP=m
+
+CONFIG_RTC_DRV_SNVS=m
+
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C=m
+CONFIG_KEYBOARD_SNVS_PWRKEY=m
+
+CONFIG_PHY_FSL_IMX8M_PCIE=m
+CONFIG_PCI_IMX6=m
+
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_IMX_CAPTURE=m
+
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_ETHERNET=y
+CONFIG_FEC=m
+CONFIG_STMMAC_ETH=m
+CONFIG_DWMAC_IMX8=m
+# CONFIG_PAGE_POOL_STATS is not set
+CONFIG_REALTEK_PHY=m
+
+CONFIG_TRUSTY=m
+CONFIG_TRUSTY_CRASH_IS_PANIC=y
+
+# CONFIG_MXC_HANTRO is not set
+CONFIG_MXC_HANTRO_VC8000E=m
+CONFIG_MXC_HANTRO_845=m
+CONFIG_MXC_HANTRO_V4L2=m
+
+# CONFIG_BATTERY_DUMMY is not set
+
+CONFIG_RESET_IMX7=m
+CONFIG_IMX8M_BUSFREQ=m
+CONFIG_IMX_IRQSTEER=m
+CONFIG_GPIO_MXC=m
+CONFIG_TIMER_IMX_SYS_CTR=m
+
+CONFIG_FPGA=y
+
+CONFIG_NVMEM_IMX_OCOTP=m
+CONFIG_CPUFREQ_DT=m
+CONFIG_ARM_IMX_CPUFREQ_DT=m
+
+CONFIG_LTO_CLANG_THIN=y
+# CONFIG_ARM64_BTI_KERNEL is not set
+
+CONFIG_DMABUF_HEAPS_SYSTEM=m
+CONFIG_DMABUF_HEAPS_CMA=m
+CONFIG_DMABUF_IMX=m
+
+# CONFIG_IMX_EL_ENCLAVE is not set
+# CONFIG_IMX_RPMSG_TTY is not set
+CONFIG_ZRAM=m
+CONFIG_ZSMALLOC=m
+
+# CONFIG_DEBUG_INFO_BTF_MODULES is not set
+
+CONFIG_FSL_IMX8_DDR_PMU=m
+# CONFIG_SOC_IMX9 is not set
+# CONFIG_MODULE_SIG_ALL is not set
+CONFIG_IMX_GKI_FIX=y
+#adlink
+CONFIG_SYSFS=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_EXTCON_USB_GPIO=m
+CONFIG_RTC_DRV_PCF85063=y
+CONFIG_PINCTRL_SX150X=y
+CONFIG_MTD=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_ARCH_LAYERSCAPE=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_EEPROM_AT24=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+CONFIG_DRM_PANEL_LVDS=m
+CONFIG_FW_LOADER=y
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_INPUT_PWM_BEEPER=y
+CONFIG_TCG_TPM=m
+CONFIG_TCG_TIS_CORE=m
+CONFIG_TCG_TIS_I2C=m
diff --git a/drivers/char/tpm/Kconfig b/drivers/char/tpm/Kconfig
index 927088b2c3d3..7ccd0d762d83 100644
--- a/drivers/char/tpm/Kconfig
+++ b/drivers/char/tpm/Kconfig
@@ -74,21 +74,9 @@ config TCG_TIS_SPI_CR50
 	  If you have a H1 secure module running Cr50 firmware on SPI bus,
 	  say Yes and it will be accessible from within Linux.
 
-config TCG_TIS_I2C
-	tristate "TPM Interface Specification 1.3 Interface / TPM 2.0 FIFO Interface - (I2C - generic)"
-	depends on I2C
-	select CRC_CCITT
-	select TCG_TIS_CORE
-	help
-	  If you have a TPM security chip, compliant with the TCG TPM PTP
-	  (I2C interface) specification and connected to an I2C bus master,
-	  say Yes and it will be accessible from within Linux.
-	  To compile this driver as a module, choose M here;
-	  the module will be called tpm_tis_i2c.
-
 config TCG_TIS_SYNQUACER
 	tristate "TPM Interface Specification 1.2 Interface / TPM 2.0 FIFO Interface (MMIO - SynQuacer)"
-	depends on ARCH_SYNQUACER || COMPILE_TEST
+	depends on ARCH_SYNQUACER
 	select TCG_TIS_CORE
 	help
 	  If you have a TPM security chip that is compliant with the
@@ -107,6 +95,19 @@ config TCG_TIS_I2C_CR50
 	  to handle the limitations of the hardware.  To compile this driver
 	  as a module, choose M here; the module will be called tcg_tis_i2c_cr50.
 
+config TCG_TIS_I2C
+	tristate "TPM I2C Interface Specification"
+	depends on I2C
+        depends on CRC_CCITT
+	select TCG_TIS_CORE
+	help
+	  If you have a TPM security chip which is connected to a regular
+	  I2C master (i.e. most embedded platforms) that is compliant with the
+	  TCG TPM I2C Interface Specification say Yes and it will be accessible from
+	  within Linux. To compile this driver as a module, choose  M here;
+	  the module will be called tpm_tis_i2c.
+
+
 config TCG_TIS_I2C_ATMEL
 	tristate "TPM Interface Specification 1.2 Interface (I2C - Atmel)"
 	depends on I2C
diff --git a/drivers/char/tpm/Makefile b/drivers/char/tpm/Makefile
index 0222b1ddb310..3c69b8402291 100644
--- a/drivers/char/tpm/Makefile
+++ b/drivers/char/tpm/Makefile
@@ -24,12 +24,12 @@ obj-$(CONFIG_TCG_TIS) += tpm_tis.o
 obj-$(CONFIG_TCG_TIS_SYNQUACER) += tpm_tis_synquacer.o
 
 obj-$(CONFIG_TCG_TIS_SPI) += tpm_tis_spi.o
+obj-$(CONFIG_TCG_TIS_I2C) += tpm_tis_i2c.o
 tpm_tis_spi-y := tpm_tis_spi_main.o
 tpm_tis_spi-$(CONFIG_TCG_TIS_SPI_CR50) += tpm_tis_spi_cr50.o
 
 obj-$(CONFIG_TCG_TIS_I2C_CR50) += tpm_tis_i2c_cr50.o
 
-obj-$(CONFIG_TCG_TIS_I2C) += tpm_tis_i2c.o
 obj-$(CONFIG_TCG_TIS_I2C_ATMEL) += tpm_i2c_atmel.o
 obj-$(CONFIG_TCG_TIS_I2C_INFINEON) += tpm_i2c_infineon.o
 obj-$(CONFIG_TCG_TIS_I2C_NUVOTON) += tpm_i2c_nuvoton.o
diff --git a/drivers/char/tpm/eventlog/acpi.c b/drivers/char/tpm/eventlog/acpi.c
index cd266021d010..1b18ce5ebab1 100644
--- a/drivers/char/tpm/eventlog/acpi.c
+++ b/drivers/char/tpm/eventlog/acpi.c
@@ -90,21 +90,16 @@ int tpm_read_log_acpi(struct tpm_chip *chip)
 			return -ENODEV;
 
 		if (tbl->header.length <
-				sizeof(*tbl) + sizeof(struct acpi_tpm2_phy)) {
-			acpi_put_table((struct acpi_table_header *)tbl);
+				sizeof(*tbl) + sizeof(struct acpi_tpm2_phy))
 			return -ENODEV;
-		}
 
 		tpm2_phy = (void *)tbl + sizeof(*tbl);
 		len = tpm2_phy->log_area_minimum_length;
 
 		start = tpm2_phy->log_area_start_address;
-		if (!start || !len) {
-			acpi_put_table((struct acpi_table_header *)tbl);
+		if (!start || !len)
 			return -ENODEV;
-		}
 
-		acpi_put_table((struct acpi_table_header *)tbl);
 		format = EFI_TCG2_EVENT_LOG_FORMAT_TCG_2;
 	} else {
 		/* Find TCPA entry in RSDT (ACPI_LOGICAL_ADDRESSING) */
@@ -125,10 +120,8 @@ int tpm_read_log_acpi(struct tpm_chip *chip)
 			break;
 		}
 
-		acpi_put_table((struct acpi_table_header *)buff);
 		format = EFI_TCG2_EVENT_LOG_FORMAT_TCG_1_2;
 	}
-
 	if (!len) {
 		dev_warn(&chip->dev, "%s: TCPA log area empty\n", __func__);
 		return -EIO;
@@ -143,12 +136,8 @@ int tpm_read_log_acpi(struct tpm_chip *chip)
 
 	ret = -EIO;
 	virt = acpi_os_map_iomem(start, len);
-	if (!virt) {
-		dev_warn(&chip->dev, "%s: Failed to map ACPI memory\n", __func__);
-		/* try EFI log next */
-		ret = -ENODEV;
+	if (!virt)
 		goto err;
-	}
 
 	memcpy_fromio(log->bios_event_log, virt, len);
 
@@ -167,4 +156,5 @@ int tpm_read_log_acpi(struct tpm_chip *chip)
 	kfree(log->bios_event_log);
 	log->bios_event_log = NULL;
 	return ret;
+
 }
diff --git a/drivers/char/tpm/st33zp24/i2c.c b/drivers/char/tpm/st33zp24/i2c.c
index a3aa411389e7..7c617edff4ca 100644
--- a/drivers/char/tpm/st33zp24/i2c.c
+++ b/drivers/char/tpm/st33zp24/i2c.c
@@ -264,11 +264,16 @@ static int st33zp24_i2c_probe(struct i2c_client *client,
  * @param: client, the i2c_client description (TPM I2C description).
  * @return: 0 in case of success.
  */
-static void st33zp24_i2c_remove(struct i2c_client *client)
+static int st33zp24_i2c_remove(struct i2c_client *client)
 {
 	struct tpm_chip *chip = i2c_get_clientdata(client);
+	int ret;
 
-	st33zp24_remove(chip);
+	ret = st33zp24_remove(chip);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static const struct i2c_device_id st33zp24_i2c_id[] = {
diff --git a/drivers/char/tpm/st33zp24/spi.c b/drivers/char/tpm/st33zp24/spi.c
index 22d184884694..a75dafd39445 100644
--- a/drivers/char/tpm/st33zp24/spi.c
+++ b/drivers/char/tpm/st33zp24/spi.c
@@ -381,11 +381,16 @@ static int st33zp24_spi_probe(struct spi_device *dev)
  * @param: client, the spi_device description (TPM SPI description).
  * @return: 0 in case of success.
  */
-static void st33zp24_spi_remove(struct spi_device *dev)
+static int st33zp24_spi_remove(struct spi_device *dev)
 {
 	struct tpm_chip *chip = spi_get_drvdata(dev);
+	int ret;
 
-	st33zp24_remove(chip);
+	ret = st33zp24_remove(chip);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static const struct spi_device_id st33zp24_spi_id[] = {
diff --git a/drivers/char/tpm/st33zp24/st33zp24.c b/drivers/char/tpm/st33zp24/st33zp24.c
index 15b393e92c8e..4ec10ab5e576 100644
--- a/drivers/char/tpm/st33zp24/st33zp24.c
+++ b/drivers/char/tpm/st33zp24/st33zp24.c
@@ -61,7 +61,9 @@ enum tis_defaults {
 };
 
 /*
- * clear the pending interrupt.
+ * clear_interruption clear the pending interrupt.
+ * @param: tpm_dev, the tpm device device.
+ * @return: the interrupt status value.
  */
 static u8 clear_interruption(struct st33zp24_dev *tpm_dev)
 {
@@ -70,10 +72,12 @@ static u8 clear_interruption(struct st33zp24_dev *tpm_dev)
 	tpm_dev->ops->recv(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);
 	tpm_dev->ops->send(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);
 	return interrupt;
-}
+} /* clear_interruption() */
 
 /*
- * cancel the current command execution or set STS to COMMAND READY.
+ * st33zp24_cancel, cancel the current command execution or
+ * set STS to COMMAND READY.
+ * @param: chip, the tpm_chip description as specified in driver/char/tpm/tpm.h
  */
 static void st33zp24_cancel(struct tpm_chip *chip)
 {
@@ -82,10 +86,12 @@ static void st33zp24_cancel(struct tpm_chip *chip)
 
 	data = TPM_STS_COMMAND_READY;
 	tpm_dev->ops->send(tpm_dev->phy_id, TPM_STS, &data, 1);
-}
+} /* st33zp24_cancel() */
 
 /*
- * return the TPM_STS register
+ * st33zp24_status return the TPM_STS register
+ * @param: chip, the tpm chip description
+ * @return: the TPM_STS register value.
  */
 static u8 st33zp24_status(struct tpm_chip *chip)
 {
@@ -94,10 +100,12 @@ static u8 st33zp24_status(struct tpm_chip *chip)
 
 	tpm_dev->ops->recv(tpm_dev->phy_id, TPM_STS, &data, 1);
 	return data;
-}
+} /* st33zp24_status() */
 
 /*
- * if the locality is active
+ * check_locality if the locality is active
+ * @param: chip, the tpm chip description
+ * @return: true if LOCALITY0 is active, otherwise false
  */
 static bool check_locality(struct tpm_chip *chip)
 {
@@ -112,8 +120,13 @@ static bool check_locality(struct tpm_chip *chip)
 		return true;
 
 	return false;
-}
+} /* check_locality() */
 
+/*
+ * request_locality request the TPM locality
+ * @param: chip, the chip description
+ * @return: the active locality or negative value.
+ */
 static int request_locality(struct tpm_chip *chip)
 {
 	struct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);
@@ -140,8 +153,12 @@ static int request_locality(struct tpm_chip *chip)
 
 	/* could not get locality */
 	return -EACCES;
-}
+} /* request_locality() */
 
+/*
+ * release_locality release the active locality
+ * @param: chip, the tpm chip description.
+ */
 static void release_locality(struct tpm_chip *chip)
 {
 	struct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);
@@ -154,6 +171,8 @@ static void release_locality(struct tpm_chip *chip)
 
 /*
  * get_burstcount return the burstcount value
+ * @param: chip, the chip description
+ * return: the burstcount or negative value.
  */
 static int get_burstcount(struct tpm_chip *chip)
 {
@@ -181,8 +200,18 @@ static int get_burstcount(struct tpm_chip *chip)
 		msleep(TPM_TIMEOUT);
 	} while (time_before(jiffies, stop));
 	return -EBUSY;
-}
+} /* get_burstcount() */
 
+
+/*
+ * wait_for_tpm_stat_cond
+ * @param: chip, chip description
+ * @param: mask, expected mask value
+ * @param: check_cancel, does the command expected to be canceled ?
+ * @param: canceled, did we received a cancel request ?
+ * @return: true if status == mask or if the command is canceled.
+ * false in other cases.
+ */
 static bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,
 				bool check_cancel, bool *canceled)
 {
@@ -199,7 +228,13 @@ static bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,
 }
 
 /*
- * wait for a TPM_STS value
+ * wait_for_stat wait for a TPM_STS value
+ * @param: chip, the tpm chip description
+ * @param: mask, the value mask to wait
+ * @param: timeout, the timeout
+ * @param: queue, the wait queue.
+ * @param: check_cancel, does the command can be cancelled ?
+ * @return: the tpm status, 0 if success, -ETIME if timeout is reached.
  */
 static int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,
 			wait_queue_head_t *queue, bool check_cancel)
@@ -257,8 +292,15 @@ static int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,
 	}
 
 	return -ETIME;
-}
+} /* wait_for_stat() */
 
+/*
+ * recv_data receive data
+ * @param: chip, the tpm chip description
+ * @param: buf, the buffer where the data are received
+ * @param: count, the number of data to receive
+ * @return: the number of bytes read from TPM FIFO.
+ */
 static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	struct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);
@@ -283,6 +325,12 @@ static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 	return size;
 }
 
+/*
+ * tpm_ioserirq_handler the serirq irq handler
+ * @param: irq, the tpm chip description
+ * @param: dev_id, the description of the chip
+ * @return: the status of the handler.
+ */
 static irqreturn_t tpm_ioserirq_handler(int irq, void *dev_id)
 {
 	struct tpm_chip *chip = dev_id;
@@ -293,10 +341,16 @@ static irqreturn_t tpm_ioserirq_handler(int irq, void *dev_id)
 	disable_irq_nosync(tpm_dev->irq);
 
 	return IRQ_HANDLED;
-}
+} /* tpm_ioserirq_handler() */
 
 /*
- * send TPM commands through the I2C bus.
+ * st33zp24_send send TPM commands through the I2C bus.
+ *
+ * @param: chip, the tpm_chip description as specified in driver/char/tpm/tpm.h
+ * @param: buf,	the buffer to send.
+ * @param: count, the number of bytes to send.
+ * @return: In case of success the number of bytes sent.
+ *			In other case, a < 0 value describing the issue.
  */
 static int st33zp24_send(struct tpm_chip *chip, unsigned char *buf,
 			 size_t len)
@@ -377,6 +431,14 @@ static int st33zp24_send(struct tpm_chip *chip, unsigned char *buf,
 	return ret;
 }
 
+/*
+ * st33zp24_recv received TPM response through TPM phy.
+ * @param: chip, the tpm_chip description as specified in driver/char/tpm/tpm.h.
+ * @param: buf,	the buffer to store datas.
+ * @param: count, the number of bytes to send.
+ * @return: In case of success the number of bytes received.
+ *	    In other case, a < 0 value describing the issue.
+ */
 static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,
 			    size_t count)
 {
@@ -416,6 +478,12 @@ static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,
 	return size;
 }
 
+/*
+ * st33zp24_req_canceled
+ * @param: chip, the tpm_chip description as specified in driver/char/tpm/tpm.h.
+ * @param: status, the TPM status.
+ * @return: Does TPM ready to compute a new command ? true.
+ */
 static bool st33zp24_req_canceled(struct tpm_chip *chip, u8 status)
 {
 	return (status == TPM_STS_COMMAND_READY);
@@ -433,7 +501,11 @@ static const struct tpm_class_ops st33zp24_tpm = {
 };
 
 /*
- * initialize the TPM device
+ * st33zp24_probe initialize the TPM device
+ * @param: client, the i2c_client description (TPM I2C description).
+ * @param: id, the i2c_device_id struct.
+ * @return: 0 in case of success.
+ *	 -1 in other case.
  */
 int st33zp24_probe(void *phy_id, const struct st33zp24_phy_ops *ops,
 		   struct device *dev, int irq, int io_lpcpd)
@@ -511,13 +583,25 @@ int st33zp24_probe(void *phy_id, const struct st33zp24_phy_ops *ops,
 }
 EXPORT_SYMBOL(st33zp24_probe);
 
-void st33zp24_remove(struct tpm_chip *chip)
+/*
+ * st33zp24_remove remove the TPM device
+ * @param: tpm_data, the tpm phy.
+ * @return: 0 in case of success.
+ */
+int st33zp24_remove(struct tpm_chip *chip)
 {
 	tpm_chip_unregister(chip);
+	return 0;
 }
 EXPORT_SYMBOL(st33zp24_remove);
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * st33zp24_pm_suspend suspend the TPM device
+ * @param: tpm_data, the tpm phy.
+ * @param: mesg, the power management message.
+ * @return: 0 in case of success.
+ */
 int st33zp24_pm_suspend(struct device *dev)
 {
 	struct tpm_chip *chip = dev_get_drvdata(dev);
@@ -531,9 +615,14 @@ int st33zp24_pm_suspend(struct device *dev)
 		ret = tpm_pm_suspend(dev);
 
 	return ret;
-}
+} /* st33zp24_pm_suspend() */
 EXPORT_SYMBOL(st33zp24_pm_suspend);
 
+/*
+ * st33zp24_pm_resume resume the TPM device
+ * @param: tpm_data, the tpm phy.
+ * @return: 0 in case of success.
+ */
 int st33zp24_pm_resume(struct device *dev)
 {
 	struct tpm_chip *chip = dev_get_drvdata(dev);
@@ -551,7 +640,7 @@ int st33zp24_pm_resume(struct device *dev)
 			tpm1_do_selftest(chip);
 	}
 	return ret;
-}
+} /* st33zp24_pm_resume() */
 EXPORT_SYMBOL(st33zp24_pm_resume);
 #endif
 
diff --git a/drivers/char/tpm/st33zp24/st33zp24.h b/drivers/char/tpm/st33zp24/st33zp24.h
index b387a476c555..6747be1e2502 100644
--- a/drivers/char/tpm/st33zp24/st33zp24.h
+++ b/drivers/char/tpm/st33zp24/st33zp24.h
@@ -34,5 +34,5 @@ int st33zp24_pm_resume(struct device *dev);
 
 int st33zp24_probe(void *phy_id, const struct st33zp24_phy_ops *ops,
 		   struct device *dev, int irq, int io_lpcpd);
-void st33zp24_remove(struct tpm_chip *chip);
+int st33zp24_remove(struct tpm_chip *chip);
 #endif /* __LOCAL_ST33ZP24_H__ */
diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index 95d847c9de79..65d800ecc996 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -415,7 +415,7 @@ static int tpm_add_char_device(struct tpm_chip *chip)
 		return rc;
 	}
 
-	if (chip->flags & TPM_CHIP_FLAG_TPM2 && !tpm_is_firmware_upgrade(chip)) {
+	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
 		rc = tpm_devs_add(chip);
 		if (rc)
 			goto err_del_cdev;
@@ -466,8 +466,7 @@ static void tpm_del_legacy_sysfs(struct tpm_chip *chip)
 {
 	struct attribute **i;
 
-	if (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL) ||
-	    tpm_is_firmware_upgrade(chip))
+	if (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL))
 		return;
 
 	sysfs_remove_link(&chip->dev.parent->kobj, "ppi");
@@ -485,8 +484,7 @@ static int tpm_add_legacy_sysfs(struct tpm_chip *chip)
 	struct attribute **i;
 	int rc;
 
-	if (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL) ||
-		tpm_is_firmware_upgrade(chip))
+	if (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL))
 		return 0;
 
 	rc = compat_only_sysfs_link_entry_to_kobj(
@@ -507,78 +505,16 @@ static int tpm_add_legacy_sysfs(struct tpm_chip *chip)
 	return 0;
 }
 
-/*
- * Some AMD fTPM versions may cause stutter
- * https://www.amd.com/en/support/kb/faq/pa-410
- *
- * Fixes are available in two series of fTPM firmware:
- * 6.x.y.z series: 6.0.18.6 +
- * 3.x.y.z series: 3.57.y.5 +
- */
-static bool tpm_amd_is_rng_defective(struct tpm_chip *chip)
-{
-	u32 val1, val2;
-	u64 version;
-	int ret;
-
-	if (!(chip->flags & TPM_CHIP_FLAG_TPM2))
-		return false;
-
-	ret = tpm_request_locality(chip);
-	if (ret)
-		return false;
-
-	ret = tpm2_get_tpm_pt(chip, TPM2_PT_MANUFACTURER, &val1, NULL);
-	if (ret)
-		goto release;
-	if (val1 != 0x414D4400U /* AMD */) {
-		ret = -ENODEV;
-		goto release;
-	}
-	ret = tpm2_get_tpm_pt(chip, TPM2_PT_FIRMWARE_VERSION_1, &val1, NULL);
-	if (ret)
-		goto release;
-	ret = tpm2_get_tpm_pt(chip, TPM2_PT_FIRMWARE_VERSION_2, &val2, NULL);
-
-release:
-	tpm_relinquish_locality(chip);
-
-	if (ret)
-		return false;
-
-	version = ((u64)val1 << 32) | val2;
-	if ((version >> 48) == 6) {
-		if (version >= 0x0006000000180006ULL)
-			return false;
-	} else if ((version >> 48) == 3) {
-		if (version >= 0x0003005700000005ULL)
-			return false;
-	} else {
-		return false;
-	}
-
-	dev_warn(&chip->dev,
-		 "AMD fTPM version 0x%llx causes system stutter; hwrng disabled\n",
-		 version);
-
-	return true;
-}
-
 static int tpm_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)
 {
 	struct tpm_chip *chip = container_of(rng, struct tpm_chip, hwrng);
 
-	/* Give back zero bytes, as TPM chip has not yet fully resumed: */
-	if (chip->flags & TPM_CHIP_FLAG_SUSPENDED)
-		return 0;
-
 	return tpm_get_random(chip, data, max);
 }
 
 static int tpm_add_hwrng(struct tpm_chip *chip)
 {
-	if (!IS_ENABLED(CONFIG_HW_RANDOM_TPM) || tpm_is_firmware_upgrade(chip) ||
-	    tpm_amd_is_rng_defective(chip))
+	if (!IS_ENABLED(CONFIG_HW_RANDOM_TPM))
 		return 0;
 
 	snprintf(chip->hwrng_name, sizeof(chip->hwrng_name),
@@ -592,9 +528,6 @@ static int tpm_get_pcr_allocation(struct tpm_chip *chip)
 {
 	int rc;
 
-	if (tpm_is_firmware_upgrade(chip))
-		return 0;
-
 	rc = (chip->flags & TPM_CHIP_FLAG_TPM2) ?
 	     tpm2_get_pcr_allocation(chip) :
 	     tpm1_get_pcr_allocation(chip);
@@ -605,42 +538,6 @@ static int tpm_get_pcr_allocation(struct tpm_chip *chip)
 	return rc;
 }
 
-/*
- * tpm_chip_bootstrap() - Boostrap TPM chip after power on
- * @chip: TPM chip to use.
- *
- * Initialize TPM chip after power on. This a one-shot function: subsequent
- * calls will have no effect.
- */
-int tpm_chip_bootstrap(struct tpm_chip *chip)
-{
-	int rc;
-
-	if (chip->flags & TPM_CHIP_FLAG_BOOTSTRAPPED)
-		return 0;
-
-	rc = tpm_chip_start(chip);
-	if (rc)
-		return rc;
-
-	rc = tpm_auto_startup(chip);
-	if (rc)
-		goto stop;
-
-	rc = tpm_get_pcr_allocation(chip);
-stop:
-	tpm_chip_stop(chip);
-
-	/*
-	 * Unconditionally set, as driver initialization should cease, when the
-	 * boostrapping process fails.
-	 */
-	chip->flags |= TPM_CHIP_FLAG_BOOTSTRAPPED;
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(tpm_chip_bootstrap);
-
 /*
  * tpm_chip_register() - create a character device for the TPM chip
  * @chip: TPM chip to use.
@@ -656,7 +553,17 @@ int tpm_chip_register(struct tpm_chip *chip)
 {
 	int rc;
 
-	rc = tpm_chip_bootstrap(chip);
+	rc = tpm_chip_start(chip);
+	if (rc)
+		return rc;
+	rc = tpm_auto_startup(chip);
+	if (rc) {
+		tpm_chip_stop(chip);
+		return rc;
+	}
+
+	rc = tpm_get_pcr_allocation(chip);
+	tpm_chip_stop(chip);
 	if (rc)
 		return rc;
 
@@ -683,7 +590,7 @@ int tpm_chip_register(struct tpm_chip *chip)
 	return 0;
 
 out_hwrng:
-	if (IS_ENABLED(CONFIG_HW_RANDOM_TPM) && !tpm_is_firmware_upgrade(chip))
+	if (IS_ENABLED(CONFIG_HW_RANDOM_TPM))
 		hwrng_unregister(&chip->hwrng);
 out_ppi:
 	tpm_bios_log_teardown(chip);
@@ -708,11 +615,10 @@ EXPORT_SYMBOL_GPL(tpm_chip_register);
 void tpm_chip_unregister(struct tpm_chip *chip)
 {
 	tpm_del_legacy_sysfs(chip);
-	if (IS_ENABLED(CONFIG_HW_RANDOM_TPM) && !tpm_is_firmware_upgrade(chip) &&
-	    !tpm_amd_is_rng_defective(chip))
+	if (IS_ENABLED(CONFIG_HW_RANDOM_TPM))
 		hwrng_unregister(&chip->hwrng);
 	tpm_bios_log_teardown(chip);
-	if (chip->flags & TPM_CHIP_FLAG_TPM2 && !tpm_is_firmware_upgrade(chip))
+	if (chip->flags & TPM_CHIP_FLAG_TPM2)
 		tpm_devs_remove(chip);
 	tpm_del_char_device(chip);
 }
diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 0f941cb32eb1..293bf34f35f7 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -64,6 +64,8 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 	int rc;
 	ssize_t len = 0;
 	u32 count, ordinal;
+	//change ST@2020.10.29
+	unsigned int delay_msec = TPM_TIMEOUT_POLL;
 	unsigned long stop;
 
 	if (bufsiz < TPM_HEADER_SIZE)
@@ -114,7 +116,10 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)
 			return -ECANCELED;
 		}
 
-		tpm_msleep(TPM_TIMEOUT_POLL);
+		//change ST@2020.10.29
+		//tpm_msleep(TPM_TIMEOUT_POLL);
+		tpm_msleep(delay_msec);
+		delay_msec = delay_msec+delay_msec;
 		rmb();
 	} while (time_before(jiffies, stop));
 
@@ -157,6 +162,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	u8 save[TPM_HEADER_SIZE + 3*sizeof(u32)];
 	unsigned int delay_msec = TPM2_DURATION_SHORT;
 	u32 rc = 0;
+	u32 i = TPM_RETRY;
 	ssize_t ret;
 	const size_t save_size = min(sizeof(save), bufsiz);
 	/* the command code is where the return code will be */
@@ -172,7 +178,13 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 	for (;;) {
 		ret = tpm_try_transmit(chip, buf, bufsiz);
 		if (ret < 0)
-			break;
+		{
+			i--;
+			if (i<=0)
+				break;
+		}
+		else
+		{
 		rc = be32_to_cpu(header->return_code);
 		if (rc != TPM2_RC_RETRY && rc != TPM2_RC_TESTING)
 			break;
@@ -194,6 +206,7 @@ ssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)
 		tpm_msleep(delay_msec);
 		delay_msec *= 2;
 		memcpy(buf, save, save_size);
+		}
 	}
 	return ret;
 }
@@ -401,22 +414,17 @@ int tpm_pm_suspend(struct device *dev)
 	    !pm_suspend_via_firmware())
 		goto suspended;
 
-	rc = tpm_try_get_ops(chip);
-	if (!rc) {
+	if (!tpm_chip_start(chip)) {
 		if (chip->flags & TPM_CHIP_FLAG_TPM2)
 			tpm2_shutdown(chip, TPM2_SU_STATE);
 		else
 			rc = tpm1_pm_suspend(chip, tpm_suspend_pcr);
 
-		tpm_put_ops(chip);
+		tpm_chip_stop(chip);
 	}
 
 suspended:
-	chip->flags |= TPM_CHIP_FLAG_SUSPENDED;
-
-	if (rc)
-		dev_err(dev, "Ignoring error %d while suspending\n", rc);
-	return 0;
+	return rc;
 }
 EXPORT_SYMBOL_GPL(tpm_pm_suspend);
 
@@ -431,14 +439,6 @@ int tpm_pm_resume(struct device *dev)
 	if (chip == NULL)
 		return -ENODEV;
 
-	chip->flags &= ~TPM_CHIP_FLAG_SUSPENDED;
-
-	/*
-	 * Guarantee that SUSPENDED is written last, so that hwrng does not
-	 * activate before the chip has been fully resumed.
-	 */
-	wmb();
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(tpm_pm_resume);
diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c
index 54c71473aa29..63f03cfb8e6a 100644
--- a/drivers/char/tpm/tpm-sysfs.c
+++ b/drivers/char/tpm/tpm-sysfs.c
@@ -480,9 +480,6 @@ void tpm_sysfs_add_device(struct tpm_chip *chip)
 
 	WARN_ON(chip->groups_cnt != 0);
 
-	if (tpm_is_firmware_upgrade(chip))
-		return;
-
 	if (chip->flags & TPM_CHIP_FLAG_TPM2)
 		chip->groups[chip->groups_cnt++] = &tpm2_dev_group;
 	else
diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h
index f6c99b3f0045..2163c6ee0d36 100644
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -55,7 +55,6 @@ enum tpm_addr {
 #define TPM_WARN_DOING_SELFTEST 0x802
 #define TPM_ERR_DEACTIVATED     0x6
 #define TPM_ERR_DISABLED        0x7
-#define TPM_ERR_FAILEDSELFTEST  0x1C
 #define TPM_ERR_INVALID_POSTINIT 38
 
 #define TPM_TAG_RQU_COMMAND 193
@@ -150,79 +149,6 @@ enum tpm_sub_capabilities {
 	TPM_CAP_PROP_TIS_DURATION = 0x120,
 };
 
-enum tpm2_pt_props {
-	TPM2_PT_NONE = 0x00000000,
-	TPM2_PT_GROUP = 0x00000100,
-	TPM2_PT_FIXED = TPM2_PT_GROUP * 1,
-	TPM2_PT_FAMILY_INDICATOR = TPM2_PT_FIXED + 0,
-	TPM2_PT_LEVEL = TPM2_PT_FIXED + 1,
-	TPM2_PT_REVISION = TPM2_PT_FIXED + 2,
-	TPM2_PT_DAY_OF_YEAR = TPM2_PT_FIXED + 3,
-	TPM2_PT_YEAR = TPM2_PT_FIXED + 4,
-	TPM2_PT_MANUFACTURER = TPM2_PT_FIXED + 5,
-	TPM2_PT_VENDOR_STRING_1 = TPM2_PT_FIXED + 6,
-	TPM2_PT_VENDOR_STRING_2 = TPM2_PT_FIXED + 7,
-	TPM2_PT_VENDOR_STRING_3 = TPM2_PT_FIXED + 8,
-	TPM2_PT_VENDOR_STRING_4 = TPM2_PT_FIXED + 9,
-	TPM2_PT_VENDOR_TPM_TYPE = TPM2_PT_FIXED + 10,
-	TPM2_PT_FIRMWARE_VERSION_1 = TPM2_PT_FIXED + 11,
-	TPM2_PT_FIRMWARE_VERSION_2 = TPM2_PT_FIXED + 12,
-	TPM2_PT_INPUT_BUFFER = TPM2_PT_FIXED + 13,
-	TPM2_PT_HR_TRANSIENT_MIN = TPM2_PT_FIXED + 14,
-	TPM2_PT_HR_PERSISTENT_MIN = TPM2_PT_FIXED + 15,
-	TPM2_PT_HR_LOADED_MIN = TPM2_PT_FIXED + 16,
-	TPM2_PT_ACTIVE_SESSIONS_MAX = TPM2_PT_FIXED + 17,
-	TPM2_PT_PCR_COUNT = TPM2_PT_FIXED + 18,
-	TPM2_PT_PCR_SELECT_MIN = TPM2_PT_FIXED + 19,
-	TPM2_PT_CONTEXT_GAP_MAX = TPM2_PT_FIXED + 20,
-	TPM2_PT_NV_COUNTERS_MAX = TPM2_PT_FIXED + 22,
-	TPM2_PT_NV_INDEX_MAX = TPM2_PT_FIXED + 23,
-	TPM2_PT_MEMORY = TPM2_PT_FIXED + 24,
-	TPM2_PT_CLOCK_UPDATE = TPM2_PT_FIXED + 25,
-	TPM2_PT_CONTEXT_HASH = TPM2_PT_FIXED + 26,
-	TPM2_PT_CONTEXT_SYM = TPM2_PT_FIXED + 27,
-	TPM2_PT_CONTEXT_SYM_SIZE = TPM2_PT_FIXED + 28,
-	TPM2_PT_ORDERLY_COUNT = TPM2_PT_FIXED + 29,
-	TPM2_PT_MAX_COMMAND_SIZE = TPM2_PT_FIXED + 30,
-	TPM2_PT_MAX_RESPONSE_SIZE = TPM2_PT_FIXED + 31,
-	TPM2_PT_MAX_DIGEST = TPM2_PT_FIXED + 32,
-	TPM2_PT_MAX_OBJECT_CONTEXT = TPM2_PT_FIXED + 33,
-	TPM2_PT_MAX_SESSION_CONTEXT = TPM2_PT_FIXED + 34,
-	TPM2_PT_PS_FAMILY_INDICATOR = TPM2_PT_FIXED + 35,
-	TPM2_PT_PS_LEVEL = TPM2_PT_FIXED + 36,
-	TPM2_PT_PS_REVISION = TPM2_PT_FIXED + 37,
-	TPM2_PT_PS_DAY_OF_YEAR = TPM2_PT_FIXED + 38,
-	TPM2_PT_PS_YEAR = TPM2_PT_FIXED + 39,
-	TPM2_PT_SPLIT_MAX = TPM2_PT_FIXED + 40,
-	TPM2_PT_TOTAL_COMMANDS = TPM2_PT_FIXED + 41,
-	TPM2_PT_LIBRARY_COMMANDS = TPM2_PT_FIXED + 42,
-	TPM2_PT_VENDOR_COMMANDS = TPM2_PT_FIXED + 43,
-	TPM2_PT_NV_BUFFER_MAX = TPM2_PT_FIXED + 44,
-	TPM2_PT_MODES = TPM2_PT_FIXED + 45,
-	TPM2_PT_MAX_CAP_BUFFER = TPM2_PT_FIXED + 46,
-	TPM2_PT_VAR = TPM2_PT_GROUP * 2,
-	TPM2_PT_PERMANENT = TPM2_PT_VAR + 0,
-	TPM2_PT_STARTUP_CLEAR = TPM2_PT_VAR + 1,
-	TPM2_PT_HR_NV_INDEX = TPM2_PT_VAR + 2,
-	TPM2_PT_HR_LOADED = TPM2_PT_VAR + 3,
-	TPM2_PT_HR_LOADED_AVAIL = TPM2_PT_VAR + 4,
-	TPM2_PT_HR_ACTIVE = TPM2_PT_VAR + 5,
-	TPM2_PT_HR_ACTIVE_AVAIL = TPM2_PT_VAR + 6,
-	TPM2_PT_HR_TRANSIENT_AVAIL = TPM2_PT_VAR + 7,
-	TPM2_PT_HR_PERSISTENT = TPM2_PT_VAR + 8,
-	TPM2_PT_HR_PERSISTENT_AVAIL = TPM2_PT_VAR + 9,
-	TPM2_PT_NV_COUNTERS = TPM2_PT_VAR + 10,
-	TPM2_PT_NV_COUNTERS_AVAIL = TPM2_PT_VAR + 11,
-	TPM2_PT_ALGORITHM_SET = TPM2_PT_VAR + 12,
-	TPM2_PT_LOADED_CURVES = TPM2_PT_VAR + 13,
-	TPM2_PT_LOCKOUT_COUNTER = TPM2_PT_VAR + 14,
-	TPM2_PT_MAX_AUTH_FAIL = TPM2_PT_VAR + 15,
-	TPM2_PT_LOCKOUT_INTERVAL = TPM2_PT_VAR + 16,
-	TPM2_PT_LOCKOUT_RECOVERY = TPM2_PT_VAR + 17,
-	TPM2_PT_NV_WRITE_RECOVERY = TPM2_PT_VAR + 18,
-	TPM2_PT_AUDIT_COUNTER_0 = TPM2_PT_VAR + 19,
-	TPM2_PT_AUDIT_COUNTER_1 = TPM2_PT_VAR + 20,
-};
 
 /* 128 bytes is an arbitrary cap. This could be as large as TPM_BUFSIZE - 18
  * bytes, but 128 is still a relatively large number of random bytes and
@@ -263,7 +189,6 @@ static inline void tpm_msleep(unsigned int delay_msec)
 		     delay_msec * 1000);
 };
 
-int tpm_chip_bootstrap(struct tpm_chip *chip);
 int tpm_chip_start(struct tpm_chip *chip);
 void tpm_chip_stop(struct tpm_chip *chip);
 struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip);
diff --git a/drivers/char/tpm/tpm1-cmd.c b/drivers/char/tpm/tpm1-cmd.c
index cf64c7385105..f7dc986fa4a0 100644
--- a/drivers/char/tpm/tpm1-cmd.c
+++ b/drivers/char/tpm/tpm1-cmd.c
@@ -709,12 +709,7 @@ int tpm1_auto_startup(struct tpm_chip *chip)
 	if (rc)
 		goto out;
 	rc = tpm1_do_selftest(chip);
-	if (rc == TPM_ERR_FAILEDSELFTEST) {
-		dev_warn(&chip->dev, "TPM self test failed, switching to the firmware upgrade mode\n");
-		/* A TPM in this state possibly allows or needs a firmware upgrade */
-		chip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;
-		return 0;
-	} else if (rc) {
+	if (rc) {
 		dev_err(&chip->dev, "TPM self test failed\n");
 		goto out;
 	}
diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c
index 65d03867e114..de92065394be 100644
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@ -752,24 +752,8 @@ int tpm2_auto_startup(struct tpm_chip *chip)
 	}
 
 	rc = tpm2_get_cc_attrs_tbl(chip);
-	if (rc == TPM2_RC_FAILURE || (rc < 0 && rc != -ENOMEM)) {
-		dev_info(&chip->dev,
-			 "TPM in field failure mode, requires firmware upgrade\n");
-		chip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;
-		rc = 0;
-	}
 
 out:
-	/*
-	 * Infineon TPM in field upgrade mode will return no data for the number
-	 * of supported commands.
-	 */
-	if (rc == TPM2_RC_UPGRADE || rc == -ENODATA) {
-		dev_info(&chip->dev, "TPM in field upgrade mode, requires firmware upgrade\n");
-		chip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;
-		rc = 0;
-	}
-
 	if (rc > 0)
 		rc = -ENODEV;
 	return rc;
diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index 916f4ff246c1..18606651d1aa 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -98,8 +98,6 @@ struct crb_priv {
 	u8 __iomem *rsp;
 	u32 cmd_size;
 	u32 smc_func_id;
-	u32 __iomem *pluton_start_addr;
-	u32 __iomem *pluton_reply_addr;
 };
 
 struct tpm2_crb_smc {
@@ -110,11 +108,6 @@ struct tpm2_crb_smc {
 	u32 smc_func_id;
 };
 
-struct tpm2_crb_pluton {
-	u64 start_addr;
-	u64 reply_addr;
-};
-
 static bool crb_wait_for_reg_32(u32 __iomem *reg, u32 mask, u32 value,
 				unsigned long timeout)
 {
@@ -134,25 +127,6 @@ static bool crb_wait_for_reg_32(u32 __iomem *reg, u32 mask, u32 value,
 	return ((ioread32(reg) & mask) == value);
 }
 
-static int crb_try_pluton_doorbell(struct crb_priv *priv, bool wait_for_complete)
-{
-	if (priv->sm != ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON)
-		return 0;
-
-	if (!crb_wait_for_reg_32(priv->pluton_reply_addr, ~0, 1, TPM2_TIMEOUT_C))
-		return -ETIME;
-
-	iowrite32(1, priv->pluton_start_addr);
-	if (wait_for_complete == false)
-		return 0;
-
-	if (!crb_wait_for_reg_32(priv->pluton_start_addr,
-				 0xffffffff, 0, 200))
-		return -ETIME;
-
-	return 0;
-}
-
 /**
  * __crb_go_idle - request tpm crb device to go the idle state
  *
@@ -171,8 +145,6 @@ static int crb_try_pluton_doorbell(struct crb_priv *priv, bool wait_for_complete
  */
 static int __crb_go_idle(struct device *dev, struct crb_priv *priv)
 {
-	int rc;
-
 	if ((priv->sm == ACPI_TPM2_START_METHOD) ||
 	    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD) ||
 	    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC))
@@ -180,10 +152,6 @@ static int __crb_go_idle(struct device *dev, struct crb_priv *priv)
 
 	iowrite32(CRB_CTRL_REQ_GO_IDLE, &priv->regs_t->ctrl_req);
 
-	rc = crb_try_pluton_doorbell(priv, true);
-	if (rc)
-		return rc;
-
 	if (!crb_wait_for_reg_32(&priv->regs_t->ctrl_req,
 				 CRB_CTRL_REQ_GO_IDLE/* mask */,
 				 0, /* value */
@@ -220,19 +188,12 @@ static int crb_go_idle(struct tpm_chip *chip)
  */
 static int __crb_cmd_ready(struct device *dev, struct crb_priv *priv)
 {
-	int rc;
-
 	if ((priv->sm == ACPI_TPM2_START_METHOD) ||
 	    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD) ||
 	    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC))
 		return 0;
 
 	iowrite32(CRB_CTRL_REQ_CMD_READY, &priv->regs_t->ctrl_req);
-
-	rc = crb_try_pluton_doorbell(priv, true);
-	if (rc)
-		return rc;
-
 	if (!crb_wait_for_reg_32(&priv->regs_t->ctrl_req,
 				 CRB_CTRL_REQ_CMD_READY /* mask */,
 				 0, /* value */
@@ -291,7 +252,7 @@ static int __crb_relinquish_locality(struct device *dev,
 	iowrite32(CRB_LOC_CTRL_RELINQUISH, &priv->regs_h->loc_ctrl);
 	if (!crb_wait_for_reg_32(&priv->regs_h->loc_state, mask, value,
 				 TPM2_TIMEOUT_C)) {
-		dev_warn(dev, "TPM_LOC_STATE_x.Relinquish timed out\n");
+		dev_warn(dev, "TPM_LOC_STATE_x.requestAccess timed out\n");
 		return -ETIME;
 	}
 
@@ -410,10 +371,6 @@ static int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)
 		return -E2BIG;
 	}
 
-	/* Seems to be necessary for every command */
-	if (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON)
-		__crb_cmd_ready(&chip->dev, priv);
-
 	memcpy_toio(priv->cmd, buf, len);
 
 	/* Make sure that cmd is populated before issuing start. */
@@ -437,10 +394,7 @@ static int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)
 		rc = tpm_crb_smc_start(&chip->dev, priv->smc_func_id);
 	}
 
-	if (rc)
-		return rc;
-
-	return crb_try_pluton_doorbell(priv, false);
+	return rc;
 }
 
 static void crb_cancel(struct tpm_chip *chip)
@@ -570,18 +524,15 @@ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
 		return ret;
 	acpi_dev_free_resource_list(&acpi_resource_list);
 
-	/* Pluton doesn't appear to define ACPI memory regions */
-	if (priv->sm != ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON) {
-		if (resource_type(iores_array) != IORESOURCE_MEM) {
-			dev_err(dev, FW_BUG "TPM2 ACPI table does not define a memory resource\n");
-			return -EINVAL;
-		} else if (resource_type(iores_array + TPM_CRB_MAX_RESOURCES) ==
-			   IORESOURCE_MEM) {
-			dev_warn(dev, "TPM2 ACPI table defines too many memory resources\n");
-			memset(iores_array + TPM_CRB_MAX_RESOURCES,
-			       0, sizeof(*iores_array));
-			iores_array[TPM_CRB_MAX_RESOURCES].flags = 0;
-		}
+	if (resource_type(iores_array) != IORESOURCE_MEM) {
+		dev_err(dev, FW_BUG "TPM2 ACPI table does not define a memory resource\n");
+		return -EINVAL;
+	} else if (resource_type(iores_array + TPM_CRB_MAX_RESOURCES) ==
+		IORESOURCE_MEM) {
+		dev_warn(dev, "TPM2 ACPI table defines too many memory resources\n");
+		memset(iores_array + TPM_CRB_MAX_RESOURCES,
+		       0, sizeof(*iores_array));
+		iores_array[TPM_CRB_MAX_RESOURCES].flags = 0;
 	}
 
 	iores = NULL;
@@ -705,22 +656,6 @@ static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
 	return ret;
 }
 
-static int crb_map_pluton(struct device *dev, struct crb_priv *priv,
-	       struct acpi_table_tpm2 *buf, struct tpm2_crb_pluton *crb_pluton)
-{
-	priv->pluton_start_addr = crb_map_res(dev, NULL, NULL,
-					      crb_pluton->start_addr, 4);
-	if (IS_ERR(priv->pluton_start_addr))
-		return PTR_ERR(priv->pluton_start_addr);
-
-	priv->pluton_reply_addr = crb_map_res(dev, NULL, NULL,
-					      crb_pluton->reply_addr, 4);
-	if (IS_ERR(priv->pluton_reply_addr))
-		return PTR_ERR(priv->pluton_reply_addr);
-
-	return 0;
-}
-
 static int crb_acpi_add(struct acpi_device *device)
 {
 	struct acpi_table_tpm2 *buf;
@@ -728,7 +663,6 @@ static int crb_acpi_add(struct acpi_device *device)
 	struct tpm_chip *chip;
 	struct device *dev = &device->dev;
 	struct tpm2_crb_smc *crb_smc;
-	struct tpm2_crb_pluton *crb_pluton;
 	acpi_status status;
 	u32 sm;
 	int rc;
@@ -742,16 +676,12 @@ static int crb_acpi_add(struct acpi_device *device)
 
 	/* Should the FIFO driver handle this? */
 	sm = buf->start_method;
-	if (sm == ACPI_TPM2_MEMORY_MAPPED) {
-		rc = -ENODEV;
-		goto out;
-	}
+	if (sm == ACPI_TPM2_MEMORY_MAPPED)
+		return -ENODEV;
 
 	priv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);
-	if (!priv) {
-		rc = -ENOMEM;
-		goto out;
-	}
+	if (!priv)
+		return -ENOMEM;
 
 	if (sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC) {
 		if (buf->header.length < (sizeof(*buf) + sizeof(*crb_smc))) {
@@ -759,49 +689,28 @@ static int crb_acpi_add(struct acpi_device *device)
 				FW_BUG "TPM2 ACPI table has wrong size %u for start method type %d\n",
 				buf->header.length,
 				ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC);
-			rc = -EINVAL;
-			goto out;
+			return -EINVAL;
 		}
 		crb_smc = ACPI_ADD_PTR(struct tpm2_crb_smc, buf, sizeof(*buf));
 		priv->smc_func_id = crb_smc->smc_func_id;
 	}
 
-	if (sm == ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON) {
-		if (buf->header.length < (sizeof(*buf) + sizeof(*crb_pluton))) {
-			dev_err(dev,
-				FW_BUG "TPM2 ACPI table has wrong size %u for start method type %d\n",
-				buf->header.length,
-				ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON);
-			return -EINVAL;
-		}
-		crb_pluton = ACPI_ADD_PTR(struct tpm2_crb_pluton, buf, sizeof(*buf));
-		rc = crb_map_pluton(dev, priv, buf, crb_pluton);
-		if (rc)
-			return rc;
-	}
-
 	priv->sm = sm;
 	priv->hid = acpi_device_hid(device);
 
 	rc = crb_map_io(device, priv, buf);
 	if (rc)
-		goto out;
+		return rc;
 
 	chip = tpmm_chip_alloc(dev, &tpm_crb);
-	if (IS_ERR(chip)) {
-		rc = PTR_ERR(chip);
-		goto out;
-	}
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
 
 	dev_set_drvdata(&chip->dev, priv);
 	chip->acpi_dev_handle = device->handle;
 	chip->flags = TPM_CHIP_FLAG_TPM2;
 
-	rc = tpm_chip_register(chip);
-
-out:
-	acpi_put_table((struct acpi_table_header *)buf);
-	return rc;
+	return tpm_chip_register(chip);
 }
 
 static int crb_acpi_remove(struct acpi_device *device)
diff --git a/drivers/char/tpm/tpm_ftpm_tee.c b/drivers/char/tpm/tpm_ftpm_tee.c
index deff23bb54bf..6e3235565a4d 100644
--- a/drivers/char/tpm/tpm_ftpm_tee.c
+++ b/drivers/char/tpm/tpm_ftpm_tee.c
@@ -177,7 +177,7 @@ static u8 ftpm_tee_tpm_op_status(struct tpm_chip *chip)
 
 static bool ftpm_tee_tpm_req_canceled(struct tpm_chip *chip, u8 status)
 {
-	return false;
+	return 0;
 }
 
 static const struct tpm_class_ops ftpm_tee_tpm_ops = {
@@ -397,13 +397,7 @@ static int __init ftpm_mod_init(void)
 	if (rc)
 		return rc;
 
-	rc = driver_register(&ftpm_tee_driver.driver);
-	if (rc) {
-		platform_driver_unregister(&ftpm_tee_plat_driver);
-		return rc;
-	}
-
-	return 0;
+	return driver_register(&ftpm_tee_driver.driver);
 }
 
 static void __exit ftpm_mod_exit(void)
diff --git a/drivers/char/tpm/tpm_i2c_atmel.c b/drivers/char/tpm/tpm_i2c_atmel.c
index 4be3677c1463..d5ac85558214 100644
--- a/drivers/char/tpm/tpm_i2c_atmel.c
+++ b/drivers/char/tpm/tpm_i2c_atmel.c
@@ -179,11 +179,12 @@ static int i2c_atmel_probe(struct i2c_client *client,
 	return tpm_chip_register(chip);
 }
 
-static void i2c_atmel_remove(struct i2c_client *client)
+static int i2c_atmel_remove(struct i2c_client *client)
 {
 	struct device *dev = &(client->dev);
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 	tpm_chip_unregister(chip);
+	return 0;
 }
 
 static const struct i2c_device_id i2c_atmel_id[] = {
diff --git a/drivers/char/tpm/tpm_i2c_infineon.c b/drivers/char/tpm/tpm_i2c_infineon.c
index fd3c3661e646..a19d32cb4e94 100644
--- a/drivers/char/tpm/tpm_i2c_infineon.c
+++ b/drivers/char/tpm/tpm_i2c_infineon.c
@@ -706,13 +706,15 @@ static int tpm_tis_i2c_probe(struct i2c_client *client,
 	return rc;
 }
 
-static void tpm_tis_i2c_remove(struct i2c_client *client)
+static int tpm_tis_i2c_remove(struct i2c_client *client)
 {
 	struct tpm_chip *chip = tpm_dev.chip;
 
 	tpm_chip_unregister(chip);
 	release_locality(chip, tpm_dev.locality, 1);
 	tpm_dev.client = NULL;
+
+	return 0;
 }
 
 static struct i2c_driver tpm_tis_i2c_driver = {
diff --git a/drivers/char/tpm/tpm_i2c_nuvoton.c b/drivers/char/tpm/tpm_i2c_nuvoton.c
index 95c37350cc8e..b77c18e38662 100644
--- a/drivers/char/tpm/tpm_i2c_nuvoton.c
+++ b/drivers/char/tpm/tpm_i2c_nuvoton.c
@@ -622,11 +622,12 @@ static int i2c_nuvoton_probe(struct i2c_client *client,
 	return tpm_chip_register(chip);
 }
 
-static void i2c_nuvoton_remove(struct i2c_client *client)
+static int i2c_nuvoton_remove(struct i2c_client *client)
 {
 	struct tpm_chip *chip = i2c_get_clientdata(client);
 
 	tpm_chip_unregister(chip);
+	return 0;
 }
 
 static const struct i2c_device_id i2c_nuvoton_id[] = {
diff --git a/drivers/char/tpm/tpm_ppi.c b/drivers/char/tpm/tpm_ppi.c
index bc7b1b4501b3..40018a73b3cb 100644
--- a/drivers/char/tpm/tpm_ppi.c
+++ b/drivers/char/tpm/tpm_ppi.c
@@ -380,7 +380,7 @@ void tpm_add_ppi(struct tpm_chip *chip)
 				      TPM_PPI_FN_VERSION,
 				      NULL, ACPI_TYPE_STRING);
 	if (obj) {
-		strscpy(chip->ppi_version, obj->string.pointer,
+		strlcpy(chip->ppi_version, obj->string.pointer,
 			sizeof(chip->ppi_version));
 		ACPI_FREE(obj);
 	}
diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c
index 0d084d6652c4..d3f2e5364c27 100644
--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@ -83,22 +83,6 @@ static const struct dmi_system_id tpm_tis_dmi_table[] = {
 			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T490s"),
 		},
 	},
-	{
-		.callback = tpm_tis_disable_irq,
-		.ident = "ThinkStation P360 Tiny",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkStation P360 Tiny"),
-		},
-	},
-	{
-		.callback = tpm_tis_disable_irq,
-		.ident = "ThinkPad L490",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
-			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad L490"),
-		},
-	},
 	{}
 };
 
@@ -141,7 +125,6 @@ static int check_acpi_tpm2(struct device *dev)
 	const struct acpi_device_id *aid = acpi_match_device(tpm_acpi_tbl, dev);
 	struct acpi_table_tpm2 *tbl;
 	acpi_status st;
-	int ret = 0;
 
 	if (!aid || aid->driver_data != DEVICE_IS_TPM2)
 		return 0;
@@ -149,7 +132,8 @@ static int check_acpi_tpm2(struct device *dev)
 	/* If the ACPI TPM2 signature is matched then a global ACPI_SIG_TPM2
 	 * table is mandatory
 	 */
-	st = acpi_get_table(ACPI_SIG_TPM2, 1, (struct acpi_table_header **)&tbl);
+	st =
+	    acpi_get_table(ACPI_SIG_TPM2, 1, (struct acpi_table_header **)&tbl);
 	if (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {
 		dev_err(dev, FW_BUG "failed to get TPM2 ACPI table\n");
 		return -EINVAL;
@@ -157,10 +141,9 @@ static int check_acpi_tpm2(struct device *dev)
 
 	/* The tpm2_crb driver handles this device */
 	if (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)
-		ret = -ENODEV;
+		return -ENODEV;
 
-	acpi_put_table((struct acpi_table_header *)tbl);
-	return ret;
+	return 0;
 }
 #else
 static int check_acpi_tpm2(struct device *dev)
@@ -170,46 +153,50 @@ static int check_acpi_tpm2(struct device *dev)
 #endif
 
 static int tpm_tcg_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
-			      u8 *result, enum tpm_tis_io_mode io_mode)
+			      u8 *result)
 {
 	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
-	__le16 result_le16;
-	__le32 result_le32;
-
-	switch (io_mode) {
-	case TPM_TIS_PHYS_8:
-		while (len--)
-			*result++ = ioread8(phy->iobase + addr);
-		break;
-	case TPM_TIS_PHYS_16:
-		result_le16 = cpu_to_le16(ioread16(phy->iobase + addr));
-		memcpy(result, &result_le16, sizeof(u16));
-		break;
-	case TPM_TIS_PHYS_32:
-		result_le32 = cpu_to_le32(ioread32(phy->iobase + addr));
-		memcpy(result, &result_le32, sizeof(u32));
-		break;
-	}
+
+	while (len--)
+		*result++ = ioread8(phy->iobase + addr);
 
 	return 0;
 }
 
 static int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
-			       const u8 *value, enum tpm_tis_io_mode io_mode)
+			       const u8 *value)
 {
 	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
 
-	switch (io_mode) {
-	case TPM_TIS_PHYS_8:
-		while (len--)
-			iowrite8(*value++, phy->iobase + addr);
-		break;
-	case TPM_TIS_PHYS_16:
-		return -EINVAL;
-	case TPM_TIS_PHYS_32:
-		iowrite32(le32_to_cpu(*((__le32 *)value)), phy->iobase + addr);
-		break;
-	}
+	while (len--)
+		iowrite8(*value++, phy->iobase + addr);
+
+	return 0;
+}
+
+static int tpm_tcg_read16(struct tpm_tis_data *data, u32 addr, u16 *result)
+{
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	*result = ioread16(phy->iobase + addr);
+
+	return 0;
+}
+
+static int tpm_tcg_read32(struct tpm_tis_data *data, u32 addr, u32 *result)
+{
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	*result = ioread32(phy->iobase + addr);
+
+	return 0;
+}
+
+static int tpm_tcg_write32(struct tpm_tis_data *data, u32 addr, u32 value)
+{
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	iowrite32(value, phy->iobase + addr);
 
 	return 0;
 }
@@ -217,6 +204,9 @@ static int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
 static const struct tpm_tis_phy_ops tpm_tcg = {
 	.read_bytes = tpm_tcg_read_bytes,
 	.write_bytes = tpm_tcg_write_bytes,
+	.read16 = tpm_tcg_read16,
+	.read32 = tpm_tcg_read32,
+	.write32 = tpm_tcg_write32,
 };
 
 static int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info)
@@ -243,7 +233,7 @@ static int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info)
 		irq = tpm_info->irq;
 
 	if (itpm || is_itpm(ACPI_COMPANION(dev)))
-		set_bit(TPM_TIS_ITPM_WORKAROUND, &phy->priv.flags);
+		phy->priv.flags |= TPM_TIS_ITPM_WORKAROUND;
 
 	return tpm_tis_core_init(dev, &phy->priv, irq, &tpm_tcg,
 				 ACPI_HANDLE(dev));
diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c
index 55f6ff1e05aa..c444b3d0b2b9 100644
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -53,63 +53,88 @@ static int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,
 	long rc;
 	u8 status;
 	bool canceled = false;
-	u8 sts_mask = 0;
-	int ret = 0;
 
 	/* check current status */
 	status = chip->ops->status(chip);
 	if ((status & mask) == mask)
 		return 0;
 
-	/* check what status changes can be handled by irqs */
-	if (priv->int_mask & TPM_INTF_STS_VALID_INT)
-		sts_mask |= TPM_STS_VALID;
+	stop = jiffies + timeout;
 
-	if (priv->int_mask & TPM_INTF_DATA_AVAIL_INT)
-		sts_mask |= TPM_STS_DATA_AVAIL;
+	if (chip->flags & TPM_CHIP_FLAG_IRQ) {
+again:
+		timeout = stop - jiffies;
+		if ((long)timeout <= 0)
+			return -ETIME;
+		rc = wait_event_interruptible_timeout(*queue,
+			wait_for_tpm_stat_cond(chip, mask, check_cancel,
+					       &canceled),
+			timeout);
+		if (rc > 0) {
+			if (canceled)
+				return -ECANCELED;
+			return 0;
+		}
+		if (rc == -ERESTARTSYS && freezing(current)) {
+			clear_thread_flag(TIF_SIGPENDING);
+			goto again;
+		}
+	} else {
+		do {
+			usleep_range(priv->timeout_min,
+				     priv->timeout_max);
+			status = chip->ops->status(chip);
+			if ((status & mask) == mask)
+				return 0;
+		} while (time_before(jiffies, stop));
+	}
+	return -ETIME;
+}
 
-	if (priv->int_mask & TPM_INTF_CMD_READY_INT)
-		sts_mask |= TPM_STS_COMMAND_READY;
+static int wait_for_tpm_stat_result (struct tpm_chip *chip, u8 mask ,u8 mask_result
+,unsigned long timeout, wait_queue_head_t *queue,	bool check_cancel)
+{
+	unsigned long stop;
+	long rc;
+	u8 status;
+	bool canceled = false;
+	/* check current status */
+	status = chip->ops->status(chip);
 
-	sts_mask &= mask;
+	if ((status & mask) == mask_result)
+					return 0;
 
 	stop = jiffies + timeout;
-	/* process status changes with irq support */
-	if (sts_mask) {
-		ret = -ETIME;
+
+	if (chip->flags & TPM_CHIP_FLAG_IRQ) {
 again:
 		timeout = stop - jiffies;
 		if ((long)timeout <= 0)
 			return -ETIME;
 		rc = wait_event_interruptible_timeout(*queue,
-			wait_for_tpm_stat_cond(chip, sts_mask, check_cancel,
+			wait_for_tpm_stat_cond(chip, mask, check_cancel,
 					       &canceled),
 			timeout);
 		if (rc > 0) {
 			if (canceled)
 				return -ECANCELED;
-			ret = 0;
+			return 0;
 		}
 		if (rc == -ERESTARTSYS && freezing(current)) {
 			clear_thread_flag(TIF_SIGPENDING);
 			goto again;
 		}
-	}
+	} else {
+		do {
+			usleep_range(TPM_TIMEOUT_USECS_MIN,
+				     TPM_TIMEOUT_USECS_MAX);
+			status = chip->ops->status(chip);
 
-	if (ret)
-		return ret;
+			if ((status & mask) == mask_result)
+					return 0;
 
-	mask &= ~sts_mask;
-	if (!mask) /* all done */
-		return 0;
-	/* process status changes without irq support */
-	do {
-		status = chip->ops->status(chip);
-		if ((status & mask) == mask)
-			return 0;
-		usleep_range(priv->timeout_min,
-			     priv->timeout_max);
-	} while (time_before(jiffies, stop));
+		} while (time_before(jiffies, stop));
+	}
 	return -ETIME;
 }
 
@@ -158,27 +183,16 @@ static bool check_locality(struct tpm_chip *chip, int l)
 	return false;
 }
 
-static int __tpm_tis_relinquish_locality(struct tpm_tis_data *priv, int l)
-{
-	tpm_tis_write8(priv, TPM_ACCESS(l), TPM_ACCESS_ACTIVE_LOCALITY);
-
-	return 0;
-}
-
-static int tpm_tis_relinquish_locality(struct tpm_chip *chip, int l)
+static int release_locality(struct tpm_chip *chip, int l)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 
-	mutex_lock(&priv->locality_count_mutex);
-	priv->locality_count--;
-	if (priv->locality_count == 0)
-		__tpm_tis_relinquish_locality(priv, l);
-	mutex_unlock(&priv->locality_count_mutex);
+	tpm_tis_write8(priv, TPM_ACCESS(l), TPM_ACCESS_ACTIVE_LOCALITY);
 
 	return 0;
 }
 
-static int __tpm_tis_request_locality(struct tpm_chip *chip, int l)
+static int request_locality(struct tpm_chip *chip, int l)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	unsigned long stop, timeout;
@@ -219,20 +233,6 @@ static int __tpm_tis_request_locality(struct tpm_chip *chip, int l)
 	return -1;
 }
 
-static int tpm_tis_request_locality(struct tpm_chip *chip, int l)
-{
-	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-	int ret = 0;
-
-	mutex_lock(&priv->locality_count_mutex);
-	if (priv->locality_count == 0)
-		ret = __tpm_tis_request_locality(chip, l);
-	if (!ret)
-		priv->locality_count++;
-	mutex_unlock(&priv->locality_count_mutex);
-	return ret;
-}
-
 static u8 tpm_tis_status(struct tpm_chip *chip)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
@@ -268,6 +268,16 @@ static u8 tpm_tis_status(struct tpm_chip *chip)
 	return status;
 }
 
+static bool tpm_tis_check_data(struct tpm_chip *chip, const u8 *buf,
+size_t len) {
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+
+	if (priv->phy_ops->check_data)
+		return priv->phy_ops->check_data(priv, buf, len);
+	return true;
+}
+
+
 static void tpm_tis_ready(struct tpm_chip *chip)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
@@ -334,15 +344,16 @@ static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int size = 0;
-	int status;
+	int status,i;
 	u32 expected;
-	int rc;
-
-	if (count < TPM_HEADER_SIZE) {
-		size = -EIO;
-		goto out;
-	}
+	bool check_data = false;
 
+	for (i = 0; i < TPM_RETRY; i++)
+	{
+		if (count < TPM_HEADER_SIZE) {
+			size = -EIO;
+			goto out;
+		}
 	size = recv_data(chip, buf, TPM_HEADER_SIZE);
 	/* read first 10 bytes, including tag, paramsize, and result */
 	if (size < TPM_HEADER_SIZE) {
@@ -365,24 +376,28 @@ static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 	}
 
 	if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
-				&priv->int_queue, false) < 0) {
-		size = -ETIME;
-		goto out;
-	}
-	status = tpm_tis_status(chip);
-	if (status & TPM_STS_DATA_AVAIL) {	/* retry? */
-		dev_err(&chip->dev, "Error left over data\n");
-		size = -EIO;
-		goto out;
-	}
+				      &priv->int_queue, false) < 0) {
+			size = -ETIME;
+			goto out;
+		}
 
-	rc = tpm_tis_verify_crc(priv, (size_t)size, buf);
-	if (rc < 0) {
-		dev_err(&chip->dev, "CRC mismatch for response.\n");
-		size = rc;
-		goto out;
+		status = tpm_tis_status(chip);
+		if (status & TPM_STS_DATA_AVAIL) {	/* retry? */
+			dev_err(&chip->dev, "Error left over data\n");
+			size = -EIO;
+			goto out;
+		}
+
+		check_data = tpm_tis_check_data(chip, buf, size);
+		if (!check_data)
+			tpm_tis_write8(priv, TPM_STS(priv->locality),
+				       TPM_STS_RESPONSE_RETRY);
+		else break;
 	}
 
+		if (!check_data)
+		 size = -EIO;
+
 out:
 	tpm_tis_ready(chip);
 	return size;
@@ -398,7 +413,7 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int rc, status, burstcnt;
 	size_t count = 0;
-	bool itpm = test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);
+
 
 	status = tpm_tis_status(chip);
 	if ((status & TPM_STS_COMMAND_READY) == 0) {
@@ -425,35 +440,27 @@ static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)
 			goto out_err;
 
 		count += burstcnt;
+        if (wait_for_tpm_stat_result (chip, TPM_STS_VALID | TPM_STS_DATA_EXPECT,TPM_STS_VALID | TPM_STS_DATA_EXPECT, chip->timeout_c,
+				&priv->int_queue, false) < 0) {
+		rc = -ETIME;
+		goto out_err;
+	    }
 
-		if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
-					&priv->int_queue, false) < 0) {
-			rc = -ETIME;
-			goto out_err;
-		}
-		status = tpm_tis_status(chip);
-		if (!itpm && (status & TPM_STS_DATA_EXPECT) == 0) {
-			rc = -EIO;
-			goto out_err;
-		}
 	}
 
 	/* write last byte */
 	rc = tpm_tis_write8(priv, TPM_DATA_FIFO(priv->locality), buf[count]);
+
 	if (rc < 0)
 		goto out_err;
 
-	if (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
-				&priv->int_queue, false) < 0) {
-		rc = -ETIME;
-		goto out_err;
-	}
-	status = tpm_tis_status(chip);
-	if (!itpm && (status & TPM_STS_DATA_EXPECT) != 0) {
-		rc = -EIO;
-		goto out_err;
+	if (wait_for_tpm_stat_result(chip, TPM_STS_VALID | TPM_STS_DATA_EXPECT, TPM_STS_VALID , chip->timeout_a,
+					&priv->int_queue, false) < 0) {
+			rc = -ETIME;
+			goto out_err;
 	}
 
+
 	return 0;
 
 out_err:
@@ -490,21 +497,25 @@ static void disable_interrupts(struct tpm_chip *chip)
 static int tpm_tis_send_main(struct tpm_chip *chip, const u8 *buf, size_t len)
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-	int rc;
+	int rc,i;
 	u32 ordinal;
 	unsigned long dur;
+	bool data_valid = false;
 
-	rc = tpm_tis_send_data(chip, buf, len);
-	if (rc < 0)
-		return rc;
+	//rc = tpm_tis_send_data(chip, buf, len);
+	//if (rc < 0)
+	//	return rc;
 
-	rc = tpm_tis_verify_crc(priv, len, buf);
-	if (rc < 0) {
-		dev_err(&chip->dev, "CRC mismatch for command.\n");
-		return rc;
+	/* go and do it */
+	for (i = 0; i < TPM_RETRY && !data_valid; i++) {
+		rc = tpm_tis_send_data(chip, buf, len);
+		if (rc < 0)
+			return rc;
+		data_valid = tpm_tis_check_data(chip, buf, len);
 	}
+	if (!data_valid)
+		return -EIO;
 
-	/* go and do it */
 	rc = tpm_tis_write8(priv, TPM_STS(priv->locality), TPM_STS_GO);
 	if (rc < 0)
 		goto out_err;
@@ -531,8 +542,7 @@ static int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)
 	int rc, irq;
 	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 
-	if (!(chip->flags & TPM_CHIP_FLAG_IRQ) ||
-	     test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))
+	if (!(chip->flags & TPM_CHIP_FLAG_IRQ) || priv->irq_tested)
 		return tpm_tis_send_main(chip, buf, len);
 
 	/* Verify receipt of the expected IRQ */
@@ -542,11 +552,11 @@ static int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)
 	rc = tpm_tis_send_main(chip, buf, len);
 	priv->irq = irq;
 	chip->flags |= TPM_CHIP_FLAG_IRQ;
-	if (!test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))
+	if (!priv->irq_tested)
 		tpm_msleep(1);
-	if (!test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))
+	if (!priv->irq_tested)
 		disable_interrupts(chip);
-	set_bit(TPM_TIS_IRQ_TESTED, &priv->flags);
+	priv->irq_tested = true;
 	return rc;
 }
 
@@ -689,7 +699,7 @@ static int probe_itpm(struct tpm_chip *chip)
 	size_t len = sizeof(cmd_getticks);
 	u16 vendor;
 
-	if (test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags))
+	if (priv->flags & TPM_TIS_ITPM_WORKAROUND)
 		return 0;
 
 	rc = tpm_tis_read16(priv, TPM_DID_VID(0), &vendor);
@@ -700,7 +710,7 @@ static int probe_itpm(struct tpm_chip *chip)
 	if (vendor != TPM_VID_INTEL)
 		return 0;
 
-	if (tpm_tis_request_locality(chip, 0) != 0)
+	if (request_locality(chip, 0) != 0)
 		return -EBUSY;
 
 	rc = tpm_tis_send_data(chip, cmd_getticks, len);
@@ -709,40 +719,26 @@ static int probe_itpm(struct tpm_chip *chip)
 
 	tpm_tis_ready(chip);
 
-	set_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);
+	priv->flags |= TPM_TIS_ITPM_WORKAROUND;
 
 	rc = tpm_tis_send_data(chip, cmd_getticks, len);
 	if (rc == 0)
 		dev_info(&chip->dev, "Detected an iTPM.\n");
 	else {
-		clear_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);
+		priv->flags &= ~TPM_TIS_ITPM_WORKAROUND;
 		rc = -EFAULT;
 	}
 
 out:
 	tpm_tis_ready(chip);
-	tpm_tis_relinquish_locality(chip, priv->locality);
+	release_locality(chip, priv->locality);
 
 	return rc;
 }
 
 static bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)
 {
-	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
-
-	if (!test_bit(TPM_TIS_DEFAULT_CANCELLATION, &priv->flags)) {
-		switch (priv->manufacturer_id) {
-		case TPM_VID_WINBOND:
-			return ((status == TPM_STS_VALID) ||
-				(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));
-		case TPM_VID_STM:
-			return (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));
-		default:
-			break;
-		}
-	}
-
-	return status == TPM_STS_COMMAND_READY;
+	return ((status & TPM_STS_COMMAND_READY) == TPM_STS_COMMAND_READY);
 }
 
 static irqreturn_t tis_int_handler(int dummy, void *dev_id)
@@ -759,7 +755,7 @@ static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 	if (interrupt == 0)
 		return IRQ_NONE;
 
-	set_bit(TPM_TIS_IRQ_TESTED, &priv->flags);
+	priv->irq_tested = true;
 	if (interrupt & TPM_INTF_DATA_AVAIL_INT)
 		wake_up_interruptible(&priv->read_queue);
 	if (interrupt & TPM_INTF_LOCALITY_CHANGE_INT)
@@ -772,9 +768,7 @@ static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 		wake_up_interruptible(&priv->int_queue);
 
 	/* Clear interrupts handled with TPM_EOI */
-	tpm_tis_request_locality(chip, 0);
 	rc = tpm_tis_write32(priv, TPM_INT_STATUS(priv->locality), interrupt);
-	tpm_tis_relinquish_locality(chip, 0);
 	if (rc < 0)
 		return IRQ_NONE;
 
@@ -782,17 +776,25 @@ static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void tpm_tis_gen_interrupt(struct tpm_chip *chip)
+static int tpm_tis_gen_interrupt(struct tpm_chip *chip)
 {
 	const char *desc = "attempting to generate an interrupt";
 	u32 cap2;
 	cap_t cap;
 	int ret;
 
+	ret = request_locality(chip, 0);
+	if (ret < 0)
+		return ret;
+
 	if (chip->flags & TPM_CHIP_FLAG_TPM2)
 		ret = tpm2_get_tpm_pt(chip, 0x100, &cap2, desc);
 	else
 		ret = tpm1_getcap(chip, TPM_CAP_PROP_TIS_TIMEOUT, &cap, desc, 0);
+
+	release_locality(chip, 0);
+
+	return ret;
 }
 
 /* Register the IRQ and issue a command that will cause an interrupt. If an
@@ -807,66 +809,60 @@ static int tpm_tis_probe_irq_single(struct tpm_chip *chip, u32 intmask,
 	int rc;
 	u32 int_status;
 
-
-	rc = devm_request_threaded_irq(chip->dev.parent, irq, NULL,
-				       tis_int_handler, IRQF_ONESHOT | flags,
-				       dev_name(&chip->dev), chip);
-	if (rc) {
+	if (devm_request_irq(chip->dev.parent, irq, tis_int_handler, flags,
+			     dev_name(&chip->dev), chip) != 0) {
 		dev_info(&chip->dev, "Unable to request irq: %d for probe\n",
 			 irq);
 		return -1;
 	}
 	priv->irq = irq;
 
-	rc = tpm_tis_request_locality(chip, 0);
-	if (rc < 0)
-		return rc;
-
 	rc = tpm_tis_read8(priv, TPM_INT_VECTOR(priv->locality),
 			   &original_int_vec);
-	if (rc < 0) {
-		tpm_tis_relinquish_locality(chip, priv->locality);
+	if (rc < 0)
 		return rc;
-	}
 
 	rc = tpm_tis_write8(priv, TPM_INT_VECTOR(priv->locality), irq);
 	if (rc < 0)
-		goto restore_irqs;
+		return rc;
 
 	rc = tpm_tis_read32(priv, TPM_INT_STATUS(priv->locality), &int_status);
 	if (rc < 0)
-		goto restore_irqs;
+		return rc;
 
 	/* Clear all existing */
 	rc = tpm_tis_write32(priv, TPM_INT_STATUS(priv->locality), int_status);
 	if (rc < 0)
-		goto restore_irqs;
+		return rc;
+
 	/* Turn on */
 	rc = tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality),
 			     intmask | TPM_GLOBAL_INT_ENABLE);
 	if (rc < 0)
-		goto restore_irqs;
+		return rc;
 
-	clear_bit(TPM_TIS_IRQ_TESTED, &priv->flags);
+	priv->irq_tested = false;
 
 	/* Generate an interrupt by having the core call through to
 	 * tpm_tis_send
 	 */
-	tpm_tis_gen_interrupt(chip);
+	rc = tpm_tis_gen_interrupt(chip);
+	if (rc < 0)
+		return rc;
 
-restore_irqs:
 	/* tpm_tis_send will either confirm the interrupt is working or it
 	 * will call disable_irq which undoes all of the above.
 	 */
 	if (!(chip->flags & TPM_CHIP_FLAG_IRQ)) {
-		tpm_tis_write8(priv, original_int_vec,
-			       TPM_INT_VECTOR(priv->locality));
-		rc = -1;
-	}
+		rc = tpm_tis_write8(priv, original_int_vec,
+				TPM_INT_VECTOR(priv->locality));
+		if (rc < 0)
+			return rc;
 
-	tpm_tis_relinquish_locality(chip, priv->locality);
+		return 1;
+	}
 
-	return rc;
+	return 0;
 }
 
 /* Try to find the IRQ the TPM is using. This is for legacy x86 systems that
@@ -980,8 +976,8 @@ static const struct tpm_class_ops tpm_tis = {
 	.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,
 	.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,
 	.req_canceled = tpm_tis_req_canceled,
-	.request_locality = tpm_tis_request_locality,
-	.relinquish_locality = tpm_tis_relinquish_locality,
+	.request_locality = request_locality,
+	.relinquish_locality = release_locality,
 	.clk_enable = tpm_tis_clkrun_enable,
 };
 
@@ -1015,8 +1011,6 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	priv->timeout_min = TPM_TIMEOUT_USECS_MIN;
 	priv->timeout_max = TPM_TIMEOUT_USECS_MAX;
 	priv->phy_ops = phy_ops;
-	priv->locality_count = 0;
-	mutex_init(&priv->locality_count_mutex);
 
 	dev_set_drvdata(&chip->dev, priv);
 
@@ -1059,50 +1053,18 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	if (rc < 0)
 		goto out_err;
 
-	/* Figure out the capabilities */
-	rc = tpm_tis_read32(priv, TPM_INTF_CAPS(priv->locality), &intfcaps);
-	if (rc < 0)
-		goto out_err;
-
-	dev_dbg(dev, "TPM interface capabilities (0x%x):\n",
-		intfcaps);
-	if (intfcaps & TPM_INTF_BURST_COUNT_STATIC)
-		dev_dbg(dev, "\tBurst Count Static\n");
-	if (intfcaps & TPM_INTF_CMD_READY_INT) {
-		intmask |= TPM_INTF_CMD_READY_INT;
-		dev_dbg(dev, "\tCommand Ready Int Support\n");
-	}
-	if (intfcaps & TPM_INTF_INT_EDGE_FALLING)
-		dev_dbg(dev, "\tInterrupt Edge Falling\n");
-	if (intfcaps & TPM_INTF_INT_EDGE_RISING)
-		dev_dbg(dev, "\tInterrupt Edge Rising\n");
-	if (intfcaps & TPM_INTF_INT_LEVEL_LOW)
-		dev_dbg(dev, "\tInterrupt Level Low\n");
-	if (intfcaps & TPM_INTF_INT_LEVEL_HIGH)
-		dev_dbg(dev, "\tInterrupt Level High\n");
-	if (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT) {
-		intmask |= TPM_INTF_LOCALITY_CHANGE_INT;
-		dev_dbg(dev, "\tLocality Change Int Support\n");
-	}
-	if (intfcaps & TPM_INTF_STS_VALID_INT) {
-		intmask |= TPM_INTF_STS_VALID_INT;
-		dev_dbg(dev, "\tSts Valid Int Support\n");
-	}
-	if (intfcaps & TPM_INTF_DATA_AVAIL_INT) {
-		intmask |= TPM_INTF_DATA_AVAIL_INT;
-		dev_dbg(dev, "\tData Avail Int Support\n");
-	}
-
+	intmask |= TPM_INTF_CMD_READY_INT | TPM_INTF_LOCALITY_CHANGE_INT |
+		   TPM_INTF_DATA_AVAIL_INT | TPM_INTF_STS_VALID_INT;
 	intmask &= ~TPM_GLOBAL_INT_ENABLE;
 
-	rc = tpm_tis_request_locality(chip, 0);
+	rc = request_locality(chip, 0);
 	if (rc < 0) {
 		rc = -ENODEV;
 		goto out_err;
 	}
 
 	tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);
-	tpm_tis_relinquish_locality(chip, 0);
+	release_locality(chip, 0);
 
 	rc = tpm_chip_start(chip);
 	if (rc)
@@ -1126,14 +1088,35 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 		goto out_err;
 	}
 
+	/* Figure out the capabilities */
+	rc = tpm_tis_read32(priv, TPM_INTF_CAPS(priv->locality), &intfcaps);
+	if (rc < 0)
+		goto out_err;
+
+	dev_dbg(dev, "TPM interface capabilities (0x%x):\n",
+		intfcaps);
+	if (intfcaps & TPM_INTF_BURST_COUNT_STATIC)
+		dev_dbg(dev, "\tBurst Count Static\n");
+	if (intfcaps & TPM_INTF_CMD_READY_INT)
+		dev_dbg(dev, "\tCommand Ready Int Support\n");
+	if (intfcaps & TPM_INTF_INT_EDGE_FALLING)
+		dev_dbg(dev, "\tInterrupt Edge Falling\n");
+	if (intfcaps & TPM_INTF_INT_EDGE_RISING)
+		dev_dbg(dev, "\tInterrupt Edge Rising\n");
+	if (intfcaps & TPM_INTF_INT_LEVEL_LOW)
+		dev_dbg(dev, "\tInterrupt Level Low\n");
+	if (intfcaps & TPM_INTF_INT_LEVEL_HIGH)
+		dev_dbg(dev, "\tInterrupt Level High\n");
+	if (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT)
+		dev_dbg(dev, "\tLocality Change Int Support\n");
+	if (intfcaps & TPM_INTF_STS_VALID_INT)
+		dev_dbg(dev, "\tSts Valid Int Support\n");
+	if (intfcaps & TPM_INTF_DATA_AVAIL_INT)
+		dev_dbg(dev, "\tData Avail Int Support\n");
+
 	/* INTERRUPT Setup */
 	init_waitqueue_head(&priv->read_queue);
 	init_waitqueue_head(&priv->int_queue);
-
-	rc = tpm_chip_bootstrap(chip);
-	if (rc)
-		goto out_err;
-
 	if (irq != -1) {
 		/*
 		 * Before doing irq testing issue a command to the TPM in polling mode
@@ -1141,13 +1124,13 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 		 * proper timeouts for the driver.
 		 */
 
-		rc = tpm_tis_request_locality(chip, 0);
+		rc = request_locality(chip, 0);
 		if (rc < 0)
 			goto out_err;
 
 		rc = tpm_get_timeouts(chip);
 
-		tpm_tis_relinquish_locality(chip, 0);
+		release_locality(chip, 0);
 
 		if (rc) {
 			dev_err(dev, "Could not get TPM timeouts and durations\n");
@@ -1155,23 +1138,17 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 			goto out_err;
 		}
 
-		if (irq)
+		if (irq) {
 			tpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,
 						 irq);
-		else
-			tpm_tis_probe_irq(chip, intmask);
-
-		if (chip->flags & TPM_CHIP_FLAG_IRQ) {
-			priv->int_mask = intmask;
-		} else {
-			dev_err(&chip->dev, FW_BUG
+			if (!(chip->flags & TPM_CHIP_FLAG_IRQ)) {
+				dev_err(&chip->dev, FW_BUG
 					"TPM interrupt not working, polling instead\n");
 
-			rc = tpm_tis_request_locality(chip, 0);
-			if (rc < 0)
-				goto out_err;
-			disable_interrupts(chip);
-			tpm_tis_relinquish_locality(chip, 0);
+				disable_interrupts(chip);
+			}
+		} else {
+			tpm_tis_probe_irq(chip, intmask);
 		}
 	}
 
@@ -1200,20 +1177,31 @@ static void tpm_tis_reenable_interrupts(struct tpm_chip *chip)
 	u32 intmask;
 	int rc;
 
-	/*
-	 * Re-enable interrupts that device may have lost or BIOS/firmware may
-	 * have disabled.
+	if (chip->ops->clk_enable != NULL)
+		chip->ops->clk_enable(chip, true);
+
+	/* reenable interrupts that device may have lost or
+	 * BIOS/firmware may have disabled
 	 */
 	rc = tpm_tis_write8(priv, TPM_INT_VECTOR(priv->locality), priv->irq);
-	if (rc < 0) {
-		dev_err(&chip->dev, "Setting IRQ failed.\n");
-		return;
-	}
+	if (rc < 0)
+		goto out;
 
-	intmask = priv->int_mask | TPM_GLOBAL_INT_ENABLE;
-	rc = tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);
+	rc = tpm_tis_read32(priv, TPM_INT_ENABLE(priv->locality), &intmask);
 	if (rc < 0)
-		dev_err(&chip->dev, "Enabling interrupts failed.\n");
+		goto out;
+
+	intmask |= TPM_INTF_CMD_READY_INT
+	    | TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT
+	    | TPM_INTF_STS_VALID_INT | TPM_GLOBAL_INT_ENABLE;
+
+	tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);
+
+out:
+	if (chip->ops->clk_enable != NULL)
+		chip->ops->clk_enable(chip, false);
+
+	return;
 }
 
 int tpm_tis_resume(struct device *dev)
@@ -1221,25 +1209,26 @@ int tpm_tis_resume(struct device *dev)
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 	int ret;
 
-	ret = tpm_chip_start(chip);
-	if (ret)
-		return ret;
-
 	if (chip->flags & TPM_CHIP_FLAG_IRQ)
 		tpm_tis_reenable_interrupts(chip);
 
+	ret = tpm_pm_resume(dev);
+	if (ret)
+		return ret;
+
 	/*
 	 * TPM 1.2 requires self-test on resume. This function actually returns
 	 * an error code but for unknown reason it isn't handled.
 	 */
-	if (!(chip->flags & TPM_CHIP_FLAG_TPM2))
-		tpm1_do_selftest(chip);
+	if (!(chip->flags & TPM_CHIP_FLAG_TPM2)) {
+		ret = request_locality(chip, 0);
+		if (ret < 0)
+			return ret;
 
-	tpm_chip_stop(chip);
+		tpm1_do_selftest(chip);
 
-	ret = tpm_pm_resume(dev);
-	if (ret)
-		return ret;
+		release_locality(chip, 0);
+	}
 
 	return 0;
 }
diff --git a/drivers/char/tpm/tpm_tis_core.h b/drivers/char/tpm/tpm_tis_core.h
index 610bfadb6acf..bb7343a453a2 100644
--- a/drivers/char/tpm/tpm_tis_core.h
+++ b/drivers/char/tpm/tpm_tis_core.h
@@ -34,6 +34,7 @@ enum tis_status {
 	TPM_STS_GO = 0x20,
 	TPM_STS_DATA_AVAIL = 0x10,
 	TPM_STS_DATA_EXPECT = 0x08,
+	TPM_STS_RESPONSE_RETRY = 0x02,
 	TPM_STS_READ_ZERO = 0x23, /* bits that must be zero on read */
 };
 
@@ -84,19 +85,15 @@ enum tis_defaults {
 #define ILB_REMAP_SIZE			0x100
 
 enum tpm_tis_flags {
-	TPM_TIS_ITPM_WORKAROUND		= 0,
-	TPM_TIS_INVALID_STATUS		= 1,
-	TPM_TIS_DEFAULT_CANCELLATION	= 2,
-	TPM_TIS_IRQ_TESTED		= 3,
+	TPM_TIS_ITPM_WORKAROUND		= BIT(0),
+	TPM_TIS_INVALID_STATUS		= BIT(1),
 };
 
 struct tpm_tis_data {
 	u16 manufacturer_id;
-	struct mutex locality_count_mutex;
-	unsigned int locality_count;
 	int locality;
 	int irq;
-	unsigned int int_mask;
+	bool irq_tested;
 	unsigned long flags;
 	void __iomem *ilb_base_addr;
 	u16 clkrun_enabled;
@@ -108,37 +105,26 @@ struct tpm_tis_data {
 	unsigned int timeout_max; /* usecs */
 };
 
-/*
- * IO modes to indicate how many bytes should be read/written at once in the
- * tpm_tis_phy_ops read_bytes/write_bytes calls. Use TPM_TIS_PHYS_8 to
- * receive/transmit byte-wise, TPM_TIS_PHYS_16 for two bytes etc.
- */
-enum tpm_tis_io_mode {
-	TPM_TIS_PHYS_8,
-	TPM_TIS_PHYS_16,
-	TPM_TIS_PHYS_32,
-};
-
 struct tpm_tis_phy_ops {
-	/* data is passed in little endian */
 	int (*read_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,
-			  u8 *result, enum tpm_tis_io_mode mode);
+			  u8 *result);
 	int (*write_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,
-			   const u8 *value, enum tpm_tis_io_mode mode);
-	int (*verify_crc)(struct tpm_tis_data *data, size_t len,
-			  const u8 *value);
+			   const u8 *value);
+	int (*read16)(struct tpm_tis_data *data, u32 addr, u16 *result);
+	int (*read32)(struct tpm_tis_data *data, u32 addr, u32 *result);
+	int (*write32)(struct tpm_tis_data *data, u32 addr, u32 src);
+    bool (*check_data)(struct tpm_tis_data *data, const u8 *buf, size_t len);
 };
 
 static inline int tpm_tis_read_bytes(struct tpm_tis_data *data, u32 addr,
 				     u16 len, u8 *result)
 {
-	return data->phy_ops->read_bytes(data, addr, len, result,
-					 TPM_TIS_PHYS_8);
+	return data->phy_ops->read_bytes(data, addr, len, result);
 }
 
 static inline int tpm_tis_read8(struct tpm_tis_data *data, u32 addr, u8 *result)
 {
-	return data->phy_ops->read_bytes(data, addr, 1, result, TPM_TIS_PHYS_8);
+	return data->phy_ops->read_bytes(data, addr, 1, result);
 }
 
 static inline int tpm_tis_read16(struct tpm_tis_data *data, u32 addr,
@@ -147,8 +133,11 @@ static inline int tpm_tis_read16(struct tpm_tis_data *data, u32 addr,
 	__le16 result_le;
 	int rc;
 
+	if (data->phy_ops->read16)
+		return data->phy_ops->read16(data, addr, result);
+
 	rc = data->phy_ops->read_bytes(data, addr, sizeof(u16),
-				       (u8 *)&result_le, TPM_TIS_PHYS_16);
+				       (u8 *)&result_le);
 	if (!rc)
 		*result = le16_to_cpu(result_le);
 
@@ -161,8 +150,11 @@ static inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,
 	__le32 result_le;
 	int rc;
 
+	if (data->phy_ops->read32)
+		return data->phy_ops->read32(data, addr, result);
+
 	rc = data->phy_ops->read_bytes(data, addr, sizeof(u32),
-				       (u8 *)&result_le, TPM_TIS_PHYS_32);
+				       (u8 *)&result_le);
 	if (!rc)
 		*result = le32_to_cpu(result_le);
 
@@ -172,14 +164,13 @@ static inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,
 static inline int tpm_tis_write_bytes(struct tpm_tis_data *data, u32 addr,
 				      u16 len, const u8 *value)
 {
-	return data->phy_ops->write_bytes(data, addr, len, value,
-					  TPM_TIS_PHYS_8);
+	return data->phy_ops->write_bytes(data, addr, len, value);
+
 }
 
 static inline int tpm_tis_write8(struct tpm_tis_data *data, u32 addr, u8 value)
 {
-	return data->phy_ops->write_bytes(data, addr, 1, &value,
-					  TPM_TIS_PHYS_8);
+	return data->phy_ops->write_bytes(data, addr, 1, &value);
 }
 
 static inline int tpm_tis_write32(struct tpm_tis_data *data, u32 addr,
@@ -188,18 +179,14 @@ static inline int tpm_tis_write32(struct tpm_tis_data *data, u32 addr,
 	__le32 value_le;
 	int rc;
 
+	if (data->phy_ops->write32)
+		return data->phy_ops->write32(data, addr, value);
+
 	value_le = cpu_to_le32(value);
-	rc =  data->phy_ops->write_bytes(data, addr, sizeof(u32),
-					 (u8 *)&value_le, TPM_TIS_PHYS_32);
-	return rc;
-}
+	rc = data->phy_ops->write_bytes(data, addr, sizeof(u32),
+					(u8 *)&value_le);
 
-static inline int tpm_tis_verify_crc(struct tpm_tis_data *data, size_t len,
-				     const u8 *value)
-{
-	if (!data->phy_ops->verify_crc)
-		return 0;
-	return data->phy_ops->verify_crc(data, len, value);
+	return rc;
 }
 
 static inline bool is_bsw(void)
diff --git a/drivers/char/tpm/tpm_tis_i2c.c b/drivers/char/tpm/tpm_tis_i2c.c
index f3a7251c8e38..91b45cfeef1d 100644
--- a/drivers/char/tpm/tpm_tis_i2c.c
+++ b/drivers/char/tpm/tpm_tis_i2c.c
@@ -1,389 +1,287 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2014-2021 Nuvoton Technology corporation
- * Copyright (C) 2019-2022 Infineon Technologies AG
+ * Copyright (c) 2014-2019 Nuvoton Technology corporation
+ * Copyright (c) 2020, STMICROELECTRONICS International, NV All rights reserved.
  *
- * This device driver implements the TPM interface as defined in the TCG PC
- * Client Platform TPM Profile (PTP) Specification for TPM 2.0 v1.04
- * Revision 14.
+ * TPM TIS I2C
  *
- * It is based on the tpm_tis_spi device driver.
+ * TPM TIS I2C Device Driver Interface for devices that implement the TPM I2C
+ * Interface defined by TCG PC Client Platform TPM Profile (PTP) Specification
+ * Revision 01.03 v22 at www.trustedcomputinggroup.org
  */
 
-#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/acpi.h>
+#include <linux/freezer.h>
 #include <linux/crc-ccitt.h>
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/tpm.h>
+#include "tpm.h"
 #include "tpm_tis_core.h"
 
-/* TPM registers */
-#define TPM_I2C_LOC_SEL 0x00
-#define TPM_I2C_ACCESS 0x04
-#define TPM_I2C_INTERFACE_CAPABILITY 0x30
-#define TPM_I2C_DEVICE_ADDRESS 0x38
-#define TPM_I2C_DATA_CSUM_ENABLE 0x40
-#define TPM_DATA_CSUM 0x44
-#define TPM_I2C_DID_VID 0x48
-#define TPM_I2C_RID 0x4C
-
-/* TIS-compatible register address to avoid clash with TPM_ACCESS (0x00) */
-#define TPM_LOC_SEL 0x0FFF
-
-/* Mask to extract the I2C register from TIS register addresses */
-#define TPM_TIS_REGISTER_MASK 0x0FFF
-
-/* Default Guard Time of 250µs until interface capability register is read */
-#define GUARD_TIME_DEFAULT_MIN 250
-#define GUARD_TIME_DEFAULT_MAX 300
-
-/* Guard Time of 250µs after I2C slave NACK */
-#define GUARD_TIME_ERR_MIN 250
-#define GUARD_TIME_ERR_MAX 300
-
-/* Guard Time bit masks; SR is repeated start, RW is read then write, etc. */
-#define TPM_GUARD_TIME_SR_MASK 0x40000000
-#define TPM_GUARD_TIME_RR_MASK 0x00100000
-#define TPM_GUARD_TIME_RW_MASK 0x00080000
-#define TPM_GUARD_TIME_WR_MASK 0x00040000
-#define TPM_GUARD_TIME_WW_MASK 0x00020000
-#define TPM_GUARD_TIME_MIN_MASK 0x0001FE00
-#define TPM_GUARD_TIME_MIN_SHIFT 9
-
-/* Masks with bits that must be read zero */
-#define TPM_ACCESS_READ_ZERO 0x48
-#define TPM_INT_ENABLE_ZERO 0x7FFFFF60
-#define TPM_STS_READ_ZERO 0x23
-#define TPM_INTF_CAPABILITY_ZERO 0x0FFFF000
-#define TPM_I2C_INTERFACE_CAPABILITY_ZERO 0x80000000
+#define TPM_LOC_SEL                    0x04
+#define TPM_I2C_INTERFACE_CAPABILITY   0x30
+#define TPM_I2C_DEVICE_ADDRESS         0x38
+#define TPM_DATA_CSUM_ENABLE           0x40
+#define TPM_DATA_CSUM                  0x44
+#define TPM_I2C_DID_VID                0x48
+#define TPM_I2C_RID                    0x4C
 
 struct tpm_tis_i2c_phy {
 	struct tpm_tis_data priv;
 	struct i2c_client *i2c_client;
-	bool guard_time_read;
-	bool guard_time_write;
-	u16 guard_time_min;
-	u16 guard_time_max;
-	u8 *io_buf;
+	bool data_csum;
+	u8 *iobuf;
 };
 
-static inline struct tpm_tis_i2c_phy *
-to_tpm_tis_i2c_phy(struct tpm_tis_data *data)
-{
-	return container_of(data, struct tpm_tis_i2c_phy, priv);
-}
+static inline struct tpm_tis_i2c_phy *to_tpm_tis_i2c_phy(struct
+tpm_tis_data *data) {
+	return container_of(data, struct tpm_tis_i2c_phy, priv); }
 
-/*
- * tpm_tis_core uses the register addresses as defined in Table 19 "Allocation
- * of Register Space for FIFO TPM Access" of the TCG PC Client PTP
- * Specification. In order for this code to work together with tpm_tis_core,
- * those addresses need to mapped to the registers defined for I2C TPMs in
- * Table 51 "I2C-TPM Register Overview".
- *
- * For most addresses this can be done by simply stripping off the locality
- * information from the address. A few addresses need to be mapped explicitly,
- * since the corresponding I2C registers have been moved around. TPM_LOC_SEL is
- * only defined for I2C TPMs and is also mapped explicitly here to distinguish
- * it from TPM_ACCESS(0).
- *
- * Locality information is ignored, since this driver assumes exclusive access
- * to the TPM and always uses locality 0.
- */
-static u8 tpm_tis_i2c_address_to_register(u32 addr)
-{
-	addr &= TPM_TIS_REGISTER_MASK;
+static u8 address_to_register(u32 addr) {
+	addr &= 0xFFF;
 
 	switch (addr) {
+		// adapt register addresses that have changed compared to
+		// older TIS versions
 	case TPM_ACCESS(0):
-		return TPM_I2C_ACCESS;
+		return 0x04;
 	case TPM_LOC_SEL:
-		return TPM_I2C_LOC_SEL;
+		return 0x00;
 	case TPM_DID_VID(0):
-		return TPM_I2C_DID_VID;
+		return 0x48;
 	case TPM_RID(0):
-		return TPM_I2C_RID;
+		return 0x4C;
 	default:
 		return addr;
 	}
 }
 
-static int tpm_tis_i2c_retry_transfer_until_ack(struct tpm_tis_data *data,
-						struct i2c_msg *msg)
+static int tpm_tis_i2c_read_bytes(struct tpm_tis_data *data, u32 addr,
+				  u16 len, u8 *result)
 {
 	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
-	bool guard_time;
+	int ret = 0;
 	int i = 0;
-	int ret;
-
-	if (msg->flags & I2C_M_RD)
-		guard_time = phy->guard_time_read;
-	else
-		guard_time = phy->guard_time_write;
-
-	do {
-		ret = i2c_transfer(phy->i2c_client->adapter, msg, 1);
-		if (ret < 0)
-			usleep_range(GUARD_TIME_ERR_MIN, GUARD_TIME_ERR_MAX);
-		else if (guard_time)
-			usleep_range(phy->guard_time_min, phy->guard_time_max);
-		/* retry on TPM NACK */
-	} while (ret < 0 && i++ < TPM_RETRY);
-
-	return ret;
-}
+	u8 reg = address_to_register(addr);
+	struct i2c_msg msgs[] = {
+		{
+			.addr = phy->i2c_client->addr,
+			.len = sizeof(reg),
+			.buf = &reg,
+		},
+		{
+			.addr = phy->i2c_client->addr,
+			.len = len,
+			.buf = result,
+			.flags = I2C_M_RD,
+		},
+	};
+
+    do
+    {
+	ret = i2c_transfer(phy->i2c_client->adapter, msgs, ARRAY_SIZE(msgs));
+	usleep_range(250, 300); // wait default GUARD_TIME of 250µs
+
+	} while(ret < 0 && i++ < TPM_RETRY );
 
-/* Check that bits which must be read zero are not set */
-static int tpm_tis_i2c_sanity_check_read(u8 reg, u16 len, u8 *buf)
-{
-	u32 zero_mask;
-	u32 value;
-
-	switch (len) {
-	case sizeof(u8):
-		value = buf[0];
-		break;
-	case sizeof(u16):
-		value = le16_to_cpup((__le16 *)buf);
-		break;
-	case sizeof(u32):
-		value = le32_to_cpup((__le32 *)buf);
-		break;
-	default:
-		/* unknown length, skip check */
-		return 0;
-	}
+	if (ret < 0)
+		return ret;
 
-	switch (reg) {
-	case TPM_I2C_ACCESS:
-		zero_mask = TPM_ACCESS_READ_ZERO;
-		break;
-	case TPM_INT_ENABLE(0) & TPM_TIS_REGISTER_MASK:
-		zero_mask = TPM_INT_ENABLE_ZERO;
-		break;
-	case TPM_STS(0) & TPM_TIS_REGISTER_MASK:
-		zero_mask = TPM_STS_READ_ZERO;
-		break;
-	case TPM_INTF_CAPS(0) & TPM_TIS_REGISTER_MASK:
-		zero_mask = TPM_INTF_CAPABILITY_ZERO;
-		break;
-	case TPM_I2C_INTERFACE_CAPABILITY:
-		zero_mask = TPM_I2C_INTERFACE_CAPABILITY_ZERO;
-		break;
-	default:
-		/* unknown register, skip check */
-		return 0;
-	}
 
-	if (unlikely((value & zero_mask) != 0x00)) {
-		pr_debug("TPM I2C read of register 0x%02x failed sanity check: 0x%x\n", reg, value);
-		return -EIO;
-	}
 
 	return 0;
 }
 
-static int tpm_tis_i2c_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
-				  u8 *result, enum tpm_tis_io_mode io_mode)
+static int tpm_tis_i2c_write_bytes(struct tpm_tis_data *data, u32 addr,
+				   u16 len, const u8 *value)
 {
 	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
-	struct i2c_msg msg = { .addr = phy->i2c_client->addr };
-	u8 reg = tpm_tis_i2c_address_to_register(addr);
-	int i;
-	int ret;
-
-	for (i = 0; i < TPM_RETRY; i++) {
-		/* write register */
-		msg.len = sizeof(reg);
-		msg.buf = &reg;
-		msg.flags = 0;
-		ret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);
-		if (ret < 0)
-			return ret;
-
-		/* read data */
-		msg.buf = result;
-		msg.len = len;
-		msg.flags = I2C_M_RD;
-		ret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);
-		if (ret < 0)
-			return ret;
-
-		ret = tpm_tis_i2c_sanity_check_read(reg, len, result);
-		if (ret == 0)
-			return 0;
-
-		usleep_range(GUARD_TIME_ERR_MIN, GUARD_TIME_ERR_MAX);
+	int ret = 0;
+	int i = 0;
+
+	if (phy->iobuf) {
+		if (len > TPM_BUFSIZE - 1)
+			return -EIO;
+
+		phy->iobuf[0] = address_to_register(addr);
+		memcpy(phy->iobuf + 1, value, len);
+
+		{
+			struct i2c_msg msgs[] = {
+				{
+					.addr = phy->i2c_client->addr,
+					.len = len + 1,
+					.buf = phy->iobuf,
+				},
+			};
+
+            do{
+			ret = i2c_transfer(phy->i2c_client->adapter, msgs,
+					   ARRAY_SIZE(msgs));
+			usleep_range(250, 300); // wait default GUARD_TIME of 250µs
+
+			} while(ret < 0 && i++ < TPM_RETRY );
+		}
+	} else {
+		u8 reg = address_to_register(addr);
+
+		struct i2c_msg msgs[] = {
+			{
+				.addr = phy->i2c_client->addr,
+				.len = sizeof(reg),
+				.buf = &reg,
+			},
+			{
+				.addr = phy->i2c_client->addr,
+				.len = len,
+				.buf = (u8 *)value,
+				.flags = I2C_M_NOSTART,
+			},
+		};
+
+		do{
+		ret = i2c_transfer(phy->i2c_client->adapter, msgs, ARRAY_SIZE(msgs));
+	   usleep_range(250, 300); // wait default GUARD_TIME of 250µs
+
+		} while(ret < 0 && i++ < TPM_RETRY );
 	}
 
-	return ret;
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
-static int tpm_tis_i2c_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
-				   const u8 *value,
-				   enum tpm_tis_io_mode io_mode)
+static bool tpm_tis_i2c_check_data(struct tpm_tis_data *data,
+				   const u8 *buf, size_t len)
 {
 	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
-	struct i2c_msg msg = { .addr = phy->i2c_client->addr };
-	u8 reg = tpm_tis_i2c_address_to_register(addr);
-	int ret;
-
-	if (len > TPM_BUFSIZE - 1)
-		return -EIO;
+	u16 crc, crc_tpm;
+	int rc;
 
-	/* write register and data in one go */
-	phy->io_buf[0] = reg;
-	memcpy(phy->io_buf + sizeof(reg), value, len);
+	if (phy->data_csum) {
+		crc = crc_ccitt(0x0000, buf, len);
+		rc = tpm_tis_read16(data, TPM_DATA_CSUM, &crc_tpm);
+		if (rc < 0)
+			return false;
 
-	msg.len = sizeof(reg) + len;
-	msg.buf = phy->io_buf;
-	ret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);
-	if (ret < 0)
-		return ret;
+		crc_tpm = be16_to_cpu(crc_tpm);
+		return crc == crc_tpm;
+	}
 
-	return 0;
+	return true;
 }
 
-static int tpm_tis_i2c_verify_crc(struct tpm_tis_data *data, size_t len,
-				  const u8 *value)
-{
-	u16 crc_tpm, crc_host;
+static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);
+
+static int csum_state_store(struct tpm_tis_data *data, u8 new_state) {
+	struct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);
+	u8 cur_state=0;
 	int rc;
 
-	rc = tpm_tis_read16(data, TPM_DATA_CSUM, &crc_tpm);
+	rc = tpm_tis_i2c_write_bytes(&phy->priv, TPM_DATA_CSUM_ENABLE,
+				     1, &new_state);
 	if (rc < 0)
 		return rc;
 
-	/* reflect crc result, regardless of host endianness */
-	crc_host = swab16(crc_ccitt(0, value, len));
-	if (crc_tpm != crc_host)
-		return -EIO;
-
-	return 0;
-}
-
-/*
- * Guard Time:
- * After each I2C operation, the TPM might require the master to wait.
- * The time period is vendor-specific and must be read from the
- * TPM_I2C_INTERFACE_CAPABILITY register.
- *
- * Before the Guard Time is read (or after the TPM failed to send an I2C NACK),
- * a Guard Time of 250µs applies.
- *
- * Various flags in the same register indicate if a guard time is needed:
- *  - SR: <I2C read with repeated start> <guard time> <I2C read>
- *  - RR: <I2C read> <guard time> <I2C read>
- *  - RW: <I2C read> <guard time> <I2C write>
- *  - WR: <I2C write> <guard time> <I2C read>
- *  - WW: <I2C write> <guard time> <I2C write>
- *
- * See TCG PC Client PTP Specification v1.04, 8.1.10 GUARD_TIME
- */
-static int tpm_tis_i2c_init_guard_time(struct tpm_tis_i2c_phy *phy)
-{
-	u32 i2c_caps;
-	int ret;
-
-	phy->guard_time_read = true;
-	phy->guard_time_write = true;
-	phy->guard_time_min = GUARD_TIME_DEFAULT_MIN;
-	phy->guard_time_max = GUARD_TIME_DEFAULT_MAX;
-
-	ret = tpm_tis_i2c_read_bytes(&phy->priv, TPM_I2C_INTERFACE_CAPABILITY,
-				     sizeof(i2c_caps), (u8 *)&i2c_caps,
-				     TPM_TIS_PHYS_32);
-	if (ret)
-		return ret;
+	rc = tpm_tis_i2c_read_bytes(&phy->priv, TPM_DATA_CSUM_ENABLE,
+				    1, &cur_state);
+	if (rc < 0)
+		return rc;
 
-	phy->guard_time_read = (i2c_caps & TPM_GUARD_TIME_RR_MASK) ||
-			       (i2c_caps & TPM_GUARD_TIME_RW_MASK);
-	phy->guard_time_write = (i2c_caps & TPM_GUARD_TIME_WR_MASK) ||
-				(i2c_caps & TPM_GUARD_TIME_WW_MASK);
-	phy->guard_time_min = (i2c_caps & TPM_GUARD_TIME_MIN_MASK) >>
-			      TPM_GUARD_TIME_MIN_SHIFT;
-	/* guard_time_max = guard_time_min * 1.2 */
-	phy->guard_time_max = phy->guard_time_min + phy->guard_time_min / 5;
+	if (new_state == cur_state)
+		phy->data_csum = (bool)new_state;
 
-	return 0;
+	return rc;
 }
 
-static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);
-
 static const struct tpm_tis_phy_ops tpm_i2c_phy_ops = {
 	.read_bytes = tpm_tis_i2c_read_bytes,
 	.write_bytes = tpm_tis_i2c_write_bytes,
-	.verify_crc = tpm_tis_i2c_verify_crc,
+	.check_data = tpm_tis_i2c_check_data,
 };
 
 static int tpm_tis_i2c_probe(struct i2c_client *dev,
-			     const struct i2c_device_id *id)
-{
+			     const struct i2c_device_id *id) {
 	struct tpm_tis_i2c_phy *phy;
-	const u8 crc_enable = 1;
-	const u8 locality = 0;
-	int ret;
+	int rc;
+	const u8 loc_init = 0;
 
 	phy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_i2c_phy),
 			   GFP_KERNEL);
 	if (!phy)
 		return -ENOMEM;
 
-	phy->io_buf = devm_kzalloc(&dev->dev, TPM_BUFSIZE, GFP_KERNEL);
-	if (!phy->io_buf)
-		return -ENOMEM;
-
-	set_bit(TPM_TIS_DEFAULT_CANCELLATION, &phy->priv.flags);
 	phy->i2c_client = dev;
 
-	/* must precede all communication with the tpm */
-	ret = tpm_tis_i2c_init_guard_time(phy);
-	if (ret)
-		return ret;
+	if (!i2c_check_functionality(dev->adapter, I2C_FUNC_NOSTART)) {
+		phy->iobuf = devm_kmalloc(&dev->dev, TPM_BUFSIZE, GFP_KERNEL);
+		if (!phy->iobuf)
+			return -ENOMEM;
+	}
 
-	ret = tpm_tis_i2c_write_bytes(&phy->priv, TPM_LOC_SEL, sizeof(locality),
-				      &locality, TPM_TIS_PHYS_8);
-	if (ret)
-		return ret;
+	rc = tpm_tis_i2c_write_bytes(&phy->priv, TPM_LOC_SEL, 1, &loc_init);
+	if (rc < 0)
+		return rc;
 
-	ret = tpm_tis_i2c_write_bytes(&phy->priv, TPM_I2C_DATA_CSUM_ENABLE,
-				      sizeof(crc_enable), &crc_enable,
-				      TPM_TIS_PHYS_8);
-	if (ret)
-		return ret;
+
+	rc = csum_state_store(&phy->priv, 0x01);
+	if (rc < 0)
+		return rc;
 
 	return tpm_tis_core_init(&dev->dev, &phy->priv, -1, &tpm_i2c_phy_ops,
-				 NULL);
+					NULL);
 }
 
-static void tpm_tis_i2c_remove(struct i2c_client *client)
-{
+static int tpm_tis_i2c_remove(struct i2c_client *client) {
 	struct tpm_chip *chip = i2c_get_clientdata(client);
-
 	tpm_chip_unregister(chip);
 	tpm_tis_remove(chip);
+	return 0;
 }
 
 static const struct i2c_device_id tpm_tis_i2c_id[] = {
-	{ "tpm_tis_i2c", 0 },
+	{"tpm_tis_i2c", 0},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_id);
 
-#ifdef CONFIG_OF
 static const struct of_device_id of_tis_i2c_match[] = {
-	{ .compatible = "infineon,slb9673", },
+	{ .compatible = "st,st33htpm-i2c", "tcg,tpm-tis-i2c", },
 	{}
 };
 MODULE_DEVICE_TABLE(of, of_tis_i2c_match);
-#endif
+
+static const struct acpi_device_id acpi_tis_i2c_match[] = {
+	{"SMO0768", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, acpi_tis_i2c_match);
 
 static struct i2c_driver tpm_tis_i2c_driver = {
 	.driver = {
+		.owner = THIS_MODULE,
 		.name = "tpm_tis_i2c",
 		.pm = &tpm_tis_pm,
 		.of_match_table = of_match_ptr(of_tis_i2c_match),
+		.acpi_match_table = ACPI_PTR(acpi_tis_i2c_match),
 	},
 	.probe = tpm_tis_i2c_probe,
 	.remove = tpm_tis_i2c_remove,
 	.id_table = tpm_tis_i2c_id,
 };
+
 module_i2c_driver(tpm_tis_i2c_driver);
 
 MODULE_DESCRIPTION("TPM Driver for native I2C access");
diff --git a/drivers/char/tpm/tpm_tis_i2c_cr50.c b/drivers/char/tpm/tpm_tis_i2c_cr50.c
index 77cea5b31c6e..e2ab6a329732 100644
--- a/drivers/char/tpm/tpm_tis_i2c_cr50.c
+++ b/drivers/char/tpm/tpm_tis_i2c_cr50.c
@@ -31,7 +31,6 @@
 #define TPM_CR50_TIMEOUT_SHORT_MS	2		/* Short timeout during transactions */
 #define TPM_CR50_TIMEOUT_NOIRQ_MS	20		/* Timeout for TPM ready without IRQ */
 #define TPM_CR50_I2C_DID_VID		0x00281ae0L	/* Device and vendor ID reg value */
-#define TPM_TI50_I2C_DID_VID		0x504a6666L	/* Device and vendor ID reg value */
 #define TPM_CR50_I2C_MAX_RETRIES	3		/* Max retries due to I2C errors */
 #define TPM_CR50_I2C_RETRY_DELAY_LO	55		/* Min usecs between retries on I2C */
 #define TPM_CR50_I2C_RETRY_DELAY_HI	65		/* Max usecs between retries on I2C */
@@ -629,19 +628,6 @@ static bool tpm_cr50_i2c_req_canceled(struct tpm_chip *chip, u8 status)
 	return status == TPM_STS_COMMAND_READY;
 }
 
-static bool tpm_cr50_i2c_is_firmware_power_managed(struct device *dev)
-{
-	u8 val;
-	int ret;
-
-	/* This flag should default true when the device property is not present */
-	ret = device_property_read_u8(dev, "firmware-power-managed", &val);
-	if (ret)
-		return true;
-
-	return val;
-}
-
 static const struct tpm_class_ops cr50_i2c = {
 	.flags = TPM_OPS_AUTO_STARTUP,
 	.status = &tpm_cr50_i2c_tis_status,
@@ -700,8 +686,7 @@ static int tpm_cr50_i2c_probe(struct i2c_client *client)
 
 	/* cr50 is a TPM 2.0 chip */
 	chip->flags |= TPM_CHIP_FLAG_TPM2;
-	if (tpm_cr50_i2c_is_firmware_power_managed(dev))
-		chip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;
+	chip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;
 
 	/* Default timeouts */
 	chip->timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);
@@ -743,15 +728,15 @@ static int tpm_cr50_i2c_probe(struct i2c_client *client)
 	}
 
 	vendor = le32_to_cpup((__le32 *)buf);
-	if (vendor != TPM_CR50_I2C_DID_VID && vendor != TPM_TI50_I2C_DID_VID) {
+	if (vendor != TPM_CR50_I2C_DID_VID) {
 		dev_err(dev, "Vendor ID did not match! ID was %08x\n", vendor);
 		tpm_cr50_release_locality(chip, true);
 		return -ENODEV;
 	}
 
-	dev_info(dev, "%s TPM 2.0 (i2c 0x%02x irq %d id 0x%x)\n",
-		 vendor == TPM_TI50_I2C_DID_VID ? "ti50" : "cr50",
+	dev_info(dev, "cr50 TPM 2.0 (i2c 0x%02x irq %d id 0x%x)\n",
 		 client->addr, client->irq, vendor >> 16);
+
 	return tpm_chip_register(chip);
 }
 
@@ -763,18 +748,20 @@ static int tpm_cr50_i2c_probe(struct i2c_client *client)
  * - 0:		Success.
  * - -errno:	A POSIX error code.
  */
-static void tpm_cr50_i2c_remove(struct i2c_client *client)
+static int tpm_cr50_i2c_remove(struct i2c_client *client)
 {
 	struct tpm_chip *chip = i2c_get_clientdata(client);
 	struct device *dev = &client->dev;
 
 	if (!chip) {
 		dev_crit(dev, "Could not get client data at remove, memory corruption ahead\n");
-		return;
+		return 0;
 	}
 
 	tpm_chip_unregister(chip);
 	tpm_cr50_release_locality(chip, true);
+
+	return 0;
 }
 
 static SIMPLE_DEV_PM_OPS(cr50_i2c_pm, tpm_pm_suspend, tpm_pm_resume);
diff --git a/drivers/char/tpm/tpm_tis_spi.h b/drivers/char/tpm/tpm_tis_spi.h
index d0f66f6f1931..bba73979c368 100644
--- a/drivers/char/tpm/tpm_tis_spi.h
+++ b/drivers/char/tpm/tpm_tis_spi.h
@@ -31,6 +31,10 @@ extern int tpm_tis_spi_init(struct spi_device *spi, struct tpm_tis_spi_phy *phy,
 extern int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 				u8 *in, const u8 *out);
 
+extern int tpm_tis_spi_read16(struct tpm_tis_data *data, u32 addr, u16 *result);
+extern int tpm_tis_spi_read32(struct tpm_tis_data *data, u32 addr, u32 *result);
+extern int tpm_tis_spi_write32(struct tpm_tis_data *data, u32 addr, u32 value);
+
 #ifdef CONFIG_TCG_TIS_SPI_CR50
 extern int cr50_spi_probe(struct spi_device *spi);
 #else
diff --git a/drivers/char/tpm/tpm_tis_spi_cr50.c b/drivers/char/tpm/tpm_tis_spi_cr50.c
index f4937280e940..ea759af25634 100644
--- a/drivers/char/tpm/tpm_tis_spi_cr50.c
+++ b/drivers/char/tpm/tpm_tis_spi_cr50.c
@@ -36,9 +36,6 @@
 #define TPM_CR50_FW_VER(l)			(0x0f90 | ((l) << 12))
 #define TPM_CR50_MAX_FW_VER_LEN			64
 
-/* Default quality for hwrng. */
-#define TPM_CR50_DEFAULT_RNG_QUALITY		700
-
 struct cr50_spi_phy {
 	struct tpm_tis_spi_phy spi_phy;
 
@@ -185,19 +182,6 @@ static int cr50_spi_flow_control(struct tpm_tis_spi_phy *phy,
 	return 0;
 }
 
-static bool tpm_cr50_spi_is_firmware_power_managed(struct device *dev)
-{
-	u8 val;
-	int ret;
-
-	/* This flag should default true when the device property is not present */
-	ret = device_property_read_u8(dev, "firmware-power-managed", &val);
-	if (ret)
-		return true;
-
-	return val;
-}
-
 static int tpm_tis_spi_cr50_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 				     u8 *in, const u8 *out)
 {
@@ -222,13 +206,13 @@ static int tpm_tis_spi_cr50_transfer(struct tpm_tis_data *data, u32 addr, u16 le
 }
 
 static int tpm_tis_spi_cr50_read_bytes(struct tpm_tis_data *data, u32 addr,
-				       u16 len, u8 *result, enum tpm_tis_io_mode io_mode)
+				       u16 len, u8 *result)
 {
 	return tpm_tis_spi_cr50_transfer(data, addr, len, result, NULL);
 }
 
 static int tpm_tis_spi_cr50_write_bytes(struct tpm_tis_data *data, u32 addr,
-					u16 len, const u8 *value, enum tpm_tis_io_mode io_mode)
+					u16 len, const u8 *value)
 {
 	return tpm_tis_spi_cr50_transfer(data, addr, len, NULL, value);
 }
@@ -236,6 +220,9 @@ static int tpm_tis_spi_cr50_write_bytes(struct tpm_tis_data *data, u32 addr,
 static const struct tpm_tis_phy_ops tpm_spi_cr50_phy_ops = {
 	.read_bytes = tpm_tis_spi_cr50_read_bytes,
 	.write_bytes = tpm_tis_spi_cr50_write_bytes,
+	.read16 = tpm_tis_spi_read16,
+	.read32 = tpm_tis_spi_read32,
+	.write32 = tpm_tis_spi_write32,
 };
 
 static void cr50_print_fw_version(struct tpm_tis_data *data)
@@ -277,7 +264,6 @@ int cr50_spi_probe(struct spi_device *spi)
 	phy = &cr50_phy->spi_phy;
 	phy->flow_control = cr50_spi_flow_control;
 	phy->wake_after = jiffies;
-	phy->priv.rng_quality = TPM_CR50_DEFAULT_RNG_QUALITY;
 	init_completion(&phy->ready);
 
 	cr50_phy->access_delay = CR50_NOIRQ_ACCESS_DELAY;
@@ -319,8 +305,7 @@ int cr50_spi_probe(struct spi_device *spi)
 	cr50_print_fw_version(&phy->priv);
 
 	chip = dev_get_drvdata(&spi->dev);
-	if (tpm_cr50_spi_is_firmware_power_managed(&spi->dev))
-		chip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;
+	chip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;
 
 	return 0;
 }
diff --git a/drivers/char/tpm/tpm_tis_spi_main.c b/drivers/char/tpm/tpm_tis_spi_main.c
index a0963a3e92bd..aaa59a00eeae 100644
--- a/drivers/char/tpm/tpm_tis_spi_main.c
+++ b/drivers/char/tpm/tpm_tis_spi_main.c
@@ -141,17 +141,55 @@ int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 }
 
 static int tpm_tis_spi_read_bytes(struct tpm_tis_data *data, u32 addr,
-				  u16 len, u8 *result, enum tpm_tis_io_mode io_mode)
+				  u16 len, u8 *result)
 {
 	return tpm_tis_spi_transfer(data, addr, len, result, NULL);
 }
 
 static int tpm_tis_spi_write_bytes(struct tpm_tis_data *data, u32 addr,
-				   u16 len, const u8 *value, enum tpm_tis_io_mode io_mode)
+				   u16 len, const u8 *value)
 {
 	return tpm_tis_spi_transfer(data, addr, len, NULL, value);
 }
 
+int tpm_tis_spi_read16(struct tpm_tis_data *data, u32 addr, u16 *result)
+{
+	__le16 result_le;
+	int rc;
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u16),
+				       (u8 *)&result_le);
+	if (!rc)
+		*result = le16_to_cpu(result_le);
+
+	return rc;
+}
+
+int tpm_tis_spi_read32(struct tpm_tis_data *data, u32 addr, u32 *result)
+{
+	__le32 result_le;
+	int rc;
+
+	rc = data->phy_ops->read_bytes(data, addr, sizeof(u32),
+				       (u8 *)&result_le);
+	if (!rc)
+		*result = le32_to_cpu(result_le);
+
+	return rc;
+}
+
+int tpm_tis_spi_write32(struct tpm_tis_data *data, u32 addr, u32 value)
+{
+	__le32 value_le;
+	int rc;
+
+	value_le = cpu_to_le32(value);
+	rc = data->phy_ops->write_bytes(data, addr, sizeof(u32),
+					(u8 *)&value_le);
+
+	return rc;
+}
+
 int tpm_tis_spi_init(struct spi_device *spi, struct tpm_tis_spi_phy *phy,
 		     int irq, const struct tpm_tis_phy_ops *phy_ops)
 {
@@ -167,6 +205,9 @@ int tpm_tis_spi_init(struct spi_device *spi, struct tpm_tis_spi_phy *phy,
 static const struct tpm_tis_phy_ops tpm_spi_phy_ops = {
 	.read_bytes = tpm_tis_spi_read_bytes,
 	.write_bytes = tpm_tis_spi_write_bytes,
+	.read16 = tpm_tis_spi_read16,
+	.read32 = tpm_tis_spi_read32,
+	.write32 = tpm_tis_spi_write32,
 };
 
 static int tpm_tis_spi_probe(struct spi_device *dev)
@@ -213,12 +254,13 @@ static int tpm_tis_spi_driver_probe(struct spi_device *spi)
 
 static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_spi_resume);
 
-static void tpm_tis_spi_remove(struct spi_device *dev)
+static int tpm_tis_spi_remove(struct spi_device *dev)
 {
 	struct tpm_chip *chip = spi_get_drvdata(dev);
 
 	tpm_chip_unregister(chip);
 	tpm_tis_remove(chip);
+	return 0;
 }
 
 static const struct spi_device_id tpm_tis_spi_id[] = {
diff --git a/drivers/char/tpm/tpm_tis_synquacer.c b/drivers/char/tpm/tpm_tis_synquacer.c
index 679196c61401..e47bdd272704 100644
--- a/drivers/char/tpm/tpm_tis_synquacer.c
+++ b/drivers/char/tpm/tpm_tis_synquacer.c
@@ -35,53 +35,72 @@ static inline struct tpm_tis_synquacer_phy *to_tpm_tis_tcg_phy(struct tpm_tis_da
 }
 
 static int tpm_tis_synquacer_read_bytes(struct tpm_tis_data *data, u32 addr,
-					u16 len, u8 *result,
-					enum tpm_tis_io_mode io_mode)
+					u16 len, u8 *result)
 {
 	struct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);
-	switch (io_mode) {
-	case TPM_TIS_PHYS_8:
-		while (len--)
-			*result++ = ioread8(phy->iobase + addr);
-		break;
-	case TPM_TIS_PHYS_16:
-		result[1] = ioread8(phy->iobase + addr + 1);
-		result[0] = ioread8(phy->iobase + addr);
-		break;
-	case TPM_TIS_PHYS_32:
-		result[3] = ioread8(phy->iobase + addr + 3);
-		result[2] = ioread8(phy->iobase + addr + 2);
-		result[1] = ioread8(phy->iobase + addr + 1);
-		result[0] = ioread8(phy->iobase + addr);
-		break;
-	}
+
+	while (len--)
+		*result++ = ioread8(phy->iobase + addr);
 
 	return 0;
 }
 
 static int tpm_tis_synquacer_write_bytes(struct tpm_tis_data *data, u32 addr,
-					 u16 len, const u8 *value,
-					 enum tpm_tis_io_mode io_mode)
+					 u16 len, const u8 *value)
 {
 	struct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);
-	switch (io_mode) {
-	case TPM_TIS_PHYS_8:
-		while (len--)
-			iowrite8(*value++, phy->iobase + addr);
-		break;
-	case TPM_TIS_PHYS_16:
-		return -EINVAL;
-	case TPM_TIS_PHYS_32:
-		/*
-		 * Due to the limitation of SPI controller on SynQuacer,
-		 * 16/32 bits access must be done in byte-wise and descending order.
-		 */
-		iowrite8(value[3], phy->iobase + addr + 3);
-		iowrite8(value[2], phy->iobase + addr + 2);
-		iowrite8(value[1], phy->iobase + addr + 1);
-		iowrite8(value[0], phy->iobase + addr);
-		break;
-	}
+
+	while (len--)
+		iowrite8(*value++, phy->iobase + addr);
+
+	return 0;
+}
+
+static int tpm_tis_synquacer_read16_bw(struct tpm_tis_data *data,
+				       u32 addr, u16 *result)
+{
+	struct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	/*
+	 * Due to the limitation of SPI controller on SynQuacer,
+	 * 16/32 bits access must be done in byte-wise and descending order.
+	 */
+	*result = (ioread8(phy->iobase + addr + 1) << 8) |
+		  (ioread8(phy->iobase + addr));
+
+	return 0;
+}
+
+static int tpm_tis_synquacer_read32_bw(struct tpm_tis_data *data,
+				       u32 addr, u32 *result)
+{
+	struct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	/*
+	 * Due to the limitation of SPI controller on SynQuacer,
+	 * 16/32 bits access must be done in byte-wise and descending order.
+	 */
+	*result = (ioread8(phy->iobase + addr + 3) << 24) |
+		  (ioread8(phy->iobase + addr + 2) << 16) |
+		  (ioread8(phy->iobase + addr + 1) << 8) |
+		  (ioread8(phy->iobase + addr));
+
+	return 0;
+}
+
+static int tpm_tis_synquacer_write32_bw(struct tpm_tis_data *data,
+					u32 addr, u32 value)
+{
+	struct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);
+
+	/*
+	 * Due to the limitation of SPI controller on SynQuacer,
+	 * 16/32 bits access must be done in byte-wise and descending order.
+	 */
+	iowrite8(value >> 24, phy->iobase + addr + 3);
+	iowrite8(value >> 16, phy->iobase + addr + 2);
+	iowrite8(value >> 8, phy->iobase + addr + 1);
+	iowrite8(value, phy->iobase + addr);
 
 	return 0;
 }
@@ -89,6 +108,9 @@ static int tpm_tis_synquacer_write_bytes(struct tpm_tis_data *data, u32 addr,
 static const struct tpm_tis_phy_ops tpm_tcg_bw = {
 	.read_bytes	= tpm_tis_synquacer_read_bytes,
 	.write_bytes	= tpm_tis_synquacer_write_bytes,
+	.read16		= tpm_tis_synquacer_read16_bw,
+	.read32		= tpm_tis_synquacer_read32_bw,
+	.write32	= tpm_tis_synquacer_write32_bw,
 };
 
 static int tpm_tis_synquacer_init(struct device *dev,
diff --git a/drivers/char/tpm/tpm_vtpm_proxy.c b/drivers/char/tpm/tpm_vtpm_proxy.c
index 5c865987ba5c..91c772e38bb5 100644
--- a/drivers/char/tpm/tpm_vtpm_proxy.c
+++ b/drivers/char/tpm/tpm_vtpm_proxy.c
@@ -91,7 +91,7 @@ static ssize_t vtpm_proxy_fops_read(struct file *filp, char __user *buf,
 
 	len = proxy_dev->req_len;
 
-	if (count < len || len > sizeof(proxy_dev->buffer)) {
+	if (count < len) {
 		mutex_unlock(&proxy_dev->buf_lock);
 		pr_debug("Invalid size in recv: count=%zd, req_len=%zd\n",
 			 count, len);
diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.c
index 379291826261..da5b30771418 100644
--- a/drivers/char/tpm/xen-tpmfront.c
+++ b/drivers/char/tpm/xen-tpmfront.c
@@ -126,16 +126,16 @@ static void vtpm_cancel(struct tpm_chip *chip)
 	notify_remote_via_evtchn(priv->evtchn);
 }
 
-static size_t shr_data_offset(struct vtpm_shared_page *shr)
+static unsigned int shr_data_offset(struct vtpm_shared_page *shr)
 {
-	return struct_size(shr, extra_pages, shr->nr_extra_pages);
+	return sizeof(*shr) + sizeof(u32) * shr->nr_extra_pages;
 }
 
 static int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	struct vtpm_shared_page *shr = priv->shr;
-	size_t offset = shr_data_offset(shr);
+	unsigned int offset = shr_data_offset(shr);
 
 	u32 ordinal;
 	unsigned long duration;
@@ -177,7 +177,7 @@ static int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	struct tpm_private *priv = dev_get_drvdata(&chip->dev);
 	struct vtpm_shared_page *shr = priv->shr;
-	size_t offset = shr_data_offset(shr);
+	unsigned int offset = shr_data_offset(shr);
 	size_t length = shr->length;
 
 	if (shr->state == VTPM_STATE_IDLE)
@@ -253,12 +253,20 @@ static int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)
 	struct xenbus_transaction xbt;
 	const char *message = NULL;
 	int rv;
+	grant_ref_t gref;
 
-	rv = xenbus_setup_ring(dev, GFP_KERNEL, (void **)&priv->shr, 1,
-			       &priv->ring_ref);
+	priv->shr = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);
+	if (!priv->shr) {
+		xenbus_dev_fatal(dev, -ENOMEM, "allocating shared ring");
+		return -ENOMEM;
+	}
+
+	rv = xenbus_grant_ring(dev, priv->shr, 1, &gref);
 	if (rv < 0)
 		return rv;
 
+	priv->ring_ref = gref;
+
 	rv = xenbus_alloc_evtchn(dev, &priv->evtchn);
 	if (rv)
 		return rv;
@@ -323,7 +331,11 @@ static void ring_free(struct tpm_private *priv)
 	if (!priv)
 		return;
 
-	xenbus_teardown_ring((void **)&priv->shr, 1, &priv->ring_ref);
+	if (priv->ring_ref)
+		gnttab_end_foreign_access(priv->ring_ref, 0,
+				(unsigned long)priv->shr);
+	else
+		free_page((unsigned long)priv->shr);
 
 	if (priv->irq)
 		unbind_from_irqhandler(priv->irq, priv);
diff --git a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
index cbb68caa36f2..24c3eb7bfe6e 100644
--- a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
+++ b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
@@ -42,7 +42,7 @@ struct ili9881c_desc {
 	const struct ili9881c_instr *init;
 	const size_t init_length;
 	const struct drm_display_mode *mode;
-	const unsigned long mode_flags;
+	unsigned int mode_flags;
 };
 
 struct ili9881c {
@@ -663,6 +663,407 @@ static const struct ili9881c_instr w552946ab_init[] = {
 	ILI9881C_SWITCH_PAGE_INSTR(0),
 };
 
+static const struct ili9881c_instr am_8001280gtzqw_init[] = {
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x73),
+	ILI9881C_COMMAND_INSTR(0x04, 0xD3),
+	ILI9881C_COMMAND_INSTR(0x05, 0x00),
+	ILI9881C_COMMAND_INSTR(0x06, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x07, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x08, 0x00),
+	ILI9881C_COMMAND_INSTR(0x09, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x01),
+	ILI9881C_COMMAND_INSTR(0x10, 0x01),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x40),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x06),
+	ILI9881C_COMMAND_INSTR(0x21, 0x01),
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x33),
+	ILI9881C_COMMAND_INSTR(0x29, 0x03),
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x03),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x03),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x00),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	ILI9881C_COMMAND_INSTR(0x50, 0x01),
+	ILI9881C_COMMAND_INSTR(0x51, 0x23),
+	ILI9881C_COMMAND_INSTR(0x52, 0x45),
+	ILI9881C_COMMAND_INSTR(0x53, 0x67),
+	ILI9881C_COMMAND_INSTR(0x54, 0x89),
+	ILI9881C_COMMAND_INSTR(0x55, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x56, 0x01),
+	ILI9881C_COMMAND_INSTR(0x57, 0x23),
+	ILI9881C_COMMAND_INSTR(0x58, 0x45),
+	ILI9881C_COMMAND_INSTR(0x59, 0x67),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x89),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xCD),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xEF),
+	ILI9881C_COMMAND_INSTR(0x5E, 0x11),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x60, 0x00),
+	ILI9881C_COMMAND_INSTR(0x61, 0x01),
+	ILI9881C_COMMAND_INSTR(0x62, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x63, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x64, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x65, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x66, 0x06),
+	ILI9881C_COMMAND_INSTR(0x67, 0x07),
+	ILI9881C_COMMAND_INSTR(0x68, 0x02),
+	ILI9881C_COMMAND_INSTR(0x69, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6A, 0x08),
+	ILI9881C_COMMAND_INSTR(0x6B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6D, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x70, 0x02),
+	ILI9881C_COMMAND_INSTR(0x71, 0x02),
+	ILI9881C_COMMAND_INSTR(0x72, 0x02),
+	ILI9881C_COMMAND_INSTR(0x73, 0x02),
+	ILI9881C_COMMAND_INSTR(0x74, 0x02),
+	ILI9881C_COMMAND_INSTR(0x75, 0x02),
+	ILI9881C_COMMAND_INSTR(0x76, 0x00),
+	ILI9881C_COMMAND_INSTR(0x77, 0x01),
+	ILI9881C_COMMAND_INSTR(0x78, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x79, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x7B, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x7C, 0x06),
+	ILI9881C_COMMAND_INSTR(0x7D, 0x07),
+	ILI9881C_COMMAND_INSTR(0x7E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x80, 0x08),
+	ILI9881C_COMMAND_INSTR(0x81, 0x02),
+	ILI9881C_COMMAND_INSTR(0x82, 0x02),
+	ILI9881C_COMMAND_INSTR(0x83, 0x02),
+	ILI9881C_COMMAND_INSTR(0x84, 0x02),
+	ILI9881C_COMMAND_INSTR(0x85, 0x02),
+	ILI9881C_COMMAND_INSTR(0x86, 0x02),
+	ILI9881C_COMMAND_INSTR(0x87, 0x02),
+	ILI9881C_COMMAND_INSTR(0x88, 0x02),
+	ILI9881C_COMMAND_INSTR(0x89, 0x02),
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02),
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x30),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33),
+	ILI9881C_COMMAND_INSTR(0x8D, 0x15),
+	ILI9881C_COMMAND_INSTR(0x3A, 0xA4),
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	ILI9881C_COMMAND_INSTR(0x22, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x31, 0x0B),
+	ILI9881C_COMMAND_INSTR(0x50, 0xA5),
+	ILI9881C_COMMAND_INSTR(0x51, 0xA0),
+	ILI9881C_COMMAND_INSTR(0x53, 0x70),
+	ILI9881C_COMMAND_INSTR(0x55, 0x7A),
+	ILI9881C_COMMAND_INSTR(0x60, 0x14),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x00),
+	ILI9881C_COMMAND_INSTR(0xA1, 0x53),
+	ILI9881C_COMMAND_INSTR(0xA2, 0x50),
+	ILI9881C_COMMAND_INSTR(0xA3, 0x20),
+	ILI9881C_COMMAND_INSTR(0xA4, 0x27),
+	ILI9881C_COMMAND_INSTR(0xA5, 0x33),
+	ILI9881C_COMMAND_INSTR(0xA6, 0x25),
+	ILI9881C_COMMAND_INSTR(0xA7, 0x25),
+	ILI9881C_COMMAND_INSTR(0xA8, 0xD4),
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xAA, 0x2B),
+	ILI9881C_COMMAND_INSTR(0xAB, 0xB5),
+	ILI9881C_COMMAND_INSTR(0xAC, 0x19),
+	ILI9881C_COMMAND_INSTR(0xAD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xAE, 0x53),
+	ILI9881C_COMMAND_INSTR(0xAF, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xB0, 0x25),
+	ILI9881C_COMMAND_INSTR(0xB1, 0x62),
+	ILI9881C_COMMAND_INSTR(0xB2, 0x6A),
+	ILI9881C_COMMAND_INSTR(0xB3, 0x31),
+	ILI9881C_COMMAND_INSTR(0xC0, 0x00),
+	ILI9881C_COMMAND_INSTR(0xC1, 0x53),
+	ILI9881C_COMMAND_INSTR(0xC2, 0x50),
+	ILI9881C_COMMAND_INSTR(0xC3, 0x20),
+	ILI9881C_COMMAND_INSTR(0xC4, 0x27),
+	ILI9881C_COMMAND_INSTR(0xC5, 0x33),
+	ILI9881C_COMMAND_INSTR(0xC6, 0x25),
+	ILI9881C_COMMAND_INSTR(0xC7, 0x25),
+	ILI9881C_COMMAND_INSTR(0xC8, 0xD4),
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xCA, 0x2B),
+	ILI9881C_COMMAND_INSTR(0xCB, 0xB5),
+	ILI9881C_COMMAND_INSTR(0xCC, 0x19),
+	ILI9881C_COMMAND_INSTR(0xCD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xCE, 0x53),
+	ILI9881C_COMMAND_INSTR(0xCF, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xD0, 0x25),
+	ILI9881C_COMMAND_INSTR(0xD1, 0x62),
+	ILI9881C_COMMAND_INSTR(0xD2, 0x6A),
+	ILI9881C_COMMAND_INSTR(0xD3, 0x31),
+	ILI9881C_SWITCH_PAGE_INSTR(0),
+	ILI9881C_COMMAND_INSTR(0x51, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x53, 0x2C),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+};
+
+
+static const struct ili9881c_instr hsd_p0711t_init[] = {
+	// CMD_Page 3
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	//=========GIP_1===========//
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x54), //STVA Width 5H
+	ILI9881C_COMMAND_INSTR(0x04, 0x14), //STVB Width 5H
+	ILI9881C_COMMAND_INSTR(0x05, 0xD4), //STVC Width 5H
+	ILI9881C_COMMAND_INSTR(0x06, 0x08), //STVA Rise start
+	ILI9881C_COMMAND_INSTR(0x07, 0x01), //STVB Rise start
+	ILI9881C_COMMAND_INSTR(0x08, 0x0E), //STVC Rise start
+	ILI9881C_COMMAND_INSTR(0x09, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x10, 0x00),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x44),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x03), //CLKA Rise STA
+	ILI9881C_COMMAND_INSTR(0x21, 0x04), //CLKA FALL END
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x77), //CLK_x_NumB[2:0]  Phase_CLK[2:0]
+	ILI9881C_COMMAND_INSTR(0x29, 0x04), //Overlap_CLK[3:0] 5H
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x04), //GPW1/2 non Overlap time 2.62us
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x00),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x3C), //FOR GPW1/2 Cycle 2 s
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	//=========GIP_2===========//
+	ILI9881C_COMMAND_INSTR(0x50, 0x01),
+	ILI9881C_COMMAND_INSTR(0x51, 0x23),
+	ILI9881C_COMMAND_INSTR(0x52, 0x45),
+	ILI9881C_COMMAND_INSTR(0x53, 0x67),
+	ILI9881C_COMMAND_INSTR(0x54, 0x89),
+	ILI9881C_COMMAND_INSTR(0x55, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x56, 0x01),
+	ILI9881C_COMMAND_INSTR(0x57, 0x23),
+	ILI9881C_COMMAND_INSTR(0x58, 0x45),
+	ILI9881C_COMMAND_INSTR(0x59, 0x67),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x89),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xCD),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xEF),
+	//=========GIP_3===========//
+	ILI9881C_COMMAND_INSTR(0x5E, 0x11),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x01), //FW_GOUT_L1   FW
+	ILI9881C_COMMAND_INSTR(0x60, 0x00), //FW_GOUT_L2   BW
+	ILI9881C_COMMAND_INSTR(0x61, 0x08), //FW_GOUT_L3   STV2_R
+	ILI9881C_COMMAND_INSTR(0x62, 0x0A), //FW_GOUT_L4   STV3_R
+	ILI9881C_COMMAND_INSTR(0x63, 0x15), //FW_GOUT_L5   GPW1_R
+	ILI9881C_COMMAND_INSTR(0x64, 0x14), //FW_GOUT_L6   GPW2_R
+	ILI9881C_COMMAND_INSTR(0x65, 0x0C), //FW_GOUT_L7   CLK1_R
+	ILI9881C_COMMAND_INSTR(0x66, 0x0D), //FW_GOUT_L8   CLK2_R
+	ILI9881C_COMMAND_INSTR(0x67, 0x0E), //FW_GOUT_L9   CLK3_R
+	ILI9881C_COMMAND_INSTR(0x68, 0x0F), //FW_GOUT_L10  CLK4_R
+	ILI9881C_COMMAND_INSTR(0x69, 0x10), //FW_GOUT_L11  CLK5_R
+	ILI9881C_COMMAND_INSTR(0x6A, 0x11), //FW_GOUT_L12  CLK6_R
+	ILI9881C_COMMAND_INSTR(0x6B, 0x12), //FW_GOUT_L13  CLK7_R
+	ILI9881C_COMMAND_INSTR(0x6C, 0x13), //FW_GOUT_L14  CLK8_R
+	ILI9881C_COMMAND_INSTR(0x6D, 0x06), //FW_GOUT_L15  STV1_R
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02), //FW_GOUT_L16
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02), //FW_GOUT_L17  VGL
+	ILI9881C_COMMAND_INSTR(0x70, 0x02), //FW_GOUT_L18  VGL
+	ILI9881C_COMMAND_INSTR(0x71, 0x02), //FW_GOUT_L19  VGL
+	ILI9881C_COMMAND_INSTR(0x72, 0x02), //FW_GOUT_L20
+	ILI9881C_COMMAND_INSTR(0x73, 0x02), //FW_GOUT_L21
+	ILI9881C_COMMAND_INSTR(0x74, 0x02), //FW_GOUT_L22
+	ILI9881C_COMMAND_INSTR(0x75, 0x01), //BW_GOUT_L1   FW
+	ILI9881C_COMMAND_INSTR(0x76, 0x00), //BW_GOUT_L2   BW
+	ILI9881C_COMMAND_INSTR(0x77, 0x06), //BW_GOUT_L3   STV2_R
+	ILI9881C_COMMAND_INSTR(0x78, 0x0A), //BW_GOUT_L4   STV3_R
+	ILI9881C_COMMAND_INSTR(0x79, 0x15), //BW_GOUT_L5   GPW1_R
+	ILI9881C_COMMAND_INSTR(0x7A, 0x14), //BW_GOUT_L6   GPW2_R
+	ILI9881C_COMMAND_INSTR(0x7B, 0x0C), //BW_GOUT_L7   CLK1_R
+	ILI9881C_COMMAND_INSTR(0x7C, 0x0D), //BW_GOUT_L8   CLK2_R
+	ILI9881C_COMMAND_INSTR(0x7D, 0x0E), //BW_GOUT_L9   CLK3_R
+	ILI9881C_COMMAND_INSTR(0x7E, 0x0F), //BW_GOUT_L10  CLK4_R
+	ILI9881C_COMMAND_INSTR(0x7F, 0x10), //BW_GOUT_L11  CLK5_R
+	ILI9881C_COMMAND_INSTR(0x80, 0x11), //BW_GOUT_L12  CLK6_R
+	ILI9881C_COMMAND_INSTR(0x81, 0x12), //BW_GOUT_L13  CLK7_R
+	ILI9881C_COMMAND_INSTR(0x82, 0x13), //BW_GOUT_L14  CLK8_R
+	ILI9881C_COMMAND_INSTR(0x83, 0x08), //BW_GOUT_L15  STV1_R
+	ILI9881C_COMMAND_INSTR(0x84, 0x02), //BW_GOUT_L16
+	ILI9881C_COMMAND_INSTR(0x85, 0x02), //BW_GOUT_L17  VGL
+	ILI9881C_COMMAND_INSTR(0x86, 0x02), //BW_GOUT_L18  VGL
+	ILI9881C_COMMAND_INSTR(0x87, 0x02), //BW_GOUT_L19  VGL
+	ILI9881C_COMMAND_INSTR(0x88, 0x02), //BW_GOUT_L20
+	ILI9881C_COMMAND_INSTR(0x89, 0x02), //BW_GOUT_L21
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02), //BW_GOUT_L22
+	// CMD_Page 4
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15), //SEt VCORE voltAgE =1.5V
+	ILI9881C_COMMAND_INSTR(0x6E, 0x3B), //di_pwr_reg=0 For power mode 2A //VGH Clamp 18.06V
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33), //Reg vCl + pumping ratio VGH=3x VGL=-2x
+	ILI9881C_COMMAND_INSTR(0x3A, 0x24), //POWER SAVING
+	ILI9881C_COMMAND_INSTR(0x8D, 0x14), //VGL -10.05V
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA), //ESD
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_COMMAND_INSTR(0xB5, 0x27), //GMA BIAS
+	ILI9881C_COMMAND_INSTR(0x31, 0x75), //SRC BIAS
+	ILI9881C_COMMAND_INSTR(0x30, 0x03), //SRC OUTPUT BIAS
+	ILI9881C_COMMAND_INSTR(0x3B, 0x98), //PUMP SHIFT CLK
+	ILI9881C_COMMAND_INSTR(0x35, 0x1F), //HZ_opt 0426
+	ILI9881C_COMMAND_INSTR(0x33, 0x14), //Blanking Frame set to GND
+	ILI9881C_COMMAND_INSTR(0x7A, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x38, 0x02),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x10), //VLC measure setup
+	// CMD_Page 1
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	ILI9881C_COMMAND_INSTR(0x22, 0x0E),	//BGR,Normail Black, SS
+	ILI9881C_COMMAND_INSTR(0x2E, 0x88),	//RS[1:0]=01;768x(480+4xNL);NL=136
+	ILI9881C_COMMAND_INSTR(0x31, 0x02),	//00:Column  01:1dot 02:2dot inversion
+	ILI9881C_COMMAND_INSTR(0x52, 0x00),	//VCOM1
+	ILI9881C_COMMAND_INSTR(0x53, 0x1A),	//VCOM1
+	ILI9881C_COMMAND_INSTR(0x54, 0x00),	//VCOM2
+	ILI9881C_COMMAND_INSTR(0x55, 0x1A), //VCOM2
+	ILI9881C_COMMAND_INSTR(0x50, 0x42),	//VREG1OUT=3.504V(0x42)  4V(0x6B)
+	ILI9881C_COMMAND_INSTR(0x51, 0x42), //VREG2OUT=-3.504V0x42)  -4V(0x6B)
+	ILI9881C_COMMAND_INSTR(0x60, 0x1F), //SDT=2.5
+	ILI9881C_COMMAND_INSTR(0x63, 0x00),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x08), //VP255	  0 Gamma P
+	ILI9881C_COMMAND_INSTR(0xA1, 0x20), //VP251   4
+	ILI9881C_COMMAND_INSTR(0xA2, 0x26), //VP247   8
+	ILI9881C_COMMAND_INSTR(0xA3, 0x10), //VP243   12
+	ILI9881C_COMMAND_INSTR(0xA4, 0x10), //VP239   16
+	ILI9881C_COMMAND_INSTR(0xA5, 0x16), //VP231   24      22
+	ILI9881C_COMMAND_INSTR(0xA6, 0x10), //VP219   36      18
+	ILI9881C_COMMAND_INSTR(0xA7, 0x16), //VP203   52      20
+	ILI9881C_COMMAND_INSTR(0xA8, 0x60), //VP175   80
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1C), //VP144   111
+	ILI9881C_COMMAND_INSTR(0xAA, 0x26), //VP111   144
+	ILI9881C_COMMAND_INSTR(0xAB, 0x61), //VP80    175
+	ILI9881C_COMMAND_INSTR(0xAC, 0x28), //VP52    203     1A
+	ILI9881C_COMMAND_INSTR(0xAD, 0x24), //VP36    219     12
+	ILI9881C_COMMAND_INSTR(0xAE, 0x52), //VP24    231
+	ILI9881C_COMMAND_INSTR(0xAF, 0x27), //VP16    239
+	ILI9881C_COMMAND_INSTR(0xB0, 0x2B), //VP12    243
+	ILI9881C_COMMAND_INSTR(0xB1, 0x36), //VP8     247
+	ILI9881C_COMMAND_INSTR(0xB2, 0x63), //VP4     251
+	ILI9881C_COMMAND_INSTR(0xB3, 0x39), //VP0     255
+	ILI9881C_COMMAND_INSTR(0xC0, 0x08), //VN255  0 GAMMA N
+	ILI9881C_COMMAND_INSTR(0xC1, 0x20), //VN251  4
+	ILI9881C_COMMAND_INSTR(0xC2, 0x26), //VN247  8
+	ILI9881C_COMMAND_INSTR(0xC3, 0x10), //VN243  12
+	ILI9881C_COMMAND_INSTR(0xC4, 0x10), //VN239  16
+	ILI9881C_COMMAND_INSTR(0xC5, 0x16), //VN231  24
+	ILI9881C_COMMAND_INSTR(0xC6, 0x10), //VN219  36
+	ILI9881C_COMMAND_INSTR(0xC7, 0x16), //VN203  52
+	ILI9881C_COMMAND_INSTR(0xC8, 0x60), //VN175  80
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1C), //VN144  111
+	ILI9881C_COMMAND_INSTR(0xCA, 0x26), //VN111  144
+	ILI9881C_COMMAND_INSTR(0xCB, 0x61), //VN80   175
+	ILI9881C_COMMAND_INSTR(0xCC, 0x28), //VN52   203
+	ILI9881C_COMMAND_INSTR(0xCD, 0x24), //VN36   219
+	ILI9881C_COMMAND_INSTR(0xCE, 0x52), //VN24   231
+	ILI9881C_COMMAND_INSTR(0xCF, 0x27), //VN16   239
+	ILI9881C_COMMAND_INSTR(0xD0, 0x2B), //VN12   243
+	ILI9881C_COMMAND_INSTR(0xD1, 0x36), //VN8    247
+	ILI9881C_COMMAND_INSTR(0xD2, 0x63), //VN4    251
+	ILI9881C_COMMAND_INSTR(0xD3, 0x39), //VN0    255
+};
+
 static inline struct ili9881c *panel_to_ili9881c(struct drm_panel *panel)
 {
 	return container_of(panel, struct ili9881c, panel);
@@ -830,6 +1231,40 @@ static const struct drm_display_mode w552946aba_default_mode = {
 	.height_mm	= 121,
 };
 
+static const struct drm_display_mode am_8001280gtzqw_default_mode = {
+	.clock		= 74000,
+
+	.hdisplay	= 800,
+	.hsync_start	= 800 + 100,
+	.hsync_end	= 800 + 100 + 100,
+	.htotal		= 800 + 100 + 100 + 20,
+
+	.vdisplay	= 1280,
+	.vsync_start	= 1280 + 20,
+	.vsync_end	= 1280 + 20 + 16,
+	.vtotal		= 1280 + 20 + 16 + 4,
+
+	.width_mm	= 94,
+	.height_mm	= 151,
+};
+
+static const struct drm_display_mode hsd_p0711t_default_mode = {
+	.clock		= 65500,
+
+	.hdisplay	= 768,
+	.hsync_start	= 768 + 120,
+	.hsync_end	= 768 + 120 + 120,
+	.htotal		= 768 + 120 + 120 + 4,
+
+	.vdisplay	= 1024,
+	.vsync_start	= 1024 + 30,
+	.vsync_end	= 1024 + 30 + 20,
+	.vtotal		= 1024 + 30 + 20 + 4,
+
+	.width_mm	= 119,
+	.height_mm	= 159,
+};
+
 static int ili9881c_get_modes(struct drm_panel *panel,
 			      struct drm_connector *connector)
 {
@@ -882,6 +1317,7 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 {
 	struct ili9881c *ctx;
 	int ret;
+	u32 mode_flags;
 
 	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
@@ -916,7 +1352,14 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 
 	drm_panel_add(&ctx->panel);
 
-	dsi->mode_flags = ctx->desc->mode_flags;
+	if (of_property_read_bool((&dsi->dev)->of_node, "mode-flags")) {
+		ret = of_property_read_u32((&dsi->dev)->of_node, "mode-flags", &mode_flags);
+		if (ret)
+			return ret;
+	}
+
+	dsi->mode_flags = ctx->desc->mode_flags | mode_flags;
+
 	dsi->format = MIPI_DSI_FMT_RGB888;
 	dsi->lanes = 4;
 
@@ -953,10 +1396,26 @@ static const struct ili9881c_desc w552946aba_desc = {
 		      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET,
 };
 
+static const struct ili9881c_desc am_8001280gtzqw_desc = {
+	.init = am_8001280gtzqw_init,
+	.init_length = ARRAY_SIZE(am_8001280gtzqw_init),
+	.mode = &am_8001280gtzqw_default_mode,
+	.mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+};
+
+static const struct ili9881c_desc hsd_p0711t_desc = {
+	.init = hsd_p0711t_init,
+	.init_length = ARRAY_SIZE(hsd_p0711t_init),
+	.mode = &hsd_p0711t_default_mode,
+	.mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+};
+
 static const struct of_device_id ili9881c_of_match[] = {
 	{ .compatible = "bananapi,lhr050h41", .data = &lhr050h41_desc },
 	{ .compatible = "feixin,k101-im2byl02", .data = &k101_im2byl02_desc },
 	{ .compatible = "wanchanglong,w552946aba", .data = &w552946aba_desc },
+	{ .compatible = "ampire,am-8001280gtzqw", .data = &am_8001280gtzqw_desc },
+	{ .compatible = "hsd,p0711t", .data = &hsd_p0711t_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9881c_of_match);
diff --git a/drivers/gpu/drm/panel/panel-lvds.c b/drivers/gpu/drm/panel/panel-lvds.c
index de8758c30e6e..72314cc4f2af 100644
--- a/drivers/gpu/drm/panel/panel-lvds.c
+++ b/drivers/gpu/drm/panel/panel-lvds.c
@@ -8,6 +8,7 @@
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  */
 
+#include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
@@ -40,6 +41,13 @@ struct panel_lvds {
 	struct gpio_desc *reset_gpio;
 
 	enum drm_panel_orientation orientation;
+
+	bool skip_blpwr_off;
+	unsigned int enable_delay;
+	unsigned int post_prepare_delay;
+	unsigned int pre_disable_delay;
+	unsigned int disable_delay;
+	unsigned int post_unprepare_delay;
 };
 
 static inline struct panel_lvds *to_panel_lvds(struct drm_panel *panel)
@@ -51,11 +59,24 @@ static int panel_lvds_unprepare(struct drm_panel *panel)
 {
 	struct panel_lvds *lvds = to_panel_lvds(panel);
 
+	if (lvds->pre_disable_delay)
+		msleep(lvds->pre_disable_delay);
+
 	if (lvds->enable_gpio)
 		gpiod_set_value_cansleep(lvds->enable_gpio, 0);
 
-	if (lvds->supply)
-		regulator_disable(lvds->supply);
+	if (lvds->disable_delay)
+		msleep(lvds->disable_delay);
+
+	/* if skip_blpwr_off is set, then don't disable supply. Leave it for blpwm to disable.
+	   NOTE: supply regulator must be the same regulator as the blpwm power-supply */
+	if (!lvds->skip_blpwr_off) {
+		if (lvds->supply)
+			regulator_disable(lvds->supply);
+	}
+
+	if (lvds->post_unprepare_delay)
+		msleep(lvds->post_unprepare_delay);
 
 	return 0;
 }
@@ -65,19 +86,28 @@ static int panel_lvds_prepare(struct drm_panel *panel)
 	struct panel_lvds *lvds = to_panel_lvds(panel);
 
 	if (lvds->supply) {
-		int err;
-
-		err = regulator_enable(lvds->supply);
-		if (err < 0) {
-			dev_err(lvds->dev, "failed to enable supply: %d\n",
-				err);
-			return err;
+		/* if skip_blpwr_off is set, then don't enable supply. Leave it for blpwm to enable.
+		   NOTE: supply regulator must be the same regulator as the blpwm power-supply */
+		if (!lvds->skip_blpwr_off) {
+			int err;
+			err = regulator_enable(lvds->supply);
+			if (err < 0) {
+				dev_err(lvds->dev, "failed to enable supply: %d\n",
+					err);
+				return err;
+			}
 		}
 	}
 
+	if (lvds->enable_delay)
+		msleep(lvds->enable_delay);
+
 	if (lvds->enable_gpio)
 		gpiod_set_value_cansleep(lvds->enable_gpio, 1);
 
+	if (lvds->post_prepare_delay)
+		msleep(lvds->post_prepare_delay);
+
 	return 0;
 }
 
@@ -156,6 +186,27 @@ static int panel_lvds_parse_dt(struct panel_lvds *lvds)
 			   DRM_BUS_FLAG_DATA_LSB_TO_MSB :
 			   DRM_BUS_FLAG_DATA_MSB_TO_LSB;
 
+	/*
+	 * These values are optional and set as 0 by default, the out values
+	 * are modified only if a valid u32 value can be decoded.
+	 */
+	lvds->enable_delay = 0;
+	of_property_read_u32(np, "enable-delay-ms",
+			     &lvds->enable_delay);
+	lvds->post_prepare_delay = 0;
+	of_property_read_u32(np, "post-prepare-delay-ms",
+			     &lvds->post_prepare_delay);
+	lvds->pre_disable_delay = 0;
+	of_property_read_u32(np, "pre-disable-delay-ms",
+			     &lvds->pre_disable_delay);
+	lvds->disable_delay = 0;
+	of_property_read_u32(np, "disable-delay-ms",
+			     &lvds->disable_delay);
+	lvds->post_unprepare_delay = 0;
+	of_property_read_u32(np, "post-unprepare-delay-ms",
+			     &lvds->post_unprepare_delay);
+	lvds->skip_blpwr_off = of_property_read_bool(np, "skip-blpwr-off");
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 009e3e96cadf..66ba4fb07515 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -133,6 +133,12 @@ struct panel_desc {
 
 	/** @connector_type: LVDS, eDP, DSI, DPI, etc. */
 	int connector_type;
+
+	/* additional device tree settings for this panel */
+	u32 refresh_rate;
+	u32 rotate;
+	bool hflip;
+	bool vflip;
 };
 
 struct panel_simple {
@@ -188,6 +194,8 @@ static unsigned int panel_simple_get_timings_modes(struct panel_simple *panel,
 		if (panel->desc->num_timings == 1)
 			mode->type |= DRM_MODE_TYPE_PREFERRED;
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -219,6 +227,8 @@ static unsigned int panel_simple_get_display_modes(struct panel_simple *panel,
 
 		drm_mode_set_name(mode);
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -535,16 +545,21 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vactive) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vfront_porch) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vback_porch) ||
-		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len))
+		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len)) {
+		        dev_warn(dev, "BOUNDS CHECK failed\n");
 			continue;
+		}
 
-		if (ot->flags != dt->flags)
+		if (ot->flags != dt->flags) {
+			dev_warn(dev, "FLAGS CHECK failed. ot: 0x%x dt:0x%x\n", ot->flags, dt->flags);
 			continue;
+		}
 
 		videomode_from_timing(ot, &vm);
 		drm_display_mode_from_videomode(&vm, &panel->override_mode);
 		panel->override_mode.type |= DRM_MODE_TYPE_DRIVER |
 					     DRM_MODE_TYPE_PREFERRED;
+		dev_warn(dev, "Found suitable override.\n");
 		break;
 	}
 
@@ -552,6 +567,70 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		dev_err(dev, "Reject override mode: No display_timing found\n");
 }
 
+static int panel_simple_parse_dt_settings (struct device *dev, struct panel_simple *panel, const struct panel_desc *desc)
+{
+	struct device_node *np = dev->of_node;
+	struct panel_desc *pd = (struct panel_desc *)desc;
+	int ret = 0; /* return -1 to warn override */
+
+	/* if other panel node attributes exists, parse them from device tree, and force override */
+	if (of_property_read_bool(np, "panel-width-mm")) {
+		of_property_read_u32(np, "panel-width-mm", &pd->size.width);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "panel-height-mm")) {
+		of_property_read_u32(np, "panel-height-mm", &pd->size.height);
+		ret = -1;
+	}
+	/* optional delays */
+	if (of_property_read_bool(np, "delay-prepare")) {
+		of_property_read_u32(np, "delay-prepare", &pd->delay.prepare);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-enable")) {
+		of_property_read_u32(np, "delay-enable", &pd->delay.enable);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-disable")) {
+		of_property_read_u32(np, "delay-disable", &pd->delay.disable);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-unprepare")) {
+		of_property_read_u32(np, "delay-disable", &pd->delay.unprepare);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "refresh-rate")) {
+		of_property_read_u32(np, "refresh-rate", &pd->refresh_rate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bits-per-color")) {
+		of_property_read_u32(np, "bits-per-color", &pd->bpc);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-format")) {
+		of_property_read_u32(np, "bus-format", &pd->bus_format);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-flags")) {
+		of_property_read_u32(np, "bus-flags", &pd->bus_flags);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "rotate")) {
+		of_property_read_u32(np, "rotate", &pd->rotate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "horz-flip")) {
+		pd->hflip = true;
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "vert-flip")) {
+		pd->vflip = true;
+		ret = -1;
+	}
+
+	return ret;
+}
+
 static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 {
 	struct panel_simple *panel;
@@ -565,6 +644,11 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	if (!panel)
 		return -ENOMEM;
 
+	/* force override panel_desc panel settings from dt */
+	err = panel_simple_parse_dt_settings(dev, panel, desc);
+	if (err)
+		dev_warn(dev, "panel-desc setting overridden from dt\n");
+
 	panel->enabled = false;
 	panel->prepared_time = 0;
 	panel->desc = desc;
@@ -4715,22 +4799,47 @@ MODULE_DEVICE_TABLE(of, dsi_of_match);
 static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
 {
 	const struct panel_desc_dsi *desc;
-	const struct of_device_id *id;
+//	const struct of_device_id *id;
+	struct device_node *np;
+	u32 dsi_flags = 0;
+	u32 dsi_format = 0;
+	u32 dsi_lanes = 0;
 	int err;
 
-	id = of_match_node(dsi_of_match, dsi->dev.of_node);
-	if (!id)
-		return -ENODEV;
-
-	desc = id->data;
+	np = dsi->dev.of_node;
+	desc = of_device_get_match_data(&dsi->dev);
+	/* if no drm_display_mode from device tree then use the (default) desc (i.e. id->data) */
+	if (!desc) {
+		dsi_flags = desc->flags;
+		dsi_format = desc->format;
+		dsi_lanes = desc->lanes;
+		dev_warn(&dsi->dev, "panel-desc-dsi use default setting\n");
+	} else {
+		/* parse the dsi,flags, format, and lanes setting if set in dt */
+		/* and force override the const static panel_desc_dsi data struct */
+		if (of_property_read_bool(np, "dsi,flags"))
+			of_property_read_u32(np, "dsi,flags", &dsi_flags);
+		if (of_property_read_bool(np, "dsi,format"))
+			of_property_read_u32(np, "dsi,format", &dsi_format);
+		if (of_property_read_bool(np, "dsi,lanes"))
+			of_property_read_u32(np, "dsi,lanes", &dsi_lanes);
+		if (dsi_flags != desc->flags || \
+		    dsi_format != desc->format || \
+		    dsi_lanes !=  desc->lanes) {
+			((struct panel_desc_dsi*)desc)->flags = dsi_flags;
+			((struct panel_desc_dsi*)desc)->format = dsi_format;
+			((struct panel_desc_dsi*)desc)->lanes = dsi_lanes;
+			dev_warn(&dsi->dev, "panel-desc-dsi setting overridden from dt\n");
+		}
+	}
 
 	err = panel_simple_probe(&dsi->dev, &desc->desc);
 	if (err < 0)
 		return err;
 
-	dsi->mode_flags = desc->flags;
-	dsi->format = desc->format;
-	dsi->lanes = desc->lanes;
+	dsi->mode_flags = dsi_flags;
+	dsi->format = dsi_format;
+	dsi->lanes = dsi_lanes;
 
 	err = mipi_dsi_attach(dsi);
 	if (err) {
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 3d99fd6664d7..8ad2df10d04f 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -72,6 +72,13 @@
 #define RTL_GENERIC_PHYID			0x001cc800
 #define RTL_8211FVD_PHYID			0x001cc878
 
+#define RTL8211F_PAGSEL_LCR				0xd04
+#define RTL8211F_LCR					0x10 /* LED Control Register */
+#define RTL8211F_LCR_LED1_MASK			(BIT(5) | BIT(6) | BIT(8) | BIT(9))
+#define RTL8211F_LCR_LED1_SPEED			(BIT(6) | BIT(8))
+#define RTL8211F_LCR_LED2_MASK			(BIT(10) | BIT(11) | BIT(13) | BIT(14))
+#define RTL8211F_LCR_LED2_LINKACTIVE	(BIT(10) | BIT(11) | BIT(13) | BIT(14))
+
 MODULE_DESCRIPTION("Realtek PHY driver");
 MODULE_AUTHOR("Johnson Leung");
 MODULE_LICENSE("GPL");
@@ -127,6 +134,21 @@ static int rtl821x_probe(struct phy_device *phydev)
 	return 0;
 }
 
+static void rtl8211f_setup_led(struct phy_device *phydev) {
+	/* By default the EEE LED mode is enabled */
+	/*
+	 * configure led behaviour, LCR Page: 0xd04, Addr: 0x10
+	 * bit [15:8] |xxxx|LED2_ACT|LED2_LINK_1000|xxxx|  |LED2_LINK_100|LED2_LINK_10|LED1_ACT|LED1_LINK_1000|
+	 * bit [7:0]  |xxxx|LED1_LINK_100|LED1_LINK_10|LED0_ACT|  |LED0_LINK_1000|xxxx|LED0_LINK_100|LED0_LINK_10|
+	 * LED2(Y): link/activity, LED1(G): speed
+	 * Yellow = LED2_ACT + LED2_LINK1000 + LED2_LINK100
+	 * Green = LED1_LINK1000 + LED1_LLINK100
+	 */
+	phy_modify_paged_changed(phydev, RTL8211F_PAGSEL_LCR, RTL8211F_LCR,
+					RTL8211F_LCR_LED1_MASK | RTL8211F_LCR_LED1_MASK,
+					RTL8211F_LCR_LED1_SPEED | RTL8211F_LCR_LED2_LINKACTIVE);
+}
+
 static int rtl8201_ack_interrupt(struct phy_device *phydev)
 {
 	int err;
@@ -416,6 +438,7 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 		}
 	}
 
+	rtl8211f_setup_led(phydev);
 	return genphy_soft_reset(phydev);
 }
 
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 7818c2551294..619ed86b073b 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -90,7 +90,8 @@ static int dwc3_get_dr_mode(struct dwc3 *dwc)
 		    (!IS_ENABLED(CONFIG_USB_ROLE_SWITCH) ||
 		     !device_property_read_bool(dwc->dev, "usb-role-switch")) &&
 		    !DWC3_VER_IS_PRIOR(DWC3, 330A))
-			mode = USB_DR_MODE_PERIPHERAL;
+		    /* imx8mp: allow for dual role with no usb-role-switch in dts */
+		    mode = DWC3_VER_IS(DWC3, 330B) ? USB_DR_MODE_OTG : USB_DR_MODE_PERIPHERAL;
 	}
 
 	if (mode != dwc->dr_mode) {
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 5c77ddb2c34b..8fb72edf71e6 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1265,6 +1265,7 @@ struct dwc3 {
 #define DWC3_REVISION_300A	0x5533300a
 #define DWC3_REVISION_310A	0x5533310a
 #define DWC3_REVISION_330A	0x5533330a
+#define DWC3_REVISION_330B	0x5533330b
 
 #define DWC31_REVISION_ANY	0x0
 #define DWC31_REVISION_110A	0x3131302a
diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index b28ac814a8dd..040667128dd3 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -28,9 +28,12 @@ struct pwm_bl_data {
 	struct regulator	*power_supply;
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
+	unsigned int		pre_pwm_on_delay;
 	bool			legacy;
 	unsigned int		post_pwm_on_delay;
 	unsigned int		pwm_off_delay;
+	unsigned int		post_pwm_off_delay;
+	bool			skip_blpwr_off;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -49,6 +52,8 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 	if (pb->enabled)
 		return;
 
+	if (pb->pre_pwm_on_delay)
+		msleep(pb->pre_pwm_on_delay);
 	err = regulator_enable(pb->power_supply);
 	if (err < 0)
 		dev_err(pb->dev, "failed to enable power supply\n");
@@ -83,8 +88,13 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	state.duty_cycle = 0;
 	pwm_apply_state(pb->pwm, &state);
 
-	regulator_disable(pb->power_supply);
+	/* if skip_blpwr_off is set, then don't disable supply. Leave it for lvds-panel to disable.
+		   NOTE: this supply regulator must be set to the lvds0-panel */
+	if (!pb->skip_blpwr_off)
+		regulator_disable(pb->power_supply);
 	pb->enabled = false;
+	if (pb->post_pwm_off_delay)
+		msleep(pb->post_pwm_off_delay);
 }
 
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
@@ -265,9 +275,14 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	 * These values are optional and set as 0 by default, the out values
 	 * are modified only if a valid u32 value can be decoded.
 	 */
+	of_property_read_u32(node, "pre-pwm-on-delay-ms",
+			     &data->pre_pwm_on_delay);
 	of_property_read_u32(node, "post-pwm-on-delay-ms",
 			     &data->post_pwm_on_delay);
 	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
+	of_property_read_u32(node, "post-pwm-off-delay-ms",
+			     &data->post_pwm_off_delay);
+	data->skip_blpwr_off = of_property_read_bool(node, "skip-blpwr-off");
 
 	/*
 	 * Determine the number of brightness levels, if this property is not
@@ -506,8 +521,11 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	pb->pre_pwm_on_delay = data->pre_pwm_on_delay;
 	pb->post_pwm_on_delay = data->post_pwm_on_delay;
 	pb->pwm_off_delay = data->pwm_off_delay;
+	pb->post_pwm_off_delay = data->post_pwm_off_delay;
+	pb->skip_blpwr_off = data->skip_blpwr_off;
 	strcpy(pb->fb_id, data->fb_id);
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
diff --git a/include/linux/pwm_backlight.h b/include/linux/pwm_backlight.h
index c922b067ad41..8f2c4cbf306f 100644
--- a/include/linux/pwm_backlight.h
+++ b/include/linux/pwm_backlight.h
@@ -14,8 +14,11 @@ struct platform_pwm_backlight_data {
 	unsigned int lth_brightness;
 	unsigned int pwm_period_ns;
 	unsigned int *levels;
+	unsigned int pre_pwm_on_delay;
 	unsigned int post_pwm_on_delay;
 	unsigned int pwm_off_delay;
+	unsigned int post_pwm_off_delay;
+	bool skip_blpwr_off;
 	int (*init)(struct device *dev);
 	int (*notify)(struct device *dev, int brightness);
 	void (*notify_after)(struct device *dev, int brightness);
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index a916f4619ea3..41691e111954 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -41,20 +41,20 @@
 /* default value of sgtl5000 registers */
 static const struct reg_default sgtl5000_reg_defaults[] = {
 	{ SGTL5000_CHIP_DIG_POWER,		0x0000 },
-	{ SGTL5000_CHIP_I2S_CTRL,		0x0010 },
+	{ SGTL5000_CHIP_I2S_CTRL,		0x001b },
 	{ SGTL5000_CHIP_SSS_CTRL,		0x0010 },
 	{ SGTL5000_CHIP_ADCDAC_CTRL,		0x020c },
 	{ SGTL5000_CHIP_DAC_VOL,		0x3c3c },
 	{ SGTL5000_CHIP_PAD_STRENGTH,		0x015f },
-	{ SGTL5000_CHIP_ANA_ADC_CTRL,		0x0000 },
+	{ SGTL5000_CHIP_ANA_ADC_CTRL,		0x00ff },
 	{ SGTL5000_CHIP_ANA_HP_CTRL,		0x1818 },
-	{ SGTL5000_CHIP_ANA_CTRL,		0x0111 },
+	{ SGTL5000_CHIP_ANA_CTRL,		0x0022 },
 	{ SGTL5000_CHIP_REF_CTRL,		0x0000 },
 	{ SGTL5000_CHIP_MIC_CTRL,		0x0000 },
 	{ SGTL5000_CHIP_LINE_OUT_CTRL,		0x0000 },
-	{ SGTL5000_CHIP_LINE_OUT_VOL,		0x0404 },
-	{ SGTL5000_CHIP_PLL_CTRL,		0x5000 },
-	{ SGTL5000_CHIP_CLK_TOP_CTRL,		0x0000 },
+	{ SGTL5000_CHIP_LINE_OUT_VOL,		0x1f1f },
+	{ SGTL5000_CHIP_PLL_CTRL,		0xa3d7 },
+	{ SGTL5000_CHIP_CLK_TOP_CTRL,		0x0008 },
 	{ SGTL5000_CHIP_ANA_STATUS,		0x0000 },
 	{ SGTL5000_CHIP_SHORT_CTRL,		0x0000 },
 	{ SGTL5000_CHIP_ANA_TEST2,		0x0000 },
@@ -1339,18 +1339,22 @@ static int sgtl5000_set_power_regs(struct snd_soc_component *component)
 					SGTL5000_INT_OSC_EN);
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
+	} else if (vddio >= 3100 && vdda >= 3100) {
+		/* Disable charge pump */
+		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
+
+		/* VDDC use VDDIO rail */
+		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
+		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
+				SGTL5000_VDDC_MAN_ASSN_SHIFT;
 	} else {
+		dev_info(component->dev, "SGTL5000 will choose highest voltage automatically!\n");
+
+		/* Disable charge pump */
 		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
-		/*
-		 * if vddio == vdda the source of charge pump should be
-		 * assigned manually to VDDIO
-		 */
-		if (regulator_is_equal(sgtl5000->supplies[VDDA].consumer,
-				       sgtl5000->supplies[VDDIO].consumer)) {
-			lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
-			lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
-				    SGTL5000_VDDC_MAN_ASSN_SHIFT;
-		}
+
+		/* Switch to highest supply voltage */
+		lreg_ctrl &= ~SGTL5000_VDDC_ASSN_OVRD;
 	}
 
 	snd_soc_component_write(component, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);
diff --git a/sp2-imx8mp.dts b/sp2-imx8mp.dts
new file mode 100644
index 000000000000..654c2a587d8f
--- /dev/null
+++ b/sp2-imx8mp.dts
@@ -0,0 +1,1262 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mp.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	model = "ADLINK Smart Panel - IMX8MP board";
+	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+	chosen {
+		stdout-path = &uart2;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		status_led {
+			label = "green:sys-status";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on"; /* LED GREEN */
+		};
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0xc0000000>,
+		      <0x1 0x00000000 0 0xc0000000>;
+	};
+
+	/* 25MHz reference crystal */
+	ref25m: ref25xtal {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <25000000>;
+	};
+
+	reg_lvds_blpwr: regulator-lvds-pwr {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_lvds_bl_pwr>;
+		regulator-name = "vdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio3 20 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_usb0_pwr_en: regulator-usb0pwren {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb0_pwr_en>;
+		regulator-name = "usb0-pwr-en";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_keys>;
+
+		wakeup {
+			label = "Wake-Up";
+			gpios = <&gpio1 7 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WAKEUP>;
+			debounce-interval = <10>;
+			wakeup-source;
+		};
+	};
+
+	extcon_usb0: extcon-usb-idvbus-grp0 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&gpio1 10 GPIO_ACTIVE_LOW>; /* GPIO1_IO10 */
+		// vbus-gpio = <&gpio1 15 GPIO_ACTIVE_LOW>; /* GPIO1_IO15 */
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_ex_audio_3v: regulator-ex-audio-3v {
+		compatible = "regulator-fixed";
+		regulator-name = "ex-audio-3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	reg_ex_audio_1v8: regulatorex-audio-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "+V1.8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	ex_audio_clk: sgtl5000_19M {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <19200000>; /* 19.2MHz */
+	};
+
+	reg_speaker_amp: regulator-audio-amplifier {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usbhub_spkamp>;
+		regulator-name = "speaker-amp";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpios = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	sound-hdmi {
+		compatible = "fsl,imx-audio-hdmi";
+		model = "audio-hdmi";
+		audio-cpu = <&aud2htx>;
+		hdmi-out;
+		constraint-rate = <44100>,
+				<88200>,
+				<176400>,
+				<32000>,
+				<48000>,
+				<96000>,
+				<192000>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "fsl,imx-audio-sgtl5000";
+		model = "audio-sgtl5000";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_hpdet>;
+		hp-det-gpio = <&gpio4 20 GPIO_ACTIVE_LOW>;
+		codec-master;
+		ssi-controller = <&sai3>;
+		audio-codec = <&sgtl5000>;
+		audio-routing =
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT",
+			"Ext Spk", "LINE_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <3>;
+		status = "disabled";
+	};
+
+	lvds_backlight: lvds_backlight {
+		compatible = "pwm-backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_bl_en>;
+		enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		power-supply = <&reg_lvds_blpwr>;
+		pwms = <&pwm2 0 100000 0>;
+		status = "disabled";
+
+		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
+							10 11 12 13 14 15 16 17 18 19
+							20 21 22 23 24 25 26 27 28 29
+							30 31 32 33 34 35 36 37 38 39
+							40 41 42 43 44 45 46 47 48 49
+							50 51 52 53 54 55 56 57 58 59
+							60 61 62 63 64 65 66 67 68 69
+							70 71 72 73 74 75 76 77 78 79
+							80 81 82 83 84 85 86 87 88 89
+							90 91 92 93 94 95 96 97 98 99
+							100>;
+		default-brightness-level = <80>;
+	};
+
+	lvds0_panel {
+		backlight = <&lvds_backlight>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_lvds_vdd>;
+		enable-gpios = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+
+		data-mapping = "vesa-24";
+		status = "disabled";
+
+		port {
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+
+	pwm-beeper {
+		compatible = "pwm-beeper";
+		pwms = <&pwm4 0 500000 0>;
+	};
+};
+
+&A53_0 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_1 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_2 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_3 {
+	cpu-supply = <&buck2>;
+};
+
+&aud2htx {
+	status = "okay";
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio1_hog>;
+
+	gpio-line-names =       \
+		"", "USB_MUX_SEL", "", "", "", "", "", "",  \
+		"", "", "", "", "", "", "", "",      \
+		"", "", "", "", "", "", "", "", \
+		"", "", "", "", "", "", "", "";
+};
+
+&gpio4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio4_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"UART_MODE0", "UART_MODE1", "", "", "HWID_2", "HWID_3", "", "";
+/*
+	uart_mode0 {
+		gpios = <&gpio4 24 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE0";
+	};
+
+	uart_mode1 {
+		gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE1";
+	};
+
+	hwid_2 {
+		gpios = <&gpio4 28 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_2";
+	};
+
+	hwid_3 {
+		gpios = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_3";
+	};
+*/
+};
+
+&gpio5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio5_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "HWID_1", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "";
+/*
+	hwid_1 {
+		gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_1";
+	};
+*/
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_bl_pwm2>;
+	status = "okay";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_buzz_pwm4>;
+	status = "okay";
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	snps,force_thresh_dma_mode;
+	snps,mtl-tx-config = <&mtl_tx_setup>;
+	snps,mtl-rx-config = <&mtl_rx_setup>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <1>;
+			eee-broken-1000t;
+			realtek,clkout-disable;
+		};
+	};
+
+	mtl_tx_setup: tx-queues-config {
+		snps,tx-queues-to-use = <5>;
+		snps,tx-sched-sp;
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+		};
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+		};
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+		};
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+		};
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+		};
+	};
+	mtl_rx_setup: rx-queues-config {
+		snps,rx-queues-to-use = <5>;
+		snps,rx-sched-sp;
+		queue0 {
+			snps,dcb-algorithm;
+			snps,priority = <0x1>;
+			snps,map-to-dma-channel = <0>;
+		};
+		queue1 {
+			snps,dcb-algorithm;
+			snps,priority = <0x2>;
+			snps,map-to-dma-channel = <1>;
+		};
+		queue2 {
+			snps,dcb-algorithm;
+			snps,priority = <0x4>;
+			snps,map-to-dma-channel = <2>;
+		};
+		queue3 {
+			snps,dcb-algorithm;
+			snps,priority = <0x8>;
+			snps,map-to-dma-channel = <3>;
+		};
+		queue4 {
+			snps,dcb-algorithm;
+			snps,priority = <0xf0>;
+			snps,map-to-dma-channel = <4>;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@1 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <2>;
+			eee-broken-1000t;
+			reset-gpios = <&gpio4 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,aldps-enable;
+			realtek,clkout-disable;
+			interrupt-parent = <&gpio4>;
+			interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+			wakeup-source;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic@25 {
+		compatible = "nxp,pca9450c";
+		reg = <0x25>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_pmic>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		regulators {
+			buck1: BUCK1 {
+				regulator-name = "BUCK1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2: BUCK2 {
+				regulator-name = "BUCK2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+				nxp,dvs-run-voltage = <950000>;
+				nxp,dvs-standby-voltage = <850000>;
+			};
+
+			buck4: BUCK4{
+				regulator-name = "BUCK4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5: BUCK5{
+				regulator-name = "BUCK5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6: BUCK6 {
+				regulator-name = "BUCK6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1: LDO1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2: LDO2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3: LDO3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4: LDO4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5: LDO5 {
+				regulator-name = "LDO5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	status = "okay";
+};
+
+&ecspi2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2 &pinctrl_ecspi2_cs>;
+	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	spidev1: spi@0 {
+		reg = <0>;
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <500000>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+	
+	/* RTC: PCF85063A */
+	rtc: pcf85063a@51 {
+		compatible = "nxp,pcf85063a";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rtc>;
+		quartz-load-femtofarads = <12500>;
+		reg = <0x51>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+
+	/* Comment to show an external PCIe CLK GEN: PI6CG33202C-ZDIEX */
+	/* pcieclk0: pi6cg33202@6a {
+		reg = <0x6a>;
+		compatible = "pi,6cg33202";
+	}; */
+
+};
+
+&i2c3 {
+	clock-frequency = <300000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	/* TPM: ST33HTPH2X32AHD5 */
+	tpm: st33htph77@2e {
+		compatible = "st,st33htpm-i2c";
+		reg = <0x2e>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_tpm>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>;
+		tpm-reset = <&gpio1 6 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+
+	/* sgtl5000 audio codec */
+	sgtl5000: audio-codec@a {
+		compatible = "fsl,sgtl5000";
+		#sound-dai-cells = <0>;
+		reg = <0x0a>;
+		micbias-voltage-m-volts = <2250>;
+		VDDA-supply = <&reg_ex_audio_3v>;
+		VDDIO-supply = <&reg_ex_audio_1v8>;
+		VDDD-supply = <&reg_ex_audio_1v8>;
+		clocks = <&ex_audio_clk>;
+		status = "disabled";
+	};
+
+	eeprom@50 {
+		compatible = "atmel,24c256";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x50>;
+		pagesize = <64>;
+		size = <32768>;
+		address-width = <16>;
+	};
+};
+
+&i2c6 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c6>;
+	status = "okay";
+
+	/* SX1509 */
+	sx1509: gpioext0@3f {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3f>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio3>;
+		interrupts = <21 IRQ_TYPE_EDGE_FALLING>;
+
+		gpio-line-names =	\
+		"DI0", "DI1", "DI2", "DI3", "DO0", "DO1", "DO2", "DO3",	\
+		"", "", "", "", "", "", "", "";
+
+		status = "okay";
+
+		/* GPIO Expander 0 Mapping :
+		 * 0: CN_DI0, 1: CN_DI1, 2: CN_DI2, 3: CN_DI3,
+		 * 4: CN_DO0, 5: CN_DO1, 6: CN_DO2, 7: CN_DO3
+		 * 8~15: N/A
+		 */
+	};
+};
+
+&mipi_dsi {
+	/delete-node/ panel@0;
+};
+
+&irqsteer_hdmi {
+	status = "okay";
+};
+
+&hdmi_blk_ctrl {
+	status = "okay";
+};
+
+&hdmi_pavi {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&hdmiphy {
+	status = "okay";
+};
+
+&lcdif1 {
+	status = "disabled";
+};
+
+&lcdif2 {
+	status = "disabled";
+};
+
+&lcdif3 {
+	status = "okay";
+
+	thres-low  = <1 2>;	 /* (FIFO * 1 / 2) */
+	thres-high = <3 4>;	 /* (FIFO * 3 / 4) */
+};
+
+&ldb {
+	/* fsl,dual-channel; */
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+
+		port@1 {
+			reg = <1>;
+
+			lvds_out: endpoint {
+				remote-endpoint = <&panel_lvds_in>;
+			};
+		};
+	};
+};
+
+&snvs_pwrkey {
+	status = "okay";
+};
+
+&easrc {
+	fsl,asrc-rate  = <48000>;
+	status = "okay";
+};
+
+&xcvr {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&sdma2 {
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	/* fsl,sai-mclk-direction-output; */
+	status = "okay";
+};
+
+&uart1 { /* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart2 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* RS485 only */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/* SP399E RS232/RS422/RS485 */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&usb3_phy0 {
+	//vbus-power-supply = <&ptn5110>;
+	fsl,phy-tx-vref-tune = <0xe>;
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vboost-level = <2>; /* set amplitude to 1.04v */
+	fsl,phy-comp-dis-tune = <7>;
+	fsl,pcs-tx-deemph-3p5db = <0x21>;
+	fsl,phy-pcs-tx-swing-full = <0x7f>;
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb0_id>;
+	dr_mode = "otg";
+	// NOTE: don't set usb-role-switch to enable extcon
+	// (patch core.c to enable extcon fn in drd.c)
+	//usb-role-switch;
+	// NOTE: dual role, not real OTG for imx8mp, no host-negocitation or session-request
+	hnp-disable;
+	srp-disable;
+	extcon = <&extcon_usb0>;
+	otg-rev = <0x0200>;
+	status = "okay";
+};
+
+&usb3_phy1 {
+	fsl,phy-tx-preemp-amp-tune = <3>;
+	fsl,phy-tx-vref-tune = <0xb>;
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usdhc2 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC2>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&usdhc3 {
+	assigned-clocks = <&clk IMX8MP_CLK_USDHC3>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+/*
+fsl,pins = <PIN_FUNC_ID CONFIG>,
+  - PIN_FUNC_ID is a pin (5-values) working on a specific function (MUX control)
+  - CONFIG is the pad setting (1-value) like pull-up for this pin. (PAD control)
+  see iomux-v3.h
+*/
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c3
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c3
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000019
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000019
+
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23	0x00000106	// I2C6_INT#
+			MX8MP_IOMUXC_SD1_DATA6__GPIO2_IO08	0x00000106	// M.2 BT wakeup
+			MX8MP_IOMUXC_SD1_DATA7__GPIO2_IO09	0x00000106	// M.2 SDIO wakeup
+		>;
+	};
+
+	pinctrl_rtc: rtcgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXD1__GPIO3_IO22	0x80  /* RTC intr */
+		>;
+	};
+
+	pinctrl_bl_pwm2: blpwm2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
+		>;
+	};
+
+	pinctrl_buzz_pwm4: buzzpwm4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXFS__PWM4_OUT	0x116
+		>;
+	};
+
+	pinctrl_tpm: tpmgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DQS__GPIO3_IO14		0xd6	// TPM IRQ
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x156	// TPM reset
+		>;
+	};
+
+	pinctrl_usbhub_spkamp: usbhubspkampgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12		0x146	//HUB_RESET or AUDIO_AMP
+		>;
+	};
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC				0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22				0x19		//ENET RESET
+			MX8MP_IOMUXC_SAI2_RXFS__GPIO4_IO21				0x00000106	//ENET INT
+			MX8MP_IOMUXC_GPIO1_IO08__ENET_QOS_1588_EVENT0_IN		0x106
+			MX8MP_IOMUXC_GPIO1_IO09__ENET_QOS_1588_EVENT0_OUT		0x106
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			MX8MP_IOMUXC_SAI1_RXD1__GPIO4_IO03		0x00000106	//ENET1 INT
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x19		//ENET1_RESET
+			MX8MP_IOMUXC_SAI1_RXC__ENET1_1588_EVENT0_OUT	0x00000106
+			MX8MP_IOMUXC_SAI1_RXFS__ENET1_1588_EVENT0_IN	0x00000106
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX		0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX		0x154
+		>;
+	};
+
+	pinctrl_ecspi2: ecspi2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi2_cs: ecspi2cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x19
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL		0x400001c2
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c2
+		>;
+	};
+
+	pinctrl_i2c6: i2c6grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__I2C6_SCL	0x400001c2
+			MX8MP_IOMUXC_UART4_TXD__I2C6_SDA	0x400001c2
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
+		>;
+	};
+
+	pinctrl_reg_bl_en: regblengrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO00__GPIO1_IO00	0x16
+		>;
+	};
+
+	pinctrl_reg_lvds_vdd: reglvdsvddgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27	0x16
+		>;
+	};
+
+	pinctrl_reg_lvds_bl_pwr: reglvdsblpwrgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXC__GPIO3_IO20	0x106
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC	0xd6
+			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK	0xd6
+			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK	0xd6
+		>;
+	};
+
+	pinctrl_i2c2_irq: i2c2irqgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD6__GPIO4_IO18	0x1c4
+		>;
+	};
+
+	pinctrl_i2c3_irq: i2c3irqgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4
+		>;
+	};
+
+	pinctrl_gpio_keys: gpiokeysgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO07__GPIO1_IO07		0x80 // FUNCTION_INT
+		>;
+	};
+
+	pinctrl_hpdet: hpdetgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x1C6
+		>;
+	};
+
+	pinctrl_usb0_pwr_en: usb0pwrengrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO14__GPIO1_IO14	0x16
+		>;
+	};
+
+	pinctrl_gpio1_hog: gpio1hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO01__GPIO1_IO01	0x19	// GPIO_USB_MUX_SEL(Need check boot status is high or low)
+		>;
+	};
+
+	pinctrl_gpio4_hog: gpio4hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_TXFS__GPIO4_IO24	0x19	// UART_MODE0
+			MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25	0x19	// UART_MODE1
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28	0x80	// HWID_2
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29	0x80	// HWID_3
+		>;
+	};
+
+	pinctrl_gpio5_hog: gpio5hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05	0x00000106	// HWID_1
+		>;
+	};
+
+	pinctrl_usb0_id: usb0-id-grp {
+		fsl,pins = <
+			// MX8MP_IOMUXC_GPIO1_IO10__USB1_ID		0x19 // DNU - do not use
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10		0x19
+		>;
+	};
+
+	pinctrl_usb0_oc: usb0-oc-grp {
+		fsl,pins = <
+			// MX8MP_IOMUXC_GPIO1_IO15__USB2_OC		0x19
+			MX8MP_IOMUXC_GPIO1_IO15__GPIO1_IO15		0x19
+		>;
+	};
+
+//	pinctrl_usb1_oc: usb1ocgrp {
+//		fsl,pins = <
+//			MX8MP_IOMUXC_GPIO1_IO13__USB1_OC		0x19
+//		>;
+//	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+			MX8MP_IOMUXC_UART3_RXD__UART1_DCE_CTS	0x140
+			MX8MP_IOMUXC_UART3_TXD__UART1_DCE_RTS	0x140
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x140
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x140
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SCLK__UART3_DCE_RX		0x140
+			MX8MP_IOMUXC_ECSPI1_MOSI__UART3_DCE_TX		0x140
+			MX8MP_IOMUXC_ECSPI1_SS0__UART3_DCE_RTS		0x140
+			MX8MP_IOMUXC_ECSPI1_MISO__UART3_DCE_CTS		0x140
+		>;
+	};
+
+    pinctrl_uart4: uart4grp {
+        fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA00__UART4_DCE_RX		0x140
+			MX8MP_IOMUXC_NAND_DATA01__UART4_DCE_TX		0x140
+			MX8MP_IOMUXC_NAND_DATA02__UART4_DCE_CTS		0x140
+			MX8MP_IOMUXC_NAND_DATA03__UART4_DCE_RTS		0x140
+        >;
+    };
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+            MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12       0x1c4
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0x166
+		>;
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_vc8000e {
+	status = "okay";
+};
+
+&vpu_v4l2 {
+	status = "okay";
+};
+
+&gpu_3d {
+	status = "okay";
+};
+
+&gpu_2d {
+	status = "okay";
+};
+
+&ml_vipsi {
+	status = "okay";
+};
+
+&mix_gpu_ml {
+	status = "okay";
+};
+
+#include "imx8mp-android.dtsi"
diff --git a/sp2imx8mp_gki.fragment b/sp2imx8mp_gki.fragment
new file mode 100644
index 000000000000..2a749919a3b8
--- /dev/null
+++ b/sp2imx8mp_gki.fragment
@@ -0,0 +1,137 @@
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX8M=m
+CONFIG_MXC_CLK=m
+CONFIG_CLK_IMX8MP=m
+CONFIG_DEVICE_THERMAL=m
+CONFIG_IMX8MM_THERMAL=m
+CONFIG_IMX8M_PM_DOMAINS=m
+CONFIG_IMX_GPCV2_PM_DOMAINS=m
+CONFIG_PINCTRL_IMX=m
+CONFIG_PINCTRL_IMX8MP=m
+CONFIG_SERIAL_IMX=m
+CONFIG_SERIAL_IMX_CONSOLE=m
+CONFIG_IMX2_WDT=m
+CONFIG_I2C_IMX=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_REGULATOR_PCA9450=m
+CONFIG_PWM_IMX27=m
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_MMC_SDHCI_ESDHC_IMX=m
+CONFIG_PHY_FSL_IMX8MP_LVDS=m
+CONFIG_PHY_SAMSUNG_HDMI_PHY=m
+CONFIG_MXC_GPU_VIV=m
+CONFIG_IMX8MM_LCDIF_CORE=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_IMX_CDNS_MHDP=m
+CONFIG_DRM_CDNS_HDCP=m
+CONFIG_DRM_IMX8MP_LDB=m
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=m
+CONFIG_DRM_ITE_IT6263=m
+CONFIG_DRM_IMX_SEC_DSIM=m
+CONFIG_DRM_DW_HDMI_CEC=m
+CONFIG_DRM_DW_HDMI_GP_AUDIO=m
+CONFIG_DRM_IMX_HDMI=m
+CONFIG_DRM_IMX=m
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_IMX_LCDIFV3_CORE=m
+CONFIG_PHY_FSL_IMX8MQ_USB=m
+CONFIG_USB_DWC3_IMX8MP=m
+CONFIG_TYPEC_SWITCH_GPIO=m
+
+CONFIG_IMX_SDMA=m
+CONFIG_SND_SOC_IMX_CARD=m
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_EASRC=m
+CONFIG_SND_SOC_WM8960=m
+CONFIG_SND_SOC_WM8962=m
+CONFIG_SND_SOC_FSL_ASOC_CARD=m
+CONFIG_SND_SOC_BT_SCO=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_AUD2HTX=m
+CONFIG_SND_SOC_IMX_HDMI=m
+CONFIG_IMX_DSP_REMOTEPROC=m
+CONFIG_DMABUF_HEAPS_DSP=m
+
+CONFIG_IMX_MBOX=m
+CONFIG_IMX_LPA_CTRL=m
+CONFIG_I2C_RPBUS=m
+CONFIG_SND_SOC_IMX_RPMSG=m
+CONFIG_SND_SOC_IMX_PCM512X_RPMSG=m
+CONFIG_IMX_REMOTEPROC=m
+CONFIG_SND_SOC_RPMSG_WM8960=m
+CONFIG_SND_SOC_RPMSG_WM8960_I2C=m
+CONFIG_SND_SOC_RPMSG_PCM512X=m
+CONFIG_SND_SOC_RPMSG_PCM512X_I2C=m
+CONFIG_SND_SOC_FSL_RPMSG=m
+CONFIG_SND_SOC_TPA6130A2=m
+CONFIG_SND_SOC_SOF_OF=m
+CONFIG_SND_SOC_SOF_TOPLEVEL=y
+CONFIG_SND_SOC_SOF_IMX8M=m
+CONFIG_SND_SOC_SOF_IMX_TOPLEVEL=y
+CONFIG_IMX_DSP=m
+
+CONFIG_RTC_DRV_SNVS=m
+
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C=m
+CONFIG_KEYBOARD_SNVS_PWRKEY=m
+
+CONFIG_PHY_FSL_IMX8M_PCIE=m
+CONFIG_PCI_IMX6=m
+
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_IMX_CAPTURE=m
+
+CONFIG_CFG80211=m
+CONFIG_MAC80211=m
+
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_ETHERNET=y
+CONFIG_FEC=m
+CONFIG_REALTEK_PHY=m
+
+CONFIG_TRUSTY=m
+CONFIG_TRUSTY_CRASH_IS_PANIC=y
+
+# CONFIG_MXC_HANTRO is not set
+CONFIG_MXC_HANTRO_VC8000E=m
+CONFIG_MXC_HANTRO_845=m
+CONFIG_MXC_HANTRO_V4L2=m
+
+CONFIG_BATTERY_DUMMY=m
+
+CONFIG_RESET_IMX7=m
+CONFIG_IMX8M_BUSFREQ=m
+CONFIG_IMX_IRQSTEER=m
+CONFIG_GPIO_MXC=m
+CONFIG_TIMER_IMX_SYS_CTR=m
+
+CONFIG_FPGA=y
+
+CONFIG_NVMEM_IMX_OCOTP=m
+CONFIG_CPUFREQ_DT=m
+CONFIG_ARM_IMX_CPUFREQ_DT=m
+
+CONFIG_LTO_CLANG_THIN=y
+# CONFIG_ARM64_BTI_KERNEL is not set
+
+CONFIG_DMABUF_HEAPS_SYSTEM=m
+CONFIG_DMABUF_HEAPS_CMA=m
+CONFIG_DMABUF_IMX=m
+
+# CONFIG_IMX_EL_ENCLAVE is not set
+# CONFIG_IMX_RPMSG_TTY is not set
+CONFIG_ZRAM=m
+CONFIG_ZSMALLOC=m
+
+# CONFIG_DEBUG_INFO_BTF_MODULES is not set
+
+CONFIG_FSL_IMX8_DDR_PMU=m
+# CONFIG_SOC_IMX9 is not set
+# CONFIG_MODULE_SIG_ALL is not set
+CONFIG_IMX_GKI_FIX=y
-- 
2.34.1

