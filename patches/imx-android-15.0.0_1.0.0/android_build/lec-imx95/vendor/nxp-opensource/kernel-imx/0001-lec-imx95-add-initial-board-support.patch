From b22b3b060a18f7a84b48d3fc6beb510a5c39cb95 Mon Sep 17 00:00:00 2001
From: veeraadlink <veera.h@adlinktech.com>
Date: Wed, 22 Oct 2025 13:44:05 +0530
Subject: [PATCH] lec-imx95-add-initial-board-support

---
 arch/arm64/boot/dts/Makefile                  |    1 +
 .../arm64/boot/dts/adlink/g080uan02-basic.dts |   72 +
 .../boot/dts/adlink/g156hat02.6-basic.dts     |  101 +
 arch/arm64/boot/dts/adlink/imx95-pinfunc.h    |  865 +++++
 arch/arm64/boot/dts/adlink/imx95.dtsi         | 3264 +++++++++++++++++
 .../dts/adlink/lec-imx95-cameras-lvds.dts     |    9 +
 .../boot/dts/adlink/lec-imx95-g080uan02.dts   |    7 +
 .../boot/dts/adlink/lec-imx95-g156hat02.dts   |    7 +
 .../dts/adlink/lec-imx95-lt9611-noconsole.dts |   12 +
 .../dts/adlink/lec-imx95-lt9611-pcie8997.dts  |   12 +
 .../dts/adlink/lec-imx95-lt9611-uart2.dts     |   27 +
 .../boot/dts/adlink/lec-imx95-lt9611.dts      |    9 +
 .../boot/dts/adlink/lec-imx95-lt96114k.dts    |    8 +
 .../dts/adlink/lec-imx95-ov13855-lvds.dts     |   10 +
 .../boot/dts/adlink/lec-imx95-ov13855.dts     |   10 +
 .../boot/dts/adlink/lec-imx95-ov5640.dts      |    8 +
 .../arm64/boot/dts/adlink/lec-imx95-uart2.dts | 1263 +++++++
 arch/arm64/boot/dts/adlink/lec-imx95.dts      | 1265 +++++++
 arch/arm64/boot/dts/adlink/lt9611-basic.dts   |  116 +
 arch/arm64/boot/dts/adlink/lt96114k-basic.dts |  117 +
 arch/arm64/boot/dts/adlink/ov13855-basic.dts  |  147 +
 arch/arm64/boot/dts/adlink/ov5640-basic.dts   |  127 +
 arch/arm64/boot/dts/freescale/Makefile        |    7 +
 .../boot/dts/freescale/g080uan02-basic.dts    |   72 +
 .../boot/dts/freescale/g156hat02.6-basic.dts  |  101 +
 .../freescale/imx95-19x19-evk-adv7535.dtso    |   40 +-
 .../boot/dts/freescale/imx95-19x19-evk.dts    |   50 +-
 arch/arm64/boot/dts/freescale/imx95.dtsi      |   30 +-
 .../dts/freescale/lec-imx95-cameras-lvds.dts  |    9 +
 .../dts/freescale/lec-imx95-g080uan02.dts     |    7 +
 .../dts/freescale/lec-imx95-g156hat02.dts     |    7 +
 .../freescale/lec-imx95-lt9611-noconsole.dts  |   12 +
 .../freescale/lec-imx95-lt9611-pcie8997.dts   |   12 +
 .../dts/freescale/lec-imx95-lt9611-uart2.dts  |   27 +
 .../boot/dts/freescale/lec-imx95-lt9611.dts   |    9 +
 .../boot/dts/freescale/lec-imx95-lt96114k.dts |    8 +
 .../dts/freescale/lec-imx95-ov13855-lvds.dts  |   10 +
 .../boot/dts/freescale/lec-imx95-ov13855.dts  |   10 +
 .../boot/dts/freescale/lec-imx95-ov5640.dts   |    8 +
 .../boot/dts/freescale/lec-imx95-uart2.dts    | 1263 +++++++
 arch/arm64/boot/dts/freescale/lec-imx95.dts   | 1264 +++++++
 .../arm64/boot/dts/freescale/lt9611-basic.dts |  116 +
 .../boot/dts/freescale/lt96114k-basic.dts     |  117 +
 .../boot/dts/freescale/ov13855-basic.dts      |  147 +
 .../arm64/boot/dts/freescale/ov5640-basic.dts |  127 +
 arch/arm64/configs/lec_imx95_gki.fragment     |  194 +
 drivers/gpio/Kconfig                          |    8 +
 drivers/gpio/Makefile                         |    1 +
 drivers/gpio/gpio-adl1000.c                   |  884 +++++
 drivers/gpu/drm/bridge/Kconfig                |   13 +
 drivers/gpu/drm/bridge/Makefile               |    1 +
 drivers/gpu/drm/bridge/adlink-lt9611.c        | 1282 +++++++
 drivers/gpu/drm/panel/panel-simple.c          |   59 +
 drivers/media/i2c/Kconfig                     |   10 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/ov13855.c                   | 2066 +++++++++++
 drivers/media/i2c/ov5640.c                    |  134 +-
 drivers/net/phy/realtek.c                     |    2 +
 drivers/tty/serial/Kconfig                    |    8 +
 drivers/tty/serial/Makefile                   |    1 +
 drivers/tty/serial/adl1001.c                  |  754 ++++
 sound/soc/codecs/tlv320aic3x.c                |   76 +-
 sound/soc/fsl/Kconfig                         |   13 +
 sound/soc/fsl/Makefile                        |    2 +
 sound/soc/fsl/imx-tlv320aic3x.c               |  249 ++
 65 files changed, 16558 insertions(+), 110 deletions(-)
 create mode 100644 arch/arm64/boot/dts/adlink/g080uan02-basic.dts
 create mode 100644 arch/arm64/boot/dts/adlink/g156hat02.6-basic.dts
 create mode 100644 arch/arm64/boot/dts/adlink/imx95-pinfunc.h
 create mode 100644 arch/arm64/boot/dts/adlink/imx95.dtsi
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-cameras-lvds.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-g080uan02.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-g156hat02.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-lt9611-noconsole.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-lt9611-pcie8997.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-lt9611-uart2.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-lt9611.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-lt96114k.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-ov13855-lvds.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-ov13855.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-ov5640.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95-uart2.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lec-imx95.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lt9611-basic.dts
 create mode 100644 arch/arm64/boot/dts/adlink/lt96114k-basic.dts
 create mode 100644 arch/arm64/boot/dts/adlink/ov13855-basic.dts
 create mode 100644 arch/arm64/boot/dts/adlink/ov5640-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/g080uan02-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/g156hat02.6-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-cameras-lvds.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-g080uan02.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-g156hat02.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-lt9611-noconsole.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-lt9611-pcie8997.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-lt9611-uart2.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-lt9611.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-lt96114k.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-ov13855-lvds.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-ov13855.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-ov5640.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95-uart2.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lec-imx95.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lt9611-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/lt96114k-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/ov13855-basic.dts
 create mode 100644 arch/arm64/boot/dts/freescale/ov5640-basic.dts
 create mode 100644 arch/arm64/configs/lec_imx95_gki.fragment
 create mode 100644 drivers/gpio/gpio-adl1000.c
 create mode 100644 drivers/gpu/drm/bridge/adlink-lt9611.c
 create mode 100644 drivers/media/i2c/ov13855.c
 create mode 100644 drivers/tty/serial/adl1001.c
 create mode 100644 sound/soc/fsl/imx-tlv320aic3x.c

diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 30dd6347a929..e4a6add673dc 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -33,3 +33,4 @@ subdir-y += tesla
 subdir-y += ti
 subdir-y += toshiba
 subdir-y += xilinx
+#subdir-y += adlink
diff --git a/arch/arm64/boot/dts/adlink/g080uan02-basic.dts b/arch/arm64/boot/dts/adlink/g080uan02-basic.dts
new file mode 100644
index 000000000000..fc2ffc1cc038
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/g080uan02-basic.dts
@@ -0,0 +1,72 @@
+
+
+
+&{/} {
+
+	lcd0_backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&tpm6 2 6666667 PWM_POLARITY_INVERTED>;
+		brightness-levels = <0 45 63 88 119 158 203 255>;
+		default-brightness-level = <6>;
+		enable-gpios = <&i2c3_adl1000 9 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <4008000000>, <445333334>;
+};
+
+&mipi_dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel@0 {
+		compatible = "auo,g080uan02";
+		reg = <0>;
+		enable-gpios = <&i2c3_adl1000 8 GPIO_ACTIVE_HIGH>; //LCD0_VDD_EN_1V8
+		dsi-lanes = <4>;
+		v3p3-supply = <&reg_3p3v>;
+		v1p8-supply = <&reg_1p8v>;
+		backlight = <&lcd0_backlight>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@1 {
+		reg = <1>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/g156hat02.6-basic.dts b/arch/arm64/boot/dts/adlink/g156hat02.6-basic.dts
new file mode 100644
index 000000000000..b55cd4ea6523
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/g156hat02.6-basic.dts
@@ -0,0 +1,101 @@
+
+
+&{/} {
+	lvds0_panel {
+		compatible = "auo,g156hat026";
+		backlight = <&lcd0_backlight>;
+		enable-gpios = <&i2c3_adl1000 8 GPIO_ACTIVE_HIGH>; //LCD0_VDD_EN_1V8
+		
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				dual-lvds-odd-pixels;
+				panel_in_odd: endpoint {
+					remote-endpoint = <&lvds0_out>;
+				};
+			};
+
+
+			port@1 {
+				reg = <1>;
+				dual-lvds-even-pixels;
+				panel_in_even: endpoint {
+					remote-endpoint = <&lvds1_out>;
+				};
+			};
+		};
+	};
+
+	lcd0_backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&tpm6 2 6666667 PWM_POLARITY_INVERTED>;
+		brightness-levels = <0 45 63 88 119 158 203 255>;
+		default-brightness-level = <6>;
+		enable-gpios = <&i2c3_adl1000 9 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&ldb {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_LDBPLL_VCO>,
+			  <&scmi_clk IMX95_CLK_LDBPLL>;
+	assigned-clock-rates = <3291120000>, <1097040000>;
+	status = "okay";
+
+	channel@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+
+			lvds0_out: endpoint {
+				remote-endpoint = <&panel_in_odd>;
+			};
+		};
+	};
+
+	channel@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <1>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+
+			lvds1_out: endpoint {
+				remote-endpoint = <&panel_in_even>;
+			};
+		};
+	};
+};
+
+&ldb0_phy {
+	status = "okay";
+};
+
+&ldb1_phy {
+	status = "okay";
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@0 {
+		reg = <0>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/imx95-pinfunc.h b/arch/arm64/boot/dts/adlink/imx95-pinfunc.h
new file mode 100644
index 000000000000..5a59bf236dcb
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/imx95-pinfunc.h
@@ -0,0 +1,865 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright 2023 NXP
+ */
+
+#ifndef __DTS_IMX95_PINFUNC_H
+#define __DTS_IMX95_PINFUNC_H
+
+/*
+ * The pin function ID is a tuple of
+ * <mux_reg conf_reg input_reg mux_mode input_val>
+ */
+#define IMX95_PAD_DAP_TDI__JTAG_MUX_TDI                               0x0000 0x0204 0x0610 0x00 0x00
+#define IMX95_PAD_DAP_TDI__NETCMIX_TOP_MQS2_LEFT                      0x0000 0x0204 0x0000 0x01 0x00
+#define IMX95_PAD_DAP_TDI__NETCMIX_TOP_NETC_TMR_1588_ALARM1           0x0000 0x0204 0x0000 0x02 0x00
+#define IMX95_PAD_DAP_TDI__CAN2_TX                                    0x0000 0x0204 0x0000 0x03 0x00
+#define IMX95_PAD_DAP_TDI__FLEXIO2_FLEXIO_BIT30                       0x0000 0x0204 0x0000 0x04 0x00
+#define IMX95_PAD_DAP_TDI__GPIO3_IO_BIT28                             0x0000 0x0204 0x0000 0x05 0x00
+#define IMX95_PAD_DAP_TDI__LPUART5_RX                                 0x0000 0x0204 0x0570 0x06 0x00
+
+#define IMX95_PAD_DAP_TMS_SWDIO__JTAG_MUX_TMS                         0x0004 0x0208 0x0614 0x00 0x00
+#define IMX95_PAD_DAP_TMS_SWDIO__CAN4_TX                              0x0004 0x0208 0x0000 0x02 0x00
+#define IMX95_PAD_DAP_TMS_SWDIO__FLEXIO2_FLEXIO_BIT31                 0x0004 0x0208 0x0000 0x04 0x00
+#define IMX95_PAD_DAP_TMS_SWDIO__GPIO3_IO_BIT29                       0x0004 0x0208 0x0000 0x05 0x00
+#define IMX95_PAD_DAP_TMS_SWDIO__LPUART5_RTS_B                        0x0004 0x0208 0x0000 0x06 0x00
+
+#define IMX95_PAD_DAP_TCLK_SWCLK__JTAG_MUX_TCK                        0x0008 0x020C 0x060C 0x00 0x00
+#define IMX95_PAD_DAP_TCLK_SWCLK__CAN4_RX                             0x0008 0x020C 0x044C 0x02 0x00
+#define IMX95_PAD_DAP_TCLK_SWCLK__FLEXIO1_FLEXIO_BIT30                0x0008 0x020C 0x0460 0x04 0x00
+#define IMX95_PAD_DAP_TCLK_SWCLK__GPIO3_IO_BIT30                      0x0008 0x020C 0x0000 0x05 0x00
+#define IMX95_PAD_DAP_TCLK_SWCLK__LPUART5_CTS_B                       0x0008 0x020C 0x056C 0x06 0x00
+
+#define IMX95_PAD_DAP_TDO_TRACESWO__JTAG_MUX_TDO                      0x000C 0x0210 0x0000 0x00 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__NETCMIX_TOP_MQS2_RIGHT            0x000C 0x0210 0x0000 0x01 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__NETCMIX_TOP_NETC_TMR_1588_ALARM   0x000C 0x0210 0x0000 0x02 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__CAN2_RX                           0x000C 0x0210 0x0444 0x03 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__FLEXIO1_FLEXIO_BIT31              0x000C 0x0210 0x0464 0x04 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__GPIO3_IO_BIT31                    0x000C 0x0210 0x0000 0x05 0x00
+#define IMX95_PAD_DAP_TDO_TRACESWO__LPUART5_TX                        0x000C 0x0210 0x0574 0x06 0x00
+
+#define IMX95_PAD_GPIO_IO00__GPIO2_IO_BIT0                            0x0010 0x0214 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO00__LPI2C3_SDA                               0x0010 0x0214 0x0504 0x11 0x00
+#define IMX95_PAD_GPIO_IO00__LPSPI6_PCS0                              0x0010 0x0214 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO00__LPUART5_TX                               0x0010 0x0214 0x0574 0x05 0x01
+#define IMX95_PAD_GPIO_IO00__LPI2C5_SDA                               0x0010 0x0214 0x0514 0x16 0x00
+#define IMX95_PAD_GPIO_IO00__FLEXIO1_FLEXIO_BIT0                      0x0010 0x0214 0x0468 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO01__GPIO2_IO_BIT1                            0x0014 0x0218 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO01__LPI2C3_SCL                               0x0014 0x0218 0x0500 0x11 0x00
+#define IMX95_PAD_GPIO_IO01__LPSPI6_SIN                               0x0014 0x0218 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO01__LPUART5_RX                               0x0014 0x0218 0x0570 0x05 0x01
+#define IMX95_PAD_GPIO_IO01__LPI2C5_SCL                               0x0014 0x0218 0x0510 0x16 0x00
+#define IMX95_PAD_GPIO_IO01__FLEXIO1_FLEXIO_BIT1                      0x0014 0x0218 0x046C 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO02__GPIO2_IO_BIT2                            0x0018 0x021C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO02__LPI2C4_SDA                               0x0018 0x021C 0x050C 0x11 0x00
+#define IMX95_PAD_GPIO_IO02__LPSPI6_SOUT                              0x0018 0x021C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO02__LPUART5_CTS_B                            0x0018 0x021C 0x056C 0x05 0x01
+#define IMX95_PAD_GPIO_IO02__LPI2C6_SDA                               0x0018 0x021C 0x051C 0x16 0x00
+#define IMX95_PAD_GPIO_IO02__FLEXIO1_FLEXIO_BIT2                      0x0018 0x021C 0x0470 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO03__GPIO2_IO_BIT3                            0x001C 0x0220 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO03__LPI2C4_SCL                               0x001C 0x0220 0x0508 0x11 0x00
+#define IMX95_PAD_GPIO_IO03__LPSPI6_SCK                               0x001C 0x0220 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO03__LPUART5_RTS_B                            0x001C 0x0220 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO03__LPI2C6_SCL                               0x001C 0x0220 0x0518 0x16 0x00
+#define IMX95_PAD_GPIO_IO03__FLEXIO1_FLEXIO_BIT3                      0x001C 0x0220 0x0474 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO04__GPIO2_IO_BIT4                            0x0020 0x0224 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO04__TPM3_CH0                                 0x0020 0x0224 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO04__AONMIX_TOP_PDM_CLK                       0x0020 0x0224 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO04__CAN4_TX                                  0x0020 0x0224 0x0000 0x03 0x00
+#define IMX95_PAD_GPIO_IO04__LPSPI7_PCS0                              0x0020 0x0224 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO04__LPUART6_TX                               0x0020 0x0224 0x0580 0x05 0x01
+#define IMX95_PAD_GPIO_IO04__LPI2C6_SDA                               0x0020 0x0224 0x051C 0x16 0x01
+#define IMX95_PAD_GPIO_IO04__FLEXIO1_FLEXIO_BIT4                      0x0020 0x0224 0x0478 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO05__GPIO2_IO_BIT5                            0x0024 0x0228 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO05__TPM4_CH0                                 0x0024 0x0228 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO05__AONMIX_TOP_PDM_BIT_STREAM_BIT0           0x0024 0x0228 0x040C 0x02 0x01
+#define IMX95_PAD_GPIO_IO05__CAN4_RX                                  0x0024 0x0228 0x044C 0x03 0x01
+#define IMX95_PAD_GPIO_IO05__LPSPI7_SIN                               0x0024 0x0228 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO05__LPUART6_RX                               0x0024 0x0228 0x057C 0x05 0x01
+#define IMX95_PAD_GPIO_IO05__LPI2C6_SCL                               0x0024 0x0228 0x0518 0x16 0x01
+#define IMX95_PAD_GPIO_IO05__FLEXIO1_FLEXIO_BIT5                      0x0024 0x0228 0x047C 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO06__GPIO2_IO_BIT6                            0x0028 0x022C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO06__TPM5_CH0                                 0x0028 0x022C 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO06__AONMIX_TOP_PDM_BIT_STREAM_BIT1           0x0028 0x022C 0x0410 0x02 0x01
+#define IMX95_PAD_GPIO_IO06__LPSPI7_SOUT                              0x0028 0x022C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO06__LPUART6_CTS_B                            0x0028 0x022C 0x0578 0x05 0x01
+#define IMX95_PAD_GPIO_IO06__LPI2C7_SDA                               0x0028 0x022C 0x0524 0x16 0x00
+#define IMX95_PAD_GPIO_IO06__FLEXIO1_FLEXIO_BIT6                      0x0028 0x022C 0x0480 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO07__GPIO2_IO_BIT7                            0x002C 0x0230 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO07__LPSPI3_PCS1                              0x002C 0x0230 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO07__LPSPI7_SCK                               0x002C 0x0230 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO07__LPUART6_RTS_B                            0x002C 0x0230 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO07__LPI2C7_SCL                               0x002C 0x0230 0x0520 0x16 0x00
+#define IMX95_PAD_GPIO_IO07__FLEXIO1_FLEXIO_BIT7                      0x002C 0x0230 0x0484 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO08__GPIO2_IO_BIT8                            0x0030 0x0234 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO08__LPSPI3_PCS0                              0x0030 0x0234 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO08__TPM6_CH0                                 0x0030 0x0234 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO08__LPUART7_TX                               0x0030 0x0234 0x0588 0x05 0x01
+#define IMX95_PAD_GPIO_IO08__LPI2C7_SDA                               0x0030 0x0234 0x0524 0x16 0x01
+#define IMX95_PAD_GPIO_IO08__FLEXIO1_FLEXIO_BIT8                      0x0030 0x0234 0x0488 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO09__GPIO2_IO_BIT9                            0x0034 0x0238 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO09__LPSPI3_SIN                               0x0034 0x0238 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO09__TPM3_EXTCLK                              0x0034 0x0238 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO09__LPUART7_RX                               0x0034 0x0238 0x0584 0x05 0x01
+#define IMX95_PAD_GPIO_IO09__LPI2C7_SCL                               0x0034 0x0238 0x0520 0x16 0x01
+#define IMX95_PAD_GPIO_IO09__FLEXIO1_FLEXIO_BIT9                      0x0034 0x0238 0x048C 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO10__GPIO2_IO_BIT10                           0x0038 0x023C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO10__LPSPI3_SOUT                              0x0038 0x023C 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO10__TPM4_EXTCLK                              0x0038 0x023C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO10__LPUART7_CTS_B                            0x0038 0x023C 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO10__LPI2C8_SDA                               0x0038 0x023C 0x052C 0x16 0x00
+#define IMX95_PAD_GPIO_IO10__FLEXIO1_FLEXIO_BIT10                     0x0038 0x023C 0x0490 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO11__GPIO2_IO_BIT11                           0x003C 0x0240 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO11__LPSPI3_SCK                               0x003C 0x0240 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO11__TPM5_EXTCLK                              0x003C 0x0240 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO11__LPUART7_RTS_B                            0x003C 0x0240 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO11__LPI2C8_SCL                               0x003C 0x0240 0x0528 0x16 0x00
+#define IMX95_PAD_GPIO_IO11__FLEXIO1_FLEXIO_BIT11                     0x003C 0x0240 0x0494 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO12__GPIO2_IO_BIT12                           0x0040 0x0244 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO12__TPM3_CH2                                 0x0040 0x0244 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO12__AONMIX_TOP_PDM_BIT_STREAM_BIT2           0x0040 0x0244 0x0414 0x02 0x00
+#define IMX95_PAD_GPIO_IO12__FLEXIO1_FLEXIO_BIT12                     0x0040 0x0244 0x0498 0x03 0x00
+#define IMX95_PAD_GPIO_IO12__LPSPI8_PCS0                              0x0040 0x0244 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO12__LPUART8_TX                               0x0040 0x0244 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO12__LPI2C8_SDA                               0x0040 0x0244 0x052C 0x16 0x01
+#define IMX95_PAD_GPIO_IO12__SAI3_RX_SYNC                             0x0040 0x0244 0x0590 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO13__GPIO2_IO_BIT13                           0x0044 0x0248 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO13__TPM4_CH2                                 0x0044 0x0248 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO13__AONMIX_TOP_PDM_BIT_STREAM_BIT3           0x0044 0x0248 0x0418 0x02 0x00
+#define IMX95_PAD_GPIO_IO13__LPSPI8_SIN                               0x0044 0x0248 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO13__LPUART8_RX                               0x0044 0x0248 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO13__LPI2C8_SCL                               0x0044 0x0248 0x0528 0x16 0x01
+#define IMX95_PAD_GPIO_IO13__FLEXIO1_FLEXIO_BIT13                     0x0044 0x0248 0x049C 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO14__GPIO2_IO_BIT14                           0x0048 0x024C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO14__LPUART3_TX                               0x0048 0x024C 0x055C 0x01 0x01
+#define IMX95_PAD_GPIO_IO14__LPSPI8_SOUT                              0x0048 0x024C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO14__LPUART8_CTS_B                            0x0048 0x024C 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO14__LPUART4_TX                               0x0048 0x024C 0x0568 0x06 0x01
+#define IMX95_PAD_GPIO_IO14__FLEXIO1_FLEXIO_BIT14                     0x0048 0x024C 0x04A0 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO15__GPIO2_IO_BIT15                           0x004C 0x0250 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO15__LPUART3_RX                               0x004C 0x0250 0x0558 0x01 0x01
+#define IMX95_PAD_GPIO_IO15__LPSPI8_SCK                               0x004C 0x0250 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO15__LPUART8_RTS_B                            0x004C 0x0250 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO15__LPUART4_RX                               0x004C 0x0250 0x0564 0x06 0x01
+#define IMX95_PAD_GPIO_IO15__FLEXIO1_FLEXIO_BIT15                     0x004C 0x0250 0x04A4 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO16__GPIO2_IO_BIT16                           0x0050 0x0254 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO16__SAI3_TX_BCLK                             0x0050 0x0254 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO16__AONMIX_TOP_PDM_BIT_STREAM_BIT2           0x0050 0x0254 0x0414 0x02 0x01
+#define IMX95_PAD_GPIO_IO16__LPUART3_CTS_B                            0x0050 0x0254 0x0554 0x04 0x01
+#define IMX95_PAD_GPIO_IO16__LPSPI4_PCS2                              0x0050 0x0254 0x0538 0x05 0x01
+#define IMX95_PAD_GPIO_IO16__LPUART4_CTS_B                            0x0050 0x0254 0x0560 0x06 0x01
+#define IMX95_PAD_GPIO_IO16__FLEXIO1_FLEXIO_BIT16                     0x0050 0x0254 0x04A8 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO17__GPIO2_IO_BIT17                           0x0054 0x0258 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO17__SAI3_MCLK                                0x0054 0x0258 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO17__LPUART3_RTS_B                            0x0054 0x0258 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO17__LPSPI4_PCS1                              0x0054 0x0258 0x0534 0x05 0x01
+#define IMX95_PAD_GPIO_IO17__LPUART4_RTS_B                            0x0054 0x0258 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO17__FLEXIO1_FLEXIO_BIT17                     0x0054 0x0258 0x04AC 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO18__GPIO2_IO_BIT18                           0x0058 0x025C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO18__SAI3_RX_BCLK                             0x0058 0x025C 0x058C 0x01 0x00
+#define IMX95_PAD_GPIO_IO18__LPSPI5_PCS0                              0x0058 0x025C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO18__LPSPI4_PCS0                              0x0058 0x025C 0x0530 0x05 0x01
+#define IMX95_PAD_GPIO_IO18__TPM5_CH2                                 0x0058 0x025C 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO18__FLEXIO1_FLEXIO_BIT18                     0x0058 0x025C 0x04B0 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO19__GPIO2_IO_BIT19                           0x005C 0x0260 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO19__SAI3_RX_SYNC                             0x005C 0x0260 0x0590 0x01 0x01
+#define IMX95_PAD_GPIO_IO19__AONMIX_TOP_PDM_BIT_STREAM_BIT3           0x005C 0x0260 0x0418 0x02 0x01
+#define IMX95_PAD_GPIO_IO19__FLEXIO1_FLEXIO_BIT19                     0x005C 0x0260 0x04B4 0x03 0x00
+#define IMX95_PAD_GPIO_IO19__LPSPI5_SIN                               0x005C 0x0260 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO19__LPSPI4_SIN                               0x005C 0x0260 0x0540 0x05 0x01
+#define IMX95_PAD_GPIO_IO19__TPM6_CH2                                 0x005C 0x0260 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO19__SAI3_TX_DATA_BIT0                        0x005C 0x0260 0x0000 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO20__GPIO2_IO_BIT20                           0x0060 0x0264 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO20__SAI3_RX_DATA_BIT0                        0x0060 0x0264 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO20__AONMIX_TOP_PDM_BIT_STREAM_BIT0           0x0060 0x0264 0x040C 0x02 0x02
+#define IMX95_PAD_GPIO_IO20__LPSPI5_SOUT                              0x0060 0x0264 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO20__LPSPI4_SOUT                              0x0060 0x0264 0x0544 0x05 0x01
+#define IMX95_PAD_GPIO_IO20__TPM3_CH1                                 0x0060 0x0264 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO20__FLEXIO1_FLEXIO_BIT20                     0x0060 0x0264 0x04B8 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO21__GPIO2_IO_BIT21                           0x0064 0x0268 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO21__SAI3_TX_DATA_BIT0                        0x0064 0x0268 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO21__AONMIX_TOP_PDM_CLK                       0x0064 0x0268 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO21__FLEXIO1_FLEXIO_BIT21                     0x0064 0x0268 0x04BC 0x03 0x00
+#define IMX95_PAD_GPIO_IO21__LPSPI5_SCK                               0x0064 0x0268 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO21__LPSPI4_SCK                               0x0064 0x0268 0x053C 0x05 0x01
+#define IMX95_PAD_GPIO_IO21__TPM4_CH1                                 0x0064 0x0268 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO21__SAI3_RX_BCLK                             0x0064 0x0268 0x058C 0x07 0x01
+
+#define IMX95_PAD_GPIO_IO22__GPIO2_IO_BIT22                           0x0068 0x026C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO22__USDHC3_CLK                               0x0068 0x026C 0x05C8 0x01 0x00
+#define IMX95_PAD_GPIO_IO22__SPDIF_IN                                 0x0068 0x026C 0x0454 0x02 0x02
+#define IMX95_PAD_GPIO_IO22__CAN5_TX                                  0x0068 0x026C 0x0000 0x03 0x00
+#define IMX95_PAD_GPIO_IO22__TPM5_CH1                                 0x0068 0x026C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO22__TPM6_EXTCLK                              0x0068 0x026C 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO22__LPI2C5_SDA                               0x0068 0x026C 0x0514 0x16 0x01
+#define IMX95_PAD_GPIO_IO22__FLEXIO1_FLEXIO_BIT22                     0x0068 0x026C 0x04C0 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO23__GPIO2_IO_BIT23                           0x006C 0x0270 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO23__USDHC3_CMD                               0x006C 0x0270 0x05CC 0x01 0x00
+#define IMX95_PAD_GPIO_IO23__SPDIF_OUT                                0x006C 0x0270 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO23__CAN5_RX                                  0x006C 0x0270 0x0450 0x03 0x00
+#define IMX95_PAD_GPIO_IO23__TPM6_CH1                                 0x006C 0x0270 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO23__LPI2C5_SCL                               0x006C 0x0270 0x0510 0x16 0x01
+#define IMX95_PAD_GPIO_IO23__FLEXIO1_FLEXIO_BIT23                     0x006C 0x0270 0x04C4 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO24__GPIO2_IO_BIT24                           0x0070 0x0274 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO24__USDHC3_DATA0                             0x0070 0x0274 0x05D0 0x01 0x00
+#define IMX95_PAD_GPIO_IO24__TPM3_CH3                                 0x0070 0x0274 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO24__JTAG_MUX_TDO                             0x0070 0x0274 0x0000 0x05 0x00
+#define IMX95_PAD_GPIO_IO24__LPSPI6_PCS1                              0x0070 0x0274 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO24__FLEXIO1_FLEXIO_BIT24                     0x0070 0x0274 0x04C8 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO25__GPIO2_IO_BIT25                           0x0074 0x0278 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO25__USDHC3_DATA1                             0x0074 0x0278 0x05D4 0x01 0x00
+#define IMX95_PAD_GPIO_IO25__CAN2_TX                                  0x0074 0x0278 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO25__TPM4_CH3                                 0x0074 0x0278 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO25__JTAG_MUX_TCK                             0x0074 0x0278 0x060C 0x05 0x01
+#define IMX95_PAD_GPIO_IO25__LPSPI7_PCS1                              0x0074 0x0278 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO25__FLEXIO1_FLEXIO_BIT25                     0x0074 0x0278 0x04CC 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO26__GPIO2_IO_BIT26                           0x0078 0x027C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO26__USDHC3_DATA2                             0x0078 0x027C 0x05D8 0x01 0x00
+#define IMX95_PAD_GPIO_IO26__AONMIX_TOP_PDM_BIT_STREAM_BIT1           0x0078 0x027C 0x0410 0x02 0x02
+#define IMX95_PAD_GPIO_IO26__FLEXIO1_FLEXIO_BIT26                     0x0078 0x027C 0x0458 0x03 0x01
+#define IMX95_PAD_GPIO_IO26__TPM5_CH3                                 0x0078 0x027C 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO26__JTAG_MUX_TDI                             0x0078 0x027C 0x0610 0x05 0x01
+#define IMX95_PAD_GPIO_IO26__LPSPI8_PCS1                              0x0078 0x027C 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO26__SAI3_TX_SYNC                             0x0078 0x027C 0x0000 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO27__GPIO2_IO_BIT27                           0x007C 0x0280 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO27__USDHC3_DATA3                             0x007C 0x0280 0x05DC 0x01 0x00
+#define IMX95_PAD_GPIO_IO27__CAN2_RX                                  0x007C 0x0280 0x0444 0x02 0x02
+#define IMX95_PAD_GPIO_IO27__TPM6_CH3                                 0x007C 0x0280 0x0000 0x04 0x00
+#define IMX95_PAD_GPIO_IO27__JTAG_MUX_TMS                             0x007C 0x0280 0x0614 0x05 0x01
+#define IMX95_PAD_GPIO_IO27__LPSPI5_PCS1                              0x007C 0x0280 0x0000 0x06 0x00
+#define IMX95_PAD_GPIO_IO27__FLEXIO1_FLEXIO_BIT27                     0x007C 0x0280 0x045C 0x07 0x01
+
+#define IMX95_PAD_GPIO_IO28__GPIO2_IO_BIT28                           0x0080 0x0284 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO28__LPI2C3_SDA                               0x0080 0x0284 0x0504 0x11 0x01
+#define IMX95_PAD_GPIO_IO28__CAN3_TX                                  0x0080 0x0284 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO28__FLEXIO1_FLEXIO_BIT28                     0x0080 0x0284 0x0000 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO29__GPIO2_IO_BIT29                           0x0084 0x0288 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO29__LPI2C3_SCL                               0x0084 0x0288 0x0500 0x11 0x01
+#define IMX95_PAD_GPIO_IO29__CAN3_RX                                  0x0084 0x0288 0x0448 0x02 0x01
+#define IMX95_PAD_GPIO_IO29__FLEXIO1_FLEXIO_BIT29                     0x0084 0x0288 0x0000 0x07 0x00
+
+#define IMX95_PAD_GPIO_IO30__GPIO2_IO_BIT30                           0x0088 0x028C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO30__LPI2C4_SDA                               0x0088 0x028C 0x050C 0x11 0x01
+#define IMX95_PAD_GPIO_IO30__CAN5_TX                                  0x0088 0x028C 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO30__FLEXIO1_FLEXIO_BIT30                     0x0088 0x028C 0x0460 0x07 0x01
+
+#define IMX95_PAD_GPIO_IO31__GPIO2_IO_BIT31                           0x008C 0x0290 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO31__LPI2C4_SCL                               0x008C 0x0290 0x0508 0x11 0x01
+#define IMX95_PAD_GPIO_IO31__CAN5_RX                                  0x008C 0x0290 0x0450 0x02 0x01
+#define IMX95_PAD_GPIO_IO31__FLEXIO1_FLEXIO_BIT31                     0x008C 0x0290 0x0464 0x07 0x01
+
+#define IMX95_PAD_GPIO_IO32__GPIO5_IO_BIT12                           0x0090 0x0294 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO32__HSIOMIX_TOP_PCIE1_CLKREQ_B               0x0090 0x0294 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO32__LPUART6_TX                               0x0090 0x0294 0x0580 0x02 0x00
+#define IMX95_PAD_GPIO_IO32__LPSPI4_PCS2                              0x0090 0x0294 0x0538 0x04 0x00
+
+#define IMX95_PAD_GPIO_IO33__GPIO5_IO_BIT13                           0x0094 0x0298 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO33__LPUART6_RX                               0x0094 0x0298 0x057C 0x02 0x00
+#define IMX95_PAD_GPIO_IO33__LPSPI4_PCS1                              0x0094 0x0298 0x0534 0x04 0x00
+
+#define IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14                           0x0098 0x029C 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO34__LPUART6_CTS_B                            0x0098 0x029C 0x0578 0x02 0x00
+#define IMX95_PAD_GPIO_IO34__LPSPI4_PCS0                              0x0098 0x029C 0x0530 0x04 0x00
+
+#define IMX95_PAD_GPIO_IO35__GPIO5_IO_BIT15                           0x009C 0x02A0 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO35__HSIOMIX_TOP_PCIE2_CLKREQ_B               0x009C 0x02A0 0x0000 0x01 0x00
+#define IMX95_PAD_GPIO_IO35__LPUART6_RTS_B                            0x009C 0x02A0 0x0000 0x02 0x00
+#define IMX95_PAD_GPIO_IO35__LPSPI4_SIN                               0x009C 0x02A0 0x0540 0x04 0x00
+
+#define IMX95_PAD_GPIO_IO36__LPSPI4_SOUT                              0x00A0 0x02A4 0x0544 0x04 0x00
+#define IMX95_PAD_GPIO_IO36__GPIO5_IO_BIT16                           0x00A0 0x02A4 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO36__LPUART7_TX                               0x00A0 0x02A4 0x0588 0x02 0x00
+
+#define IMX95_PAD_GPIO_IO37__GPIO5_IO_BIT17                           0x00A4 0x02A8 0x0000 0x00 0x00
+#define IMX95_PAD_GPIO_IO37__LPUART7_RX                               0x00A4 0x02A8 0x0584 0x02 0x00
+#define IMX95_PAD_GPIO_IO37__LPSPI4_SCK                               0x00A4 0x02A8 0x053C 0x04 0x00
+
+#define IMX95_PAD_CCM_CLKO1__CCMSRCGPCMIX_TOP_CLKO_1                  0x00A8 0x02AC 0x0000 0x00 0x00
+#define IMX95_PAD_CCM_CLKO1__NETCMIX_TOP_NETC_TMR_1588_TRIG1          0x00A8 0x02AC 0x0434 0x01 0x00
+#define IMX95_PAD_CCM_CLKO1__FLEXIO1_FLEXIO_BIT26                     0x00A8 0x02AC 0x0458 0x04 0x00
+#define IMX95_PAD_CCM_CLKO1__GPIO3_IO_BIT26                           0x00A8 0x02AC 0x0000 0x05 0x00
+
+#define IMX95_PAD_CCM_CLKO2__GPIO3_IO_BIT27                           0x00AC 0x02B0 0x0000 0x05 0x00
+#define IMX95_PAD_CCM_CLKO2__CCMSRCGPCMIX_TOP_CLKO_2                  0x00AC 0x02B0 0x0000 0x00 0x00
+#define IMX95_PAD_CCM_CLKO2__NETCMIX_TOP_NETC_TMR_1588_PP1            0x00AC 0x02B0 0x0000 0x01 0x00
+#define IMX95_PAD_CCM_CLKO2__FLEXIO1_FLEXIO_BIT27                     0x00AC 0x02B0 0x045C 0x04 0x00
+
+#define IMX95_PAD_CCM_CLKO3__CCMSRCGPCMIX_TOP_CLKO_3                  0x00B0 0x02B4 0x0000 0x00 0x00
+#define IMX95_PAD_CCM_CLKO3__NETCMIX_TOP_NETC_TMR_1588_TRIG2          0x00B0 0x02B4 0x0438 0x01 0x00
+#define IMX95_PAD_CCM_CLKO3__CAN3_TX                                  0x00B0 0x02B4 0x0000 0x02 0x00
+#define IMX95_PAD_CCM_CLKO3__FLEXIO2_FLEXIO_BIT28                     0x00B0 0x02B4 0x0000 0x04 0x00
+#define IMX95_PAD_CCM_CLKO3__GPIO4_IO_BIT28                           0x00B0 0x02B4 0x0000 0x05 0x00
+
+#define IMX95_PAD_CCM_CLKO4__CCMSRCGPCMIX_TOP_CLKO_4                  0x00B4 0x02B8 0x0000 0x00 0x00
+#define IMX95_PAD_CCM_CLKO4__NETCMIX_TOP_NETC_TMR_1588_PP2            0x00B4 0x02B8 0x0000 0x01 0x00
+#define IMX95_PAD_CCM_CLKO4__CAN3_RX                                  0x00B4 0x02B8 0x0448 0x02 0x00
+#define IMX95_PAD_CCM_CLKO4__FLEXIO2_FLEXIO_BIT29                     0x00B4 0x02B8 0x0000 0x04 0x00
+#define IMX95_PAD_CCM_CLKO4__GPIO4_IO_BIT29                           0x00B4 0x02B8 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_MDC__NETCMIX_TOP_NETC_MDC                     0x00B8 0x02BC 0x0424 0x00 0x00
+#define IMX95_PAD_ENET1_MDC__LPUART3_DCD_B                            0x00B8 0x02BC 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_MDC__I3C2_SCL                                 0x00B8 0x02BC 0x04F8 0x02 0x00
+#define IMX95_PAD_ENET1_MDC__HSIOMIX_TOP_USB1_OTG_ID                  0x00B8 0x02BC 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_MDC__FLEXIO2_FLEXIO_BIT0                      0x00B8 0x02BC 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_MDC__GPIO4_IO_BIT0                            0x00B8 0x02BC 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_MDIO__NETCMIX_TOP_NETC_MDIO                   0x00BC 0x02C0 0x0428 0x00 0x00
+#define IMX95_PAD_ENET1_MDIO__LPUART3_RIN_B                           0x00BC 0x02C0 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_MDIO__I3C2_SDA                                0x00BC 0x02C0 0x04FC 0x02 0x00
+#define IMX95_PAD_ENET1_MDIO__HSIOMIX_TOP_USB1_OTG_PWR                0x00BC 0x02C0 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_MDIO__FLEXIO2_FLEXIO_BIT1                     0x00BC 0x02C0 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_MDIO__GPIO4_IO_BIT1                           0x00BC 0x02C0 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_TD3__NETCMIX_TOP_ETH0_RGMII_TD3               0x00C0 0x02C4 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TD3__CAN2_TX                                  0x00C0 0x02C4 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_TD3__HSIOMIX_TOP_USB2_OTG_ID                  0x00C0 0x02C4 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_TD3__FLEXIO2_FLEXIO_BIT2                      0x00C0 0x02C4 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TD3__GPIO4_IO_BIT2                            0x00C0 0x02C4 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RGMII_TD2               0x00C4 0x02C8 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RMII_REF50_CLK          0x00C4 0x02C8 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_TD2__CAN2_RX                                  0x00C4 0x02C8 0x0444 0x02 0x01
+#define IMX95_PAD_ENET1_TD2__HSIOMIX_TOP_USB2_OTG_OC                  0x00C4 0x02C8 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_TD2__FLEXIO2_FLEXIO_BIT3                      0x00C4 0x02C8 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TD2__GPIO4_IO_BIT3                            0x00C4 0x02C8 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RGMII_TD1               0x00C8 0x02CC 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TD1__LPUART3_RTS_B                            0x00C8 0x02CC 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_TD1__I3C2_PUR                                 0x00C8 0x02CC 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_TD1__HSIOMIX_TOP_USB1_OTG_OC                  0x00C8 0x02CC 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_TD1__FLEXIO2_FLEXIO_BIT4                      0x00C8 0x02CC 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TD1__GPIO4_IO_BIT4                            0x00C8 0x02CC 0x0000 0x05 0x00
+#define IMX95_PAD_ENET1_TD1__I3C2_PUR_B                               0x00C8 0x02CC 0x0000 0x06 0x00
+#define IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RMII_TXD1               0x00C8 0x02CC 0x0000 0x07 0x00
+
+#define IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RGMII_TD0               0x00CC 0x02D0 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TD0__LPUART3_TX                               0x00CC 0x02D0 0x055C 0x01 0x00
+#define IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RMII_TXD0               0x00CC 0x02D0 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_TD0__FLEXIO2_FLEXIO_BIT5                      0x00CC 0x02D0 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TD0__GPIO4_IO_BIT5                            0x00CC 0x02D0 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RGMII_TX_CTL         0x00D0 0x02D4 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TX_CTL__LPUART3_DTR_B                         0x00D0 0x02D4 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RMII_TX_EN           0x00D0 0x02D4 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_TX_CTL__FLEXIO2_FLEXIO_BIT6                   0x00D0 0x02D4 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TX_CTL__GPIO4_IO_BIT6                         0x00D0 0x02D4 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_TXC__NETCMIX_TOP_ETH0_RGMII_TX_CLK            0x00D4 0x02D8 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_TXC__CCMSRCGPCMIX_TOP_ENET_CLK_ROOT           0x00D4 0x02D8 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_TXC__FLEXIO2_FLEXIO_BIT7                      0x00D4 0x02D8 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_TXC__GPIO4_IO_BIT7                            0x00D4 0x02D8 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RGMII_RX_CTL         0x00D8 0x02DC 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RX_CTL__LPUART3_DSR_B                         0x00D8 0x02DC 0x0000 0x01 0x00
+#define IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RMII_CRS_DV          0x00D8 0x02DC 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_RX_CTL__HSIOMIX_TOP_USB2_OTG_PWR              0x00D8 0x02DC 0x0000 0x03 0x00
+#define IMX95_PAD_ENET1_RX_CTL__FLEXIO2_FLEXIO_BIT8                   0x00D8 0x02DC 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RX_CTL__GPIO4_IO_BIT8                         0x00D8 0x02DC 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RGMII_RX_CLK            0x00DC 0x02E0 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RMII_RX_ER              0x00DC 0x02E0 0x042C 0x01 0x00
+#define IMX95_PAD_ENET1_RXC__FLEXIO2_FLEXIO_BIT9                      0x00DC 0x02E0 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RXC__GPIO4_IO_BIT9                            0x00DC 0x02E0 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RGMII_RD0               0x00E0 0x02E4 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RD0__LPUART3_RX                               0x00E0 0x02E4 0x0558 0x01 0x00
+#define IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RMII_RXD0               0x00E0 0x02E4 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_RD0__FLEXIO2_FLEXIO_BIT10                     0x00E0 0x02E4 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RD0__GPIO4_IO_BIT10                           0x00E0 0x02E4 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RGMII_RD1               0x00E4 0x02E8 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RD1__LPUART3_CTS_B                            0x00E4 0x02E8 0x0554 0x01 0x00
+#define IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RMII_RXD1               0x00E4 0x02E8 0x0000 0x02 0x00
+#define IMX95_PAD_ENET1_RD1__LPTMR2_ALT1                              0x00E4 0x02E8 0x0548 0x03 0x00
+#define IMX95_PAD_ENET1_RD1__FLEXIO2_FLEXIO_BIT11                     0x00E4 0x02E8 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RD1__GPIO4_IO_BIT11                           0x00E4 0x02E8 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RGMII_RD2               0x00E8 0x02EC 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RMII_RX_ER              0x00E8 0x02EC 0x042C 0x02 0x01
+#define IMX95_PAD_ENET1_RD2__LPTMR2_ALT2                              0x00E8 0x02EC 0x054C 0x03 0x00
+#define IMX95_PAD_ENET1_RD2__FLEXIO2_FLEXIO_BIT12                     0x00E8 0x02EC 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RD2__GPIO4_IO_BIT12                           0x00E8 0x02EC 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET1_RD3__NETCMIX_TOP_ETH0_RGMII_RD3               0x00EC 0x02F0 0x0000 0x00 0x00
+#define IMX95_PAD_ENET1_RD3__LPTMR2_ALT3                              0x00EC 0x02F0 0x0550 0x03 0x00
+#define IMX95_PAD_ENET1_RD3__FLEXIO2_FLEXIO_BIT13                     0x00EC 0x02F0 0x0000 0x04 0x00
+#define IMX95_PAD_ENET1_RD3__GPIO4_IO_BIT13                           0x00EC 0x02F0 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_MDC__NETCMIX_TOP_NETC_MDC                     0x00F0 0x02F4 0x0424 0x00 0x01
+#define IMX95_PAD_ENET2_MDC__LPUART4_DCD_B                            0x00F0 0x02F4 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_MDC__NETCMIX_TOP_SAI2_RX_SYNC                 0x00F0 0x02F4 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_MDC__FLEXIO2_FLEXIO_BIT14                     0x00F0 0x02F4 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_MDC__GPIO4_IO_BIT14                           0x00F0 0x02F4 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_MDIO__NETCMIX_TOP_NETC_MDIO                   0x00F4 0x02F8 0x0428 0x00 0x01
+#define IMX95_PAD_ENET2_MDIO__LPUART4_RIN_B                           0x00F4 0x02F8 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_MDIO__NETCMIX_TOP_SAI2_RX_BCLK                0x00F4 0x02F8 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_MDIO__FLEXIO2_FLEXIO_BIT15                    0x00F4 0x02F8 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15                          0x00F4 0x02F8 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_TD3__NETCMIX_TOP_SAI2_RX_DATA_BIT0            0x00F8 0x02FC 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TD3__FLEXIO2_FLEXIO_BIT16                     0x00F8 0x02FC 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TD3__GPIO4_IO_BIT16                           0x00F8 0x02FC 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_TD3__NETCMIX_TOP_ETH1_RGMII_TD3               0x00F8 0x02FC 0x0000 0x00 0x00
+
+#define IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RGMII_TD2               0x00FC 0x0300 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RMII_REF50_CLK          0x00FC 0x0300 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_TD2__NETCMIX_TOP_SAI2_RX_DATA_BIT1            0x00FC 0x0300 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TD2__SAI4_TX_SYNC                             0x00FC 0x0300 0x05A4 0x03 0x00
+#define IMX95_PAD_ENET2_TD2__FLEXIO2_FLEXIO_BIT17                     0x00FC 0x0300 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TD2__GPIO4_IO_BIT17                           0x00FC 0x0300 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RGMII_TD1               0x0100 0x0304 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_TD1__LPUART4_RTS_B                            0x0100 0x0304 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_TD1__NETCMIX_TOP_SAI2_RX_DATA_BIT2            0x0100 0x0304 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TD1__SAI4_TX_BCLK                             0x0100 0x0304 0x05A0 0x03 0x00
+#define IMX95_PAD_ENET2_TD1__FLEXIO2_FLEXIO_BIT18                     0x0100 0x0304 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TD1__GPIO4_IO_BIT18                           0x0100 0x0304 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RMII_TXD1               0x0100 0x0304 0x0000 0x06 0x00
+
+#define IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RGMII_TD0               0x0104 0x0308 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_TD0__LPUART4_TX                               0x0104 0x0308 0x0568 0x01 0x00
+#define IMX95_PAD_ENET2_TD0__NETCMIX_TOP_SAI2_RX_DATA_BIT3            0x0104 0x0308 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TD0__SAI4_TX_DATA_BIT0                        0x0104 0x0308 0x0000 0x03 0x00
+#define IMX95_PAD_ENET2_TD0__FLEXIO2_FLEXIO_BIT19                     0x0104 0x0308 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TD0__GPIO4_IO_BIT19                           0x0104 0x0308 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RMII_TXD0               0x0104 0x0308 0x0000 0x06 0x00
+
+#define IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RGMII_TX_CTL         0x0108 0x030C 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_TX_CTL__LPUART4_DTR_B                         0x0108 0x030C 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_SAI2_TX_SYNC              0x0108 0x030C 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RMII_TX_EN           0x0108 0x030C 0x0000 0x03 0x00
+#define IMX95_PAD_ENET2_TX_CTL__FLEXIO2_FLEXIO_BIT20                  0x0108 0x030C 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TX_CTL__GPIO4_IO_BIT20                        0x0108 0x030C 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_TXC__NETCMIX_TOP_ETH1_RGMII_TX_CLK            0x010C 0x0310 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_TXC__CCMSRCGPCMIX_TOP_ENET_CLK_ROOT           0x010C 0x0310 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_TXC__NETCMIX_TOP_SAI2_TX_BCLK                 0x010C 0x0310 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_TXC__FLEXIO2_FLEXIO_BIT21                     0x010C 0x0310 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_TXC__GPIO4_IO_BIT21                           0x010C 0x0310 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RGMII_RX_CTL         0x0110 0x0314 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RX_CTL__LPUART4_DSR_B                         0x0110 0x0314 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_SAI2_TX_DATA_BIT0         0x0110 0x0314 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_RX_CTL__FLEXIO2_FLEXIO_BIT22                  0x0110 0x0314 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RX_CTL__GPIO4_IO_BIT22                        0x0110 0x0314 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RMII_CRS_DV          0x0110 0x0314 0x0000 0x06 0x00
+
+#define IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RGMII_RX_CLK            0x0114 0x0318 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RMII_RX_ER              0x0114 0x0318 0x0430 0x01 0x00
+#define IMX95_PAD_ENET2_RXC__NETCMIX_TOP_SAI2_TX_DATA_BIT1            0x0114 0x0318 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_RXC__SAI4_RX_SYNC                             0x0114 0x0318 0x059C 0x03 0x00
+#define IMX95_PAD_ENET2_RXC__FLEXIO2_FLEXIO_BIT23                     0x0114 0x0318 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RXC__GPIO4_IO_BIT23                           0x0114 0x0318 0x0000 0x05 0x00
+
+#define IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RGMII_RD0               0x0118 0x031C 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RD0__LPUART4_RX                               0x0118 0x031C 0x0564 0x01 0x00
+#define IMX95_PAD_ENET2_RD0__NETCMIX_TOP_SAI2_TX_DATA_BIT2            0x0118 0x031C 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_RD0__SAI4_RX_BCLK                             0x0118 0x031C 0x0594 0x03 0x00
+#define IMX95_PAD_ENET2_RD0__FLEXIO2_FLEXIO_BIT24                     0x0118 0x031C 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RD0__GPIO4_IO_BIT24                           0x0118 0x031C 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RMII_RXD0               0x0118 0x031C 0x0000 0x06 0x00
+
+#define IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RGMII_RD1               0x011C 0x0320 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RD1__SPDIF_IN                                 0x011C 0x0320 0x0454 0x01 0x00
+#define IMX95_PAD_ENET2_RD1__NETCMIX_TOP_SAI2_TX_DATA_BIT3            0x011C 0x0320 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_RD1__SAI4_RX_DATA_BIT0                        0x011C 0x0320 0x0598 0x03 0x00
+#define IMX95_PAD_ENET2_RD1__FLEXIO2_FLEXIO_BIT25                     0x011C 0x0320 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RD1__GPIO4_IO_BIT25                           0x011C 0x0320 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RMII_RXD1               0x011C 0x0320 0x0000 0x06 0x00
+
+#define IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RGMII_RD2               0x0120 0x0324 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RD2__LPUART4_CTS_B                            0x0120 0x0324 0x0560 0x01 0x00
+#define IMX95_PAD_ENET2_RD2__NETCMIX_TOP_SAI2_MCLK                    0x0120 0x0324 0x0000 0x02 0x00
+#define IMX95_PAD_ENET2_RD2__NETCMIX_TOP_MQS2_RIGHT                   0x0120 0x0324 0x0000 0x03 0x00
+#define IMX95_PAD_ENET2_RD2__FLEXIO2_FLEXIO_BIT26                     0x0120 0x0324 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RD2__GPIO4_IO_BIT26                           0x0120 0x0324 0x0000 0x05 0x00
+#define IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RMII_RX_ER              0x0120 0x0324 0x0430 0x06 0x01
+
+#define IMX95_PAD_ENET2_RD3__NETCMIX_TOP_ETH1_RGMII_RD3               0x0124 0x0328 0x0000 0x00 0x00
+#define IMX95_PAD_ENET2_RD3__SPDIF_OUT                                0x0124 0x0328 0x0000 0x01 0x00
+#define IMX95_PAD_ENET2_RD3__SPDIF_IN                                 0x0124 0x0328 0x0454 0x02 0x01
+#define IMX95_PAD_ENET2_RD3__NETCMIX_TOP_MQS2_LEFT                    0x0124 0x0328 0x0000 0x03 0x00
+#define IMX95_PAD_ENET2_RD3__FLEXIO2_FLEXIO_BIT27                     0x0124 0x0328 0x0000 0x04 0x00
+#define IMX95_PAD_ENET2_RD3__GPIO4_IO_BIT27                           0x0124 0x0328 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD1_CLK__FLEXIO1_FLEXIO_BIT8                        0x0128 0x032C 0x0488 0x04 0x01
+#define IMX95_PAD_SD1_CLK__GPIO3_IO_BIT8                              0x0128 0x032C 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_CLK__USDHC1_CLK                                 0x0128 0x032C 0x0000 0x00 0x00
+
+#define IMX95_PAD_SD1_CMD__USDHC1_CMD                                 0x012C 0x0330 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_CMD__FLEXIO1_FLEXIO_BIT9                        0x012C 0x0330 0x048C 0x04 0x01
+#define IMX95_PAD_SD1_CMD__GPIO3_IO_BIT9                              0x012C 0x0330 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD1_DATA0__USDHC1_DATA0                             0x0130 0x0334 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA0__FLEXIO1_FLEXIO_BIT10                     0x0130 0x0334 0x0490 0x04 0x01
+#define IMX95_PAD_SD1_DATA0__GPIO3_IO_BIT10                           0x0130 0x0334 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD1_DATA1__USDHC1_DATA1                             0x0134 0x0338 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA1__FLEXIO1_FLEXIO_BIT11                     0x0134 0x0338 0x0494 0x04 0x01
+#define IMX95_PAD_SD1_DATA1__GPIO3_IO_BIT11                           0x0134 0x0338 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD1_DATA2__USDHC1_DATA2                             0x0138 0x033C 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA2__FLEXIO1_FLEXIO_BIT12                     0x0138 0x033C 0x0498 0x04 0x01
+#define IMX95_PAD_SD1_DATA2__GPIO3_IO_BIT12                           0x0138 0x033C 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_DATA2__CCMSRCGPCMIX_TOP_PMIC_READY              0x0138 0x033C 0x0000 0x06 0x00
+
+#define IMX95_PAD_SD1_DATA3__USDHC1_DATA3                             0x013C 0x0340 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA3__FLEXSPI1_A_SS1_B                         0x013C 0x0340 0x0000 0x01 0x00
+#define IMX95_PAD_SD1_DATA3__FLEXIO1_FLEXIO_BIT13                     0x013C 0x0340 0x049C 0x04 0x01
+#define IMX95_PAD_SD1_DATA3__GPIO3_IO_BIT13                           0x013C 0x0340 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD1_DATA4__USDHC1_DATA4                             0x0140 0x0344 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA4__FLEXSPI1_A_DATA_BIT4                     0x0140 0x0344 0x04E4 0x01 0x00
+#define IMX95_PAD_SD1_DATA4__FLEXIO1_FLEXIO_BIT14                     0x0140 0x0344 0x04A0 0x04 0x01
+#define IMX95_PAD_SD1_DATA4__GPIO3_IO_BIT14                           0x0140 0x0344 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_DATA4__XSPI_DATA_BIT4                           0x0140 0x0344 0x05FC 0x06 0x00
+
+#define IMX95_PAD_SD1_DATA5__USDHC1_DATA5                             0x0144 0x0348 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA5__FLEXSPI1_A_DATA_BIT5                     0x0144 0x0348 0x04E8 0x01 0x00
+#define IMX95_PAD_SD1_DATA5__USDHC1_RESET_B                           0x0144 0x0348 0x0000 0x02 0x00
+#define IMX95_PAD_SD1_DATA5__FLEXIO1_FLEXIO_BIT15                     0x0144 0x0348 0x04A4 0x04 0x01
+#define IMX95_PAD_SD1_DATA5__GPIO3_IO_BIT15                           0x0144 0x0348 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_DATA5__XSPI_DATA_BIT5                           0x0144 0x0348 0x0600 0x06 0x00
+
+#define IMX95_PAD_SD1_DATA6__USDHC1_DATA6                             0x0148 0x034C 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA6__FLEXSPI1_A_DATA_BIT6                     0x0148 0x034C 0x04EC 0x01 0x00
+#define IMX95_PAD_SD1_DATA6__USDHC1_CD_B                              0x0148 0x034C 0x0000 0x02 0x00
+#define IMX95_PAD_SD1_DATA6__FLEXIO1_FLEXIO_BIT16                     0x0148 0x034C 0x04A8 0x04 0x01
+#define IMX95_PAD_SD1_DATA6__GPIO3_IO_BIT16                           0x0148 0x034C 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_DATA6__XSPI_DATA_BIT6                           0x0148 0x034C 0x0604 0x06 0x00
+
+#define IMX95_PAD_SD1_DATA7__USDHC1_DATA7                             0x014C 0x0350 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_DATA7__FLEXSPI1_A_DATA_BIT7                     0x014C 0x0350 0x04F0 0x01 0x00
+#define IMX95_PAD_SD1_DATA7__USDHC1_WP                                0x014C 0x0350 0x0000 0x02 0x00
+#define IMX95_PAD_SD1_DATA7__FLEXIO1_FLEXIO_BIT17                     0x014C 0x0350 0x04AC 0x04 0x01
+#define IMX95_PAD_SD1_DATA7__GPIO3_IO_BIT17                           0x014C 0x0350 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_DATA7__XSPI_DATA_BIT7                           0x014C 0x0350 0x0608 0x06 0x00
+
+#define IMX95_PAD_SD1_STROBE__USDHC1_STROBE                           0x0150 0x0354 0x0000 0x00 0x00
+#define IMX95_PAD_SD1_STROBE__FLEXSPI1_A_DQS                          0x0150 0x0354 0x04D0 0x01 0x00
+#define IMX95_PAD_SD1_STROBE__FLEXIO1_FLEXIO_BIT18                    0x0150 0x0354 0x04B0 0x04 0x01
+#define IMX95_PAD_SD1_STROBE__GPIO3_IO_BIT18                          0x0150 0x0354 0x0000 0x05 0x00
+#define IMX95_PAD_SD1_STROBE__XSPI_DQS                                0x0150 0x0354 0x05E4 0x06 0x00
+
+#define IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT                         0x0154 0x0358 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_VSELECT__USDHC2_WP                              0x0154 0x0358 0x0000 0x01 0x00
+#define IMX95_PAD_SD2_VSELECT__LPTMR2_ALT3                            0x0154 0x0358 0x0550 0x02 0x01
+#define IMX95_PAD_SD2_VSELECT__FLEXIO1_FLEXIO_BIT19                   0x0154 0x0358 0x04B4 0x04 0x01
+#define IMX95_PAD_SD2_VSELECT__GPIO3_IO_BIT19                         0x0154 0x0358 0x0000 0x05 0x00
+#define IMX95_PAD_SD2_VSELECT__CCMSRCGPCMIX_TOP_EXT_CLK1              0x0154 0x0358 0x0420 0x06 0x01
+
+#define IMX95_PAD_SD3_CLK__USDHC3_CLK                                 0x0158 0x035C 0x05C8 0x00 0x01
+#define IMX95_PAD_SD3_CLK__FLEXSPI1_A_SCLK                            0x0158 0x035C 0x04F4 0x01 0x00
+#define IMX95_PAD_SD3_CLK__SAI5_TX_DATA_BIT1                          0x0158 0x035C 0x0000 0x02 0x00
+#define IMX95_PAD_SD3_CLK__SAI5_RX_DATA_BIT0                          0x0158 0x035C 0x05AC 0x03 0x00
+#define IMX95_PAD_SD3_CLK__FLEXIO1_FLEXIO_BIT20                       0x0158 0x035C 0x04B8 0x04 0x01
+#define IMX95_PAD_SD3_CLK__GPIO3_IO_BIT20                             0x0158 0x035C 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_CLK__XSPI_CLK                                   0x0158 0x035C 0x05E8 0x06 0x00
+
+#define IMX95_PAD_SD3_CMD__USDHC3_CMD                                 0x015C 0x0360 0x05CC 0x00 0x01
+#define IMX95_PAD_SD3_CMD__FLEXSPI1_A_SS0_B                           0x015C 0x0360 0x0000 0x01 0x00
+#define IMX95_PAD_SD3_CMD__SAI5_TX_DATA_BIT2                          0x015C 0x0360 0x0000 0x02 0x00
+#define IMX95_PAD_SD3_CMD__SAI5_RX_SYNC                               0x015C 0x0360 0x05BC 0x03 0x00
+#define IMX95_PAD_SD3_CMD__FLEXIO1_FLEXIO_BIT21                       0x015C 0x0360 0x04BC 0x04 0x01
+#define IMX95_PAD_SD3_CMD__GPIO3_IO_BIT21                             0x015C 0x0360 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_CMD__XSPI_CS                                    0x015C 0x0360 0x05E0 0x06 0x00
+
+#define IMX95_PAD_SD3_DATA0__USDHC3_DATA0                             0x0160 0x0364 0x05D0 0x00 0x01
+#define IMX95_PAD_SD3_DATA0__FLEXSPI1_A_DATA_BIT0                     0x0160 0x0364 0x04D4 0x01 0x00
+#define IMX95_PAD_SD3_DATA0__SAI5_TX_DATA_BIT3                        0x0160 0x0364 0x0000 0x02 0x00
+#define IMX95_PAD_SD3_DATA0__SAI5_RX_BCLK                             0x0160 0x0364 0x05A8 0x03 0x00
+#define IMX95_PAD_SD3_DATA0__FLEXIO1_FLEXIO_BIT22                     0x0160 0x0364 0x04C0 0x04 0x01
+#define IMX95_PAD_SD3_DATA0__GPIO3_IO_BIT22                           0x0160 0x0364 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_DATA0__XSPI_DATA_BIT0                           0x0160 0x0364 0x05EC 0x06 0x00
+
+#define IMX95_PAD_SD3_DATA1__USDHC3_DATA1                             0x0164 0x0368 0x05D4 0x00 0x01
+#define IMX95_PAD_SD3_DATA1__FLEXSPI1_A_DATA_BIT1                     0x0164 0x0368 0x04D8 0x01 0x00
+#define IMX95_PAD_SD3_DATA1__SAI5_RX_DATA_BIT1                        0x0164 0x0368 0x05B0 0x02 0x00
+#define IMX95_PAD_SD3_DATA1__SAI5_TX_DATA_BIT0                        0x0164 0x0368 0x0000 0x03 0x00
+#define IMX95_PAD_SD3_DATA1__FLEXIO1_FLEXIO_BIT23                     0x0164 0x0368 0x04C4 0x04 0x01
+#define IMX95_PAD_SD3_DATA1__GPIO3_IO_BIT23                           0x0164 0x0368 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_DATA1__XSPI_DATA_BIT1                           0x0164 0x0368 0x05F0 0x06 0x00
+
+#define IMX95_PAD_SD3_DATA2__USDHC3_DATA2                             0x0168 0x036C 0x05D8 0x00 0x01
+#define IMX95_PAD_SD3_DATA2__FLEXSPI1_A_DATA_BIT2                     0x0168 0x036C 0x04DC 0x01 0x00
+#define IMX95_PAD_SD3_DATA2__SAI5_RX_DATA_BIT2                        0x0168 0x036C 0x05B4 0x02 0x00
+#define IMX95_PAD_SD3_DATA2__SAI5_TX_SYNC                             0x0168 0x036C 0x05C4 0x03 0x00
+#define IMX95_PAD_SD3_DATA2__FLEXIO1_FLEXIO_BIT24                     0x0168 0x036C 0x04C8 0x04 0x01
+#define IMX95_PAD_SD3_DATA2__GPIO3_IO_BIT24                           0x0168 0x036C 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_DATA2__XSPI_DATA_BIT2                           0x0168 0x036C 0x05F4 0x06 0x00
+
+#define IMX95_PAD_SD3_DATA3__USDHC3_DATA3                             0x016C 0x0370 0x05DC 0x00 0x01
+#define IMX95_PAD_SD3_DATA3__FLEXSPI1_A_DATA_BIT3                     0x016C 0x0370 0x04E0 0x01 0x00
+#define IMX95_PAD_SD3_DATA3__SAI5_RX_DATA_BIT3                        0x016C 0x0370 0x05B8 0x02 0x00
+#define IMX95_PAD_SD3_DATA3__SAI5_TX_BCLK                             0x016C 0x0370 0x05C0 0x03 0x00
+#define IMX95_PAD_SD3_DATA3__FLEXIO1_FLEXIO_BIT25                     0x016C 0x0370 0x04CC 0x04 0x01
+#define IMX95_PAD_SD3_DATA3__GPIO3_IO_BIT25                           0x016C 0x0370 0x0000 0x05 0x00
+#define IMX95_PAD_SD3_DATA3__XSPI_DATA_BIT3                           0x016C 0x0370 0x05F8 0x06 0x00
+
+#define IMX95_PAD_XSPI1_DATA0__FLEXSPI1_A_DATA_BIT0                   0x0170 0x0374 0x04D4 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA0__NETCMIX_TOP_SAI2_TX_DATA_BIT4          0x0170 0x0374 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_DATA0__SAI4_TX_BCLK                           0x0170 0x0374 0x05A0 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA0__SAI4_RX_DATA_BIT1                      0x0170 0x0374 0x0000 0x03 0x00
+#define IMX95_PAD_XSPI1_DATA0__XSPI_DATA_BIT0                         0x0170 0x0374 0x05EC 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA0__GPIO5_IO_BIT0                          0x0170 0x0374 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA1__FLEXSPI1_A_DATA_BIT1                   0x0174 0x0378 0x04D8 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA1__NETCMIX_TOP_SAI2_TX_DATA_BIT5          0x0174 0x0378 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_DATA1__SAI4_TX_SYNC                           0x0174 0x0378 0x05A4 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA1__SAI4_TX_DATA_BIT1                      0x0174 0x0378 0x0000 0x03 0x00
+#define IMX95_PAD_XSPI1_DATA1__XSPI_DATA_BIT1                         0x0174 0x0378 0x05F0 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA1__GPIO5_IO_BIT1                          0x0174 0x0378 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA2__FLEXSPI1_A_DATA_BIT2                   0x0178 0x037C 0x04DC 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA2__NETCMIX_TOP_SAI2_TX_DATA_BIT6          0x0178 0x037C 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_DATA2__SAI4_TX_DATA_BIT0                      0x0178 0x037C 0x0000 0x02 0x00
+#define IMX95_PAD_XSPI1_DATA2__XSPI_DATA_BIT2                         0x0178 0x037C 0x05F4 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA2__GPIO5_IO_BIT2                          0x0178 0x037C 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA3__FLEXSPI1_A_DATA_BIT3                   0x017C 0x0380 0x04E0 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA3__NETCMIX_TOP_SAI2_TX_DATA_BIT7          0x017C 0x0380 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_DATA3__SAI4_RX_DATA_BIT0                      0x017C 0x0380 0x0598 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA3__XSPI_DATA_BIT3                         0x017C 0x0380 0x05F8 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA3__GPIO5_IO_BIT3                          0x017C 0x0380 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA4__FLEXSPI1_A_DATA_BIT4                   0x0180 0x0384 0x04E4 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA4__SAI5_TX_DATA_BIT0                      0x0180 0x0384 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_DATA4__SAI5_RX_DATA_BIT1                      0x0180 0x0384 0x05B0 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA4__XSPI_DATA_BIT4                         0x0180 0x0384 0x05FC 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA4__GPIO5_IO_BIT4                          0x0180 0x0384 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA5__FLEXSPI1_A_DATA_BIT5                   0x0184 0x0388 0x04E8 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA5__SAI5_TX_SYNC                           0x0184 0x0388 0x05C4 0x01 0x01
+#define IMX95_PAD_XSPI1_DATA5__SAI5_RX_DATA_BIT2                      0x0184 0x0388 0x05B4 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA5__NETCMIX_TOP_SAI2_RX_DATA_BIT6          0x0184 0x0388 0x043C 0x03 0x00
+#define IMX95_PAD_XSPI1_DATA5__XSPI_DATA_BIT5                         0x0184 0x0388 0x0600 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA5__GPIO5_IO_BIT5                          0x0184 0x0388 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA6__FLEXSPI1_A_DATA_BIT6                   0x0188 0x038C 0x04EC 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA6__SAI5_TX_BCLK                           0x0188 0x038C 0x05C0 0x01 0x01
+#define IMX95_PAD_XSPI1_DATA6__SAI5_RX_DATA_BIT3                      0x0188 0x038C 0x05B8 0x02 0x01
+#define IMX95_PAD_XSPI1_DATA6__NETCMIX_TOP_SAI2_RX_DATA_BIT7          0x0188 0x038C 0x0440 0x03 0x00
+#define IMX95_PAD_XSPI1_DATA6__XSPI_DATA_BIT6                         0x0188 0x038C 0x0604 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA6__GPIO5_IO_BIT6                          0x0188 0x038C 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DATA7__FLEXSPI1_A_DATA_BIT7                   0x018C 0x0390 0x04F0 0x00 0x01
+#define IMX95_PAD_XSPI1_DATA7__SAI5_RX_DATA_BIT0                      0x018C 0x0390 0x05AC 0x01 0x01
+#define IMX95_PAD_XSPI1_DATA7__SAI5_TX_DATA_BIT1                      0x018C 0x0390 0x0000 0x02 0x00
+#define IMX95_PAD_XSPI1_DATA7__XSPI_DATA_BIT7                         0x018C 0x0390 0x0608 0x04 0x01
+#define IMX95_PAD_XSPI1_DATA7__GPIO5_IO_BIT7                          0x018C 0x0390 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_DQS__FLEXSPI1_A_DQS                           0x0190 0x0394 0x04D0 0x00 0x01
+#define IMX95_PAD_XSPI1_DQS__SAI5_RX_SYNC                             0x0190 0x0394 0x05BC 0x01 0x01
+#define IMX95_PAD_XSPI1_DQS__SAI5_TX_DATA_BIT2                        0x0190 0x0394 0x0000 0x02 0x00
+#define IMX95_PAD_XSPI1_DQS__NETCMIX_TOP_SAI2_RX_DATA_BIT6            0x0190 0x0394 0x043C 0x03 0x01
+#define IMX95_PAD_XSPI1_DQS__XSPI_DQS                                 0x0190 0x0394 0x05E4 0x04 0x01
+#define IMX95_PAD_XSPI1_DQS__GPIO5_IO_BIT8                            0x0190 0x0394 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_SCLK__FLEXSPI1_A_SCLK                         0x0194 0x0398 0x04F4 0x00 0x01
+#define IMX95_PAD_XSPI1_SCLK__NETCMIX_TOP_SAI2_RX_DATA_BIT4           0x0194 0x0398 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_SCLK__SAI4_RX_SYNC                            0x0194 0x0398 0x059C 0x02 0x01
+#define IMX95_PAD_XSPI1_SCLK__EARC_DC_HPD_IN                          0x0194 0x0398 0x0000 0x03 0x00
+#define IMX95_PAD_XSPI1_SCLK__XSPI_CLK                                0x0194 0x0398 0x05E8 0x04 0x01
+#define IMX95_PAD_XSPI1_SCLK__GPIO5_IO_BIT9                           0x0194 0x0398 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_SS0_B__FLEXSPI1_A_SS0_B                       0x0198 0x039C 0x0000 0x00 0x00
+#define IMX95_PAD_XSPI1_SS0_B__NETCMIX_TOP_SAI2_RX_DATA_BIT5          0x0198 0x039C 0x0000 0x01 0x00
+#define IMX95_PAD_XSPI1_SS0_B__SAI4_RX_BCLK                           0x0198 0x039C 0x0594 0x02 0x01
+#define IMX95_PAD_XSPI1_SS0_B__EARC_CEC_OUT                           0x0198 0x039C 0x0000 0x03 0x00
+#define IMX95_PAD_XSPI1_SS0_B__XSPI_CS                                0x0198 0x039C 0x05E0 0x04 0x01
+#define IMX95_PAD_XSPI1_SS0_B__GPIO5_IO_BIT10                         0x0198 0x039C 0x0000 0x05 0x00
+
+#define IMX95_PAD_XSPI1_SS1_B__FLEXSPI1_A_SS1_B                       0x019C 0x03A0 0x0000 0x00 0x00
+#define IMX95_PAD_XSPI1_SS1_B__SAI5_RX_BCLK                           0x019C 0x03A0 0x05A8 0x01 0x01
+#define IMX95_PAD_XSPI1_SS1_B__SAI5_TX_DATA_BIT3                      0x019C 0x03A0 0x0000 0x02 0x00
+#define IMX95_PAD_XSPI1_SS1_B__NETCMIX_TOP_SAI2_RX_DATA_BIT7          0x019C 0x03A0 0x0440 0x03 0x01
+#define IMX95_PAD_XSPI1_SS1_B__GPIO5_IO_BIT11                         0x019C 0x03A0 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD2_CD_B__USDHC2_CD_B                               0x01A0 0x03A4 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_CD_B__NETCMIX_TOP_NETC_TMR_1588_TRIG1           0x01A0 0x03A4 0x0434 0x01 0x01
+#define IMX95_PAD_SD2_CD_B__I3C2_SCL                                  0x01A0 0x03A4 0x04F8 0x02 0x01
+#define IMX95_PAD_SD2_CD_B__FLEXIO1_FLEXIO_BIT0                       0x01A0 0x03A4 0x0468 0x04 0x01
+#define IMX95_PAD_SD2_CD_B__GPIO3_IO_BIT0                             0x01A0 0x03A4 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD2_CLK__USDHC2_CLK                                 0x01A4 0x03A8 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_CLK__NETCMIX_TOP_NETC_TMR_1588_PP1              0x01A4 0x03A8 0x0000 0x01 0x00
+#define IMX95_PAD_SD2_CLK__I3C2_SDA                                   0x01A4 0x03A8 0x04FC 0x02 0x01
+#define IMX95_PAD_SD2_CLK__FLEXIO1_FLEXIO_BIT1                        0x01A4 0x03A8 0x046C 0x04 0x01
+#define IMX95_PAD_SD2_CLK__GPIO3_IO_BIT1                              0x01A4 0x03A8 0x0000 0x05 0x00
+#define IMX95_PAD_SD2_CLK__CCMSRCGPCMIX_TOP_OBSERVE_0                 0x01A4 0x03A8 0x0000 0x06 0x00
+
+#define IMX95_PAD_SD2_CMD__USDHC2_CMD                                 0x01A8 0x03AC 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_CMD__NETCMIX_TOP_NETC_TMR_1588_TRIG2            0x01A8 0x03AC 0x0438 0x01 0x01
+#define IMX95_PAD_SD2_CMD__I3C2_PUR                                   0x01A8 0x03AC 0x0000 0x02 0x00
+#define IMX95_PAD_SD2_CMD__I3C2_PUR_B                                 0x01A8 0x03AC 0x0000 0x03 0x00
+#define IMX95_PAD_SD2_CMD__FLEXIO1_FLEXIO_BIT2                        0x01A8 0x03AC 0x0470 0x04 0x01
+#define IMX95_PAD_SD2_CMD__GPIO3_IO_BIT2                              0x01A8 0x03AC 0x0000 0x05 0x00
+#define IMX95_PAD_SD2_CMD__CCMSRCGPCMIX_TOP_OBSERVE_1                 0x01A8 0x03AC 0x0000 0x06 0x00
+
+#define IMX95_PAD_SD2_DATA0__USDHC2_DATA0                             0x01AC 0x03B0 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_DATA0__NETCMIX_TOP_NETC_TMR_1588_PP2            0x01AC 0x03B0 0x0000 0x01 0x00
+#define IMX95_PAD_SD2_DATA0__CAN2_TX                                  0x01AC 0x03B0 0x0000 0x02 0x00
+#define IMX95_PAD_SD2_DATA0__FLEXIO1_FLEXIO_BIT3                      0x01AC 0x03B0 0x0474 0x04 0x01
+#define IMX95_PAD_SD2_DATA0__GPIO3_IO_BIT3                            0x01AC 0x03B0 0x0000 0x05 0x00
+#define IMX95_PAD_SD2_DATA0__CCMSRCGPCMIX_TOP_OBSERVE_2               0x01AC 0x03B0 0x0000 0x06 0x00
+
+#define IMX95_PAD_SD2_DATA1__USDHC2_DATA1                             0x01B0 0x03B4 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_DATA1__NETCMIX_TOP_NETC_TMR_1588_CLK            0x01B0 0x03B4 0x0000 0x01 0x00
+#define IMX95_PAD_SD2_DATA1__CAN2_RX                                  0x01B0 0x03B4 0x0444 0x02 0x03
+#define IMX95_PAD_SD2_DATA1__FLEXIO1_FLEXIO_BIT4                      0x01B0 0x03B4 0x0478 0x04 0x01
+#define IMX95_PAD_SD2_DATA1__GPIO3_IO_BIT4                            0x01B0 0x03B4 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD2_DATA2__USDHC2_DATA2                             0x01B4 0x03B8 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_DATA2__NETCMIX_TOP_NETC_TMR_1588_PP3            0x01B4 0x03B8 0x0000 0x01 0x00
+#define IMX95_PAD_SD2_DATA2__NETCMIX_TOP_MQS2_RIGHT                   0x01B4 0x03B8 0x0000 0x02 0x00
+#define IMX95_PAD_SD2_DATA2__FLEXIO1_FLEXIO_BIT5                      0x01B4 0x03B8 0x047C 0x04 0x01
+#define IMX95_PAD_SD2_DATA2__GPIO3_IO_BIT5                            0x01B4 0x03B8 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD2_DATA3__USDHC2_DATA3                             0x01B8 0x03BC 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_DATA3__LPTMR2_ALT1                              0x01B8 0x03BC 0x0548 0x01 0x01
+#define IMX95_PAD_SD2_DATA3__NETCMIX_TOP_MQS2_LEFT                    0x01B8 0x03BC 0x0000 0x02 0x00
+#define IMX95_PAD_SD2_DATA3__NETCMIX_TOP_NETC_TMR_1588_ALARM1         0x01B8 0x03BC 0x0000 0x03 0x00
+#define IMX95_PAD_SD2_DATA3__FLEXIO1_FLEXIO_BIT6                      0x01B8 0x03BC 0x0480 0x04 0x01
+#define IMX95_PAD_SD2_DATA3__GPIO3_IO_BIT6                            0x01B8 0x03BC 0x0000 0x05 0x00
+
+#define IMX95_PAD_SD2_RESET_B__USDHC2_RESET_B                         0x01BC 0x03C0 0x0000 0x00 0x00
+#define IMX95_PAD_SD2_RESET_B__LPTMR2_ALT2                            0x01BC 0x03C0 0x054C 0x01 0x01
+#define IMX95_PAD_SD2_RESET_B__NETCMIX_TOP_NETC_TMR_1588_GCLK         0x01BC 0x03C0 0x0000 0x03 0x00
+#define IMX95_PAD_SD2_RESET_B__FLEXIO1_FLEXIO_BIT7                    0x01BC 0x03C0 0x0484 0x04 0x01
+#define IMX95_PAD_SD2_RESET_B__GPIO3_IO_BIT7                          0x01BC 0x03C0 0x0000 0x05 0x00
+
+#define IMX95_PAD_I2C1_SCL__AONMIX_TOP_LPI2C1_SCL                     0x01C0 0x03C4 0x0000 0x00 0x00
+#define IMX95_PAD_I2C1_SCL__AONMIX_TOP_I3C1_SCL                       0x01C0 0x03C4 0x0000 0x01 0x00
+#define IMX95_PAD_I2C1_SCL__AONMIX_TOP_LPUART1_DCD_B                  0x01C0 0x03C4 0x0000 0x02 0x00
+#define IMX95_PAD_I2C1_SCL__AONMIX_TOP_TPM2_CH0                       0x01C0 0x03C4 0x0000 0x03 0x00
+#define IMX95_PAD_I2C1_SCL__VPUMIX_TOP_UART_RX                        0x01C0 0x03C4 0x0000 0x04 0x00
+#define IMX95_PAD_I2C1_SCL__AONMIX_TOP_GPIO1_IO_BIT0                  0x01C0 0x03C4 0x0000 0x05 0x00
+
+#define IMX95_PAD_I2C1_SDA__AONMIX_TOP_LPI2C1_SDA                     0x01C4 0x03C8 0x0000 0x00 0x00
+#define IMX95_PAD_I2C1_SDA__AONMIX_TOP_I3C1_SDA                       0x01C4 0x03C8 0x0000 0x01 0x00
+#define IMX95_PAD_I2C1_SDA__AONMIX_TOP_LPUART1_RIN_B                  0x01C4 0x03C8 0x0000 0x02 0x00
+#define IMX95_PAD_I2C1_SDA__AONMIX_TOP_TPM2_CH1                       0x01C4 0x03C8 0x0000 0x03 0x00
+#define IMX95_PAD_I2C1_SDA__VPUMIX_TOP_UART_TX                        0x01C4 0x03C8 0x0000 0x04 0x00
+#define IMX95_PAD_I2C1_SDA__AONMIX_TOP_GPIO1_IO_BIT1                  0x01C4 0x03C8 0x0000 0x05 0x00
+
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPI2C2_SCL                     0x01C8 0x03CC 0x0000 0x00 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_I3C1_PUR                       0x01C8 0x03CC 0x0000 0x01 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPUART2_DCD_B                  0x01C8 0x03CC 0x0000 0x02 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_TPM2_CH2                       0x01C8 0x03CC 0x0000 0x03 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_SAI1_RX_SYNC                   0x01C8 0x03CC 0x0000 0x04 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_GPIO1_IO_BIT2                  0x01C8 0x03CC 0x0000 0x05 0x00
+#define IMX95_PAD_I2C2_SCL__AONMIX_TOP_I3C1_PUR_B                     0x01C8 0x03CC 0x0000 0x06 0x00
+
+#define IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA                     0x01CC 0x03D0 0x0000 0x00 0x00
+#define IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPUART2_RIN_B                  0x01CC 0x03D0 0x0000 0x02 0x00
+#define IMX95_PAD_I2C2_SDA__AONMIX_TOP_TPM2_CH3                       0x01CC 0x03D0 0x0000 0x03 0x00
+#define IMX95_PAD_I2C2_SDA__AONMIX_TOP_SAI1_RX_BCLK                   0x01CC 0x03D0 0x0000 0x04 0x00
+#define IMX95_PAD_I2C2_SDA__AONMIX_TOP_GPIO1_IO_BIT3                  0x01CC 0x03D0 0x0000 0x05 0x00
+
+#define IMX95_PAD_UART1_RXD__AONMIX_TOP_LPUART1_RX                    0x01D0 0x03D4 0x0000 0x00 0x00
+#define IMX95_PAD_UART1_RXD__S400_UART_RX                             0x01D0 0x03D4 0x0000 0x01 0x00
+#define IMX95_PAD_UART1_RXD__AONMIX_TOP_LPSPI2_SIN                    0x01D0 0x03D4 0x0000 0x02 0x00
+#define IMX95_PAD_UART1_RXD__AONMIX_TOP_TPM1_CH0                      0x01D0 0x03D4 0x0000 0x03 0x00
+#define IMX95_PAD_UART1_RXD__AONMIX_TOP_GPIO1_IO_BIT4                 0x01D0 0x03D4 0x0000 0x05 0x00
+
+#define IMX95_PAD_UART1_TXD__AONMIX_TOP_LPUART1_TX                    0x01D4 0x03D8 0x0000 0x00 0x00
+#define IMX95_PAD_UART1_TXD__S400_UART_TX                             0x01D4 0x03D8 0x0000 0x01 0x00
+#define IMX95_PAD_UART1_TXD__AONMIX_TOP_LPSPI2_PCS0                   0x01D4 0x03D8 0x0000 0x02 0x00
+#define IMX95_PAD_UART1_TXD__AONMIX_TOP_TPM1_CH1                      0x01D4 0x03D8 0x0000 0x03 0x00
+#define IMX95_PAD_UART1_TXD__AONMIX_TOP_GPIO1_IO_BIT5                 0x01D4 0x03D8 0x0000 0x05 0x00
+
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART2_RX                    0x01D8 0x03DC 0x0000 0x00 0x00
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART1_CTS_B                 0x01D8 0x03DC 0x0000 0x01 0x00
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_LPSPI2_SOUT                   0x01D8 0x03DC 0x0000 0x02 0x00
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_TPM1_CH2                      0x01D8 0x03DC 0x0000 0x03 0x00
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_SAI1_MCLK                     0x01D8 0x03DC 0x041C 0x04 0x00
+#define IMX95_PAD_UART2_RXD__AONMIX_TOP_GPIO1_IO_BIT6                 0x01D8 0x03DC 0x0000 0x05 0x00
+
+#define IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART2_TX                    0x01DC 0x03E0 0x0000 0x00 0x00
+#define IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART1_RTS_B                 0x01DC 0x03E0 0x0000 0x01 0x00
+#define IMX95_PAD_UART2_TXD__AONMIX_TOP_LPSPI2_SCK                    0x01DC 0x03E0 0x0000 0x02 0x00
+#define IMX95_PAD_UART2_TXD__AONMIX_TOP_TPM1_CH3                      0x01DC 0x03E0 0x0000 0x03 0x00
+#define IMX95_PAD_UART2_TXD__AONMIX_TOP_GPIO1_IO_BIT7                 0x01DC 0x03E0 0x0000 0x05 0x00
+
+#define IMX95_PAD_PDM_CLK__AONMIX_TOP_PDM_CLK                         0x01E0 0x03E4 0x0000 0x00 0x00
+#define IMX95_PAD_PDM_CLK__AONMIX_TOP_MQS1_LEFT                       0x01E0 0x03E4 0x0000 0x01 0x00
+#define IMX95_PAD_PDM_CLK__AONMIX_TOP_LPTMR1_ALT1                     0x01E0 0x03E4 0x0000 0x04 0x00
+#define IMX95_PAD_PDM_CLK__AONMIX_TOP_GPIO1_IO_BIT8                   0x01E0 0x03E4 0x0000 0x05 0x00
+#define IMX95_PAD_PDM_CLK__AONMIX_TOP_CAN1_TX                         0x01E0 0x03E4 0x0000 0x06 0x00
+
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_PDM_BIT_STREAM_BIT0     0x01E4 0x03E8 0x040C 0x00 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_MQS1_RIGHT              0x01E4 0x03E8 0x0000 0x01 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_LPSPI1_PCS1             0x01E4 0x03E8 0x0000 0x02 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_TPM1_EXTCLK             0x01E4 0x03E8 0x0000 0x03 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_LPTMR1_ALT2             0x01E4 0x03E8 0x0000 0x04 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_GPIO1_IO_BIT9           0x01E4 0x03E8 0x0000 0x05 0x00
+#define IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_CAN1_RX                 0x01E4 0x03E8 0x0408 0x06 0x00
+
+#define IMX95_PAD_PDM_BIT_STREAM1__AONMIX_TOP_PDM_BIT_STREAM_BIT1     0x01E8 0x03EC 0x0410 0x00 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__NMI_GLUE_NMI                       0x01E8 0x03EC 0x0000 0x01 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__AONMIX_TOP_LPSPI2_PCS1             0x01E8 0x03EC 0x0000 0x02 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__AONMIX_TOP_TPM2_EXTCLK             0x01E8 0x03EC 0x0000 0x03 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__AONMIX_TOP_LPTMR1_ALT3             0x01E8 0x03EC 0x0000 0x04 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__AONMIX_TOP_GPIO1_IO_BIT10          0x01E8 0x03EC 0x0000 0x05 0x00
+#define IMX95_PAD_PDM_BIT_STREAM1__CCMSRCGPCMIX_TOP_EXT_CLK1          0x01E8 0x03EC 0x0420 0x06 0x00
+
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_SYNC                  0x01EC 0x03F0 0x0000 0x00 0x00
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_DATA_BIT1             0x01EC 0x03F0 0x0000 0x01 0x00
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_LPSPI1_PCS0                   0x01EC 0x03F0 0x0000 0x02 0x00
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_LPUART2_DTR_B                 0x01EC 0x03F0 0x0000 0x03 0x00
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_MQS1_LEFT                     0x01EC 0x03F0 0x0000 0x04 0x00
+#define IMX95_PAD_SAI1_TXFS__AONMIX_TOP_GPIO1_IO_BIT11                0x01EC 0x03F0 0x0000 0x05 0x00
+
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_SAI1_TX_BCLK                   0x01F0 0x03F4 0x0000 0x00 0x00
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_LPUART2_CTS_B                  0x01F0 0x03F4 0x0000 0x01 0x00
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_LPSPI1_SIN                     0x01F0 0x03F4 0x0000 0x02 0x00
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_LPUART1_DSR_B                  0x01F0 0x03F4 0x0000 0x03 0x00
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_CAN1_RX                        0x01F0 0x03F4 0x0408 0x04 0x01
+#define IMX95_PAD_SAI1_TXC__AONMIX_TOP_GPIO1_IO_BIT12                 0x01F0 0x03F4 0x0000 0x05 0x00
+
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0             0x01F4 0x03F8 0x0000 0x00 0x00
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_LPUART2_RTS_B                 0x01F4 0x03F8 0x0000 0x01 0x00
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_LPSPI1_SCK                    0x01F4 0x03F8 0x0000 0x02 0x00
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_LPUART1_DTR_B                 0x01F4 0x03F8 0x0000 0x03 0x00
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_CAN1_TX                       0x01F4 0x03F8 0x0000 0x04 0x00
+#define IMX95_PAD_SAI1_TXD0__AONMIX_TOP_GPIO1_IO_BIT13                0x01F4 0x03F8 0x0000 0x05 0x00
+
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0             0x01F8 0x03FC 0x0000 0x00 0x00
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_MCLK                     0x01F8 0x03FC 0x041C 0x01 0x01
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_LPSPI1_SOUT                   0x01F8 0x03FC 0x0000 0x02 0x00
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_LPUART2_DSR_B                 0x01F8 0x03FC 0x0000 0x03 0x00
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_MQS1_RIGHT                    0x01F8 0x03FC 0x0000 0x04 0x00
+#define IMX95_PAD_SAI1_RXD0__AONMIX_TOP_GPIO1_IO_BIT14                0x01F8 0x03FC 0x0000 0x05 0x00
+
+#define IMX95_PAD_WDOG_ANY__AONMIX_TOP_WDOG_ANY                       0x01FC 0x0400 0x0000 0x00 0x00
+#define IMX95_PAD_WDOG_ANY__AONMIX_TOP_FCCU_EOUT1                     0x01FC 0x0400 0x0000 0x01 0x00
+#define IMX95_PAD_WDOG_ANY__AONMIX_TOP_GPIO1_IO_BIT15                 0x01FC 0x0400 0x0000 0x05 0x00
+#endif /* __DTS_IMX95_PINFUNC_H */
diff --git a/arch/arm64/boot/dts/adlink/imx95.dtsi b/arch/arm64/boot/dts/adlink/imx95.dtsi
new file mode 100644
index 000000000000..31d05e6fa990
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/imx95.dtsi
@@ -0,0 +1,3264 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include <dt-bindings/clock/fsl,imx95-clock.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/net/nxp-netc.h>
+#include <dt-bindings/power/fsl,imx95-power.h>
+#include <dt-bindings/thermal/thermal.h>
+
+#include "imx95-pinfunc.h"
+
+/ {
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		gpio0 = &gpio1;
+		gpio1 = &gpio2;
+		gpio2 = &gpio3;
+		gpio3 = &gpio4;
+		gpio4 = &gpio5;
+		i2c0 = &lpi2c1;
+		i2c1 = &lpi2c2;
+		i2c2 = &lpi2c3;
+		i2c3 = &lpi2c4;
+		i2c4 = &lpi2c5;
+		i2c5 = &lpi2c6;
+		i2c6 = &lpi2c7;
+		i2c7 = &lpi2c8;
+		mmc0 = &usdhc1;
+		mmc1 = &usdhc2;
+		mmc2 = &usdhc3;
+		serial0 = &lpuart1;
+		serial1 = &lpuart2;
+		serial2 = &lpuart3;
+		serial3 = &lpuart4;
+		serial4 = &lpuart5;
+		serial5 = &lpuart6;
+		serial6 = &lpuart7;
+		serial7 = &lpuart8;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		idle-states {
+			entry-method = "psci";
+
+			cpu_pd_wait: cpu-pd-wait {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x0010033>;
+				local-timer-stop;
+				/*
+				entry-latency-us = <10000>;
+				exit-latency-us = <7000>;
+				min-residency-us = <27000>;
+				wakeup-latency-us = <15000>;
+				*/
+				entry-latency-us = <1000>;
+				exit-latency-us = <700>;
+				min-residency-us = <2700>;
+				wakeup-latency-us = <1500>;
+				status = "okay";
+			};
+		};
+
+		A55_0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x0>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l0>;
+		};
+
+		A55_1: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x100>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l1>;
+		};
+
+		A55_2: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x200>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l2>;
+		};
+
+		A55_3: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x300>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l3>;
+		};
+
+		A55_4: cpu@400 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x400>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l4>;
+		};
+
+		A55_5: cpu@500 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a55";
+			reg = <0x500>;
+			power-domains = <&scmi_perf IMX95_PERF_A55>;
+			power-domain-names = "perf";
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+			i-cache-size = <32768>;
+			i-cache-line-size = <64>;
+			i-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-cache-line-size = <64>;
+			d-cache-sets = <128>;
+			next-level-cache = <&l2_cache_l5>;
+		};
+
+		l2_cache_l0: l2-cache-l0 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l2_cache_l1: l2-cache-l1 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l2_cache_l2: l2-cache-l2 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l2_cache_l3: l2-cache-l3 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l2_cache_l4: l2-cache-l4 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l2_cache_l5: l2-cache-l5 {
+			compatible = "cache";
+			cache-size = <65536>;
+			cache-line-size = <64>;
+			cache-sets = <256>;
+			cache-level = <2>;
+			cache-unified;
+			next-level-cache = <&l3_cache>;
+		};
+
+		l3_cache: l3-cache {
+			compatible = "cache";
+			cache-size = <524288>;
+			cache-line-size = <64>;
+			cache-sets = <512>;
+			cache-level = <3>;
+			cache-unified;
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&A55_0>;
+				};
+
+				core1 {
+					cpu = <&A55_1>;
+				};
+
+				core2 {
+					cpu = <&A55_2>;
+				};
+
+				core3 {
+					cpu = <&A55_3>;
+				};
+
+				core4 {
+					cpu = <&A55_4>;
+				};
+
+				core5 {
+					cpu = <&A55_5>;
+				};
+			};
+		};
+	};
+
+	clk_ext1: clock-ext1 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <133000000>;
+		clock-output-names = "clk_ext1";
+	};
+
+	dummy: clk-dummy {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <0>;
+		clock-output-names = "dummy";
+	};
+
+	mqs1: mqs1 {
+		compatible = "fsl,imx95-mqs";
+		status = "disabled";
+	};
+
+	mqs2: mqs2 {
+		compatible = "fsl,imx95-mqs";
+		status = "disabled";
+	};
+
+	sai1_mclk: sai-mclk1 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <0>;
+		clock-output-names = "sai1_mclk";
+	};
+
+	sai2_mclk: sai-mclk2 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <0>;
+		clock-output-names = "sai2_mclk";
+	};
+
+	sai3_mclk: sai-mclk3 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <0>;
+		clock-output-names = "sai3_mclk";
+	};
+
+	sai4_mclk: sai-mclk4 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <0>;
+		clock-output-names = "sai4_mclk";
+	};
+
+	sai5_mclk: sai-mclk5 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <0>;
+		clock-output-names = "sai5_mclk";
+	};
+
+	osc_24m: osc-24m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "osc_24m";
+	};
+
+	ldb_pll_pixel: ldb_pll_div7 {
+		#clock-cells = <0>;
+		compatible = "fixed-factor-clock";
+		clocks = <&scmi_clk IMX95_CLK_LDBPLL>;
+		clock-div = <7>;
+		clock-mult = <1>;
+		clock-output-names = "ldb_pll_div7";
+	};
+
+	sram0: sram@445b1000 {
+		compatible = "mmio-sram";
+		reg = <0x0 0x445b1000 0x0 0x400>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x445b1000 0x400>;
+
+		scmi_buf0: scmi-sram-section@0 {
+			compatible = "arm,scmi-shmem";
+			reg = <0x0 0x80>;
+		};
+
+		scmi_buf1: scmi-sram-section@80 {
+			compatible = "arm,scmi-shmem";
+			reg = <0x80 0x80>;
+		};
+	};
+
+	sram1: sram@204c0000 {
+		compatible = "mmio-sram";
+		reg = <0x0 0x204c0000 0x0 0x18000>;
+	};
+
+	firmware {
+		scmi {
+			compatible = "arm,scmi";
+			mboxes = <&mu2 5 0>, <&mu2 3 0>, <&mu2 3 1>, <&mu2 5 1>;
+			shmem = <&scmi_buf0>, <&scmi_buf1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			scmi_devpd: protocol@11 {
+				reg = <0x11>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_sys_power: protocol@12 {
+				reg = <0x12>;
+			};
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_sensor: protocol@15 {
+				reg = <0x15>;
+				#thermal-sensor-cells = <1>;
+			};
+
+			scmi_iomuxc: protocol@19 {
+				reg = <0x19>;
+			};
+
+			scmi_bbm: protocol@81 {
+				reg = <0x81>;
+			};
+
+			scmi_misc: protocol@84 {
+				reg = <0x84>;
+			};
+		};
+	};
+
+	pmu {
+		compatible = "arm,cortex-a55-pmu";
+		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	thermal_zones: thermal-zones {
+		a55 {
+			polling-delay-passive = <250>;
+			polling-delay = <2000>;
+			thermal-sensors = <&scmi_sensor 1>;
+			trips {
+				cpu_alert0: trip0 {
+					temperature = <105000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_crit0: trip1 {
+					temperature = <125000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert0>;
+					cooling-device =
+						<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		ana {
+			polling-delay-passive = <250>;
+			polling-delay = <2000>;
+			thermal-sensors = <&scmi_sensor 0>;
+			trips {
+				ana_alert: trip0 {
+					temperature = <105000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				ana_crit0: trip1 {
+					temperature = <125000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&ana_alert>;
+					cooling-device =
+						<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&mali  THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&vpuctrl THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+				map1 {
+					trip = <&ana_crit0>;
+					cooling-device = <&mali THERMAL_NO_LIMIT 1>;
+				};
+			};
+		};
+	};
+
+	etm0: etm@40840000 {
+		compatible = "arm,coresight-etm4x", "arm,primecell";
+		reg = <0x0 0x40840000 0x0 0x10000>;
+		arm,primecell-periphid = <0xbb95d>;
+		cpu = <&A55_0>;
+		clocks = <&scmi_clk IMX95_CLK_A55PERIPH>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		out-ports {
+			port {
+				etm0_out_port: endpoint {
+					remote-endpoint = <&ca_funnel_in_port0>;
+				};
+			};
+		};
+	};
+
+	funnel0: funnel {
+		/*
+		 * non-configurable funnel don't show up on the AMBA
+		 * bus.  As such no need to add "arm,primecell".
+		 */
+		compatible = "arm,coresight-static-funnel";
+		status = "disabled";
+
+		in-ports {
+			port {
+				ca_funnel_in_port0: endpoint {
+					remote-endpoint = <&etm0_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			port {
+				ca_funnel_out_port0: endpoint {
+					remote-endpoint = <&hugo_funnel_in_port0>;
+				};
+			};
+		};
+	};
+
+	funnel1: funnel_sys {
+		compatible = "arm,coresight-static-funnel";
+		status = "disabled";
+
+		in-ports {
+			port {
+				hugo_funnel_in_port0: endpoint {
+					remote-endpoint = <&ca_funnel_out_port0>;
+				};
+			};
+		};
+
+		out-ports {
+			port {
+				hugo_funnel_out_port0: endpoint {
+					remote-endpoint = <&etf_in_port>;
+				};
+			};
+		};
+	};
+
+	etf: etf@41030000 {
+		compatible = "arm,coresight-tmc", "arm,primecell";
+		reg = <0x0 0x41030000 0x0 0x1000>;
+		clocks = <&scmi_clk IMX95_CLK_A55PERIPH>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				etf_in_port: endpoint {
+					remote-endpoint = <&hugo_funnel_out_port0>;
+				};
+			};
+		};
+
+		out-ports {
+			port {
+				etf_out_port: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+		};
+	};
+
+	etr: etr@41040000 {
+		compatible = "arm,coresight-tmc", "arm,primecell";
+		reg = <0x0 0x41040000 0x0 0x1000>;
+		clocks = <&scmi_clk IMX95_CLK_A55PERIPH>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				etr_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>;
+		clock-frequency = <24000000>;
+		arm,no-tick-in-suspend;
+		interrupt-parent = <&gic>;
+	};
+
+	gic: interrupt-controller@48000000 {
+		compatible = "arm,gic-v3";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		reg = <0 0x48000000 0 0x10000>,
+		      <0 0x48060000 0 0xc0000>;
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&gic>;
+		dma-noncoherent;
+
+		ranges;
+
+		its: msi-controller@48040000 {
+			compatible = "arm,gic-v3-its";
+			dma-noncoherent;
+			msi-controller;
+			reg = <0 0x48040000 0 0x20000>;
+		};
+	};
+
+
+	gpu_opp_table: opp_table {
+		compatible = "operating-points-v2", "operating-points-v2-mali";
+
+		opp-1000000000 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-hz-real = /bits/ 64 <1000000000>, /bits/ 64 <133333333>;
+			opp-microvolt = <920000>;
+		};
+
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-hz-real = /bits/ 64 <800000000>, /bits/ 64 <133333333>;
+			opp-microvolt = <920000>;
+		};
+		opp-500000000 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-hz-real = /bits/ 64 <500000000>, /bits/ 64 <133333333>;
+			opp-microvolt = <920000>;
+		};
+
+	};
+
+	usbphynop: usbphynop {
+		compatible = "usb-nop-xceiv";
+		#phy-cells = <0>;
+		clocks = <&scmi_clk IMX95_CLK_HSIO>;
+		clock-names = "main_clk";
+	};
+
+	imx95_soc: imx95-soc {
+		compatible = "fsl,imx95-soc";
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		aips2: bus@42000000 {
+			compatible = "fsl,aips-bus", "simple-bus";
+			reg = <0x0 0x42000000 0x0 0x800000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x42000000 0x0 0x42000000 0x8000000>,
+				 <0x28000000 0x0 0x28000000 0x10000000>;
+
+			edma2: dma-controller@42000000 {
+				compatible = "fsl,imx95-edma";
+				reg = <0x42000000 0x10000>,
+				      <0x42010000 0x8000>, <0x42018000 0x8000>,
+				      <0x42020000 0x8000>, <0x42028000 0x8000>,
+				      <0x42030000 0x8000>, <0x42038000 0x8000>,
+				      <0x42040000 0x8000>, <0x42048000 0x8000>,
+				      <0x42050000 0x8000>, <0x42058000 0x8000>,
+				      <0x42060000 0x8000>, <0x42068000 0x8000>,
+				      <0x42070000 0x8000>, <0x42078000 0x8000>,
+				      <0x42080000 0x8000>, <0x42088000 0x8000>,
+				      <0x42090000 0x8000>, <0x42098000 0x8000>,
+				      <0x420a0000 0x8000>, <0x420a8000 0x8000>,
+				      <0x420b0000 0x8000>, <0x420b8000 0x8000>,
+				      <0x420c0000 0x8000>, <0x420c8000 0x8000>,
+				      <0x420d0000 0x8000>, <0x420d8000 0x8000>,
+				      <0x420e0000 0x8000>, <0x420e8000 0x8000>,
+				      <0x420f0000 0x8000>, <0x420f8000 0x8000>,
+				      <0x42100000 0x8000>, <0x42108000 0x8000>,
+				      <0x42110000 0x8000>, <0x42118000 0x8000>,
+				      <0x42120000 0x8000>, <0x42128000 0x8000>,
+				      <0x42130000 0x8000>, <0x42138000 0x8000>,
+				      <0x42140000 0x8000>, <0x42148000 0x8000>,
+				      <0x42150000 0x8000>, <0x42158000 0x8000>,
+				      <0x42160000 0x8000>, <0x42168000 0x8000>,
+				      <0x42170000 0x8000>, <0x42178000 0x8000>,
+				      <0x42180000 0x8000>, <0x42188000 0x8000>,
+				      <0x42190000 0x8000>, <0x42198000 0x8000>,
+				      <0x421a0000 0x8000>, <0x421a8000 0x8000>,
+				      <0x421b0000 0x8000>, <0x421b8000 0x8000>,
+				      <0x421c0000 0x8000>, <0x421c8000 0x8000>,
+				      <0x421d0000 0x8000>, <0x421d8000 0x8000>,
+				      <0x421e0000 0x8000>, <0x421e8000 0x8000>,
+				      <0x421f0000 0x8000>, <0x421f8000 0x8000>,
+				      <0x42200000 0x8000>, <0x42208000 0x8000>;
+				#dma-cells = <3>;
+				shared-interrupt;
+				dma-channels = <64>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "edma2-chan0-tx", "edma2-chan1-tx",
+						  "edma2-chan2-tx", "edma2-chan3-tx",
+						  "edma2-chan4-tx", "edma2-chan5-tx",
+						  "edma2-chan6-tx", "edma2-chan7-tx",
+						  "edma2-chan8-tx", "edma2-chan9-tx",
+						  "edma2-chan10-tx", "edma2-chan11-tx",
+						  "edma2-chan12-tx", "edma2-chan13-tx",
+						  "edma2-chan14-tx", "edma2-chan15-tx",
+						  "edma2-chan16-tx", "edma2-chan17-tx",
+						  "edma2-chan18-tx", "edma2-chan19-tx",
+						  "edma2-chan20-tx", "edma2-chan21-tx",
+						  "edma2-chan22-tx", "edma2-chan23-tx",
+						  "edma2-chan24-tx", "edma2-chan25-tx",
+						  "edma2-chan26-tx", "edma2-chan27-tx",
+						  "edma2-chan28-tx", "edma2-chan29-tx",
+						  "edma2-chan30-tx", "edma2-chan31-tx",
+						  "edma2-chan32-tx", "edma2-chan33-tx",
+						  "edma2-chan34-tx", "edma2-chan35-tx",
+						  "edma2-chan36-tx", "edma2-chan37-tx",
+						  "edma2-chan38-tx", "edma2-chan39-tx",
+						  "edma2-chan40-tx", "edma2-chan41-tx",
+						  "edma2-chan42-tx", "edma2-chan43-tx",
+						  "edma2-chan44-tx", "edma2-chan45-tx",
+						  "edma2-chan46-tx", "edma2-chan47-tx",
+						  "edma2-chan48-tx", "edma2-chan49-tx",
+						  "edma2-chan50-tx", "edma2-chan51-tx",
+						  "edma2-chan52-tx", "edma2-chan53-tx",
+						  "edma2-chan54-tx", "edma2-chan55-tx",
+						  "edma2-chan56-tx", "edma2-chan57-tx",
+						  "edma2-chan58-tx", "edma2-chan59-tx",
+						  "edma2-chan60-tx", "edma2-chan61-tx",
+						  "edma2-chan62-tx", "edma2-chan63-tx",
+						  "edma2-err";
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "edma";
+				fsl,edma-axi;
+				status = "okay";
+			};
+
+			edma3: dma-controller@42210000 {
+				compatible = "fsl,imx95-edma";
+				reg = <0x42210000 0x10000>,
+				      <0x42220000 0x8000>, <0x42228000 0x8000>,
+				      <0x42230000 0x8000>, <0x42238000 0x8000>,
+				      <0x42240000 0x8000>, <0x42248000 0x8000>,
+				      <0x42250000 0x8000>, <0x42258000 0x8000>,
+				      <0x42260000 0x8000>, <0x42268000 0x8000>,
+				      <0x42270000 0x8000>, <0x42278000 0x8000>,
+				      <0x42280000 0x8000>, <0x42288000 0x8000>,
+				      <0x42290000 0x8000>, <0x42298000 0x8000>,
+				      <0x422a0000 0x8000>, <0x422a8000 0x8000>,
+				      <0x422b0000 0x8000>, <0x422b8000 0x8000>,
+				      <0x422c0000 0x8000>, <0x422c8000 0x8000>,
+				      <0x422d0000 0x8000>, <0x422d8000 0x8000>,
+				      <0x422e0000 0x8000>, <0x422e8000 0x8000>,
+				      <0x422f0000 0x8000>, <0x422f8000 0x8000>,
+				      <0x42300000 0x8000>, <0x42308000 0x8000>,
+				      <0x42310000 0x8000>, <0x42318000 0x8000>,
+				      <0x42320000 0x8000>, <0x42328000 0x8000>,
+				      <0x42330000 0x8000>, <0x42338000 0x8000>,
+				      <0x42340000 0x8000>, <0x42348000 0x8000>,
+				      <0x42350000 0x8000>, <0x42358000 0x8000>,
+				      <0x42360000 0x8000>, <0x42368000 0x8000>,
+				      <0x42370000 0x8000>, <0x42378000 0x8000>,
+				      <0x42380000 0x8000>, <0x42388000 0x8000>,
+				      <0x42390000 0x8000>, <0x42398000 0x8000>,
+				      <0x423a0000 0x8000>, <0x423a8000 0x8000>,
+				      <0x423b0000 0x8000>, <0x423b8000 0x8000>,
+				      <0x423c0000 0x8000>, <0x423c8000 0x8000>,
+				      <0x423d0000 0x8000>, <0x423d8000 0x8000>,
+				      <0x423e0000 0x8000>, <0x423e8000 0x8000>,
+				      <0x423f0000 0x8000>, <0x423f8000 0x8000>,
+				      <0x42400000 0x8000>, <0x42408000 0x8000>,
+				      <0x42410000 0x8000>, <0x42418000 0x8000>;
+				#dma-cells = <3>;
+				shared-interrupt;
+				dma-channels = <64>;
+				interrupts = <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 284 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 284 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 285 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 285 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 286 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 286 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 287 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 287 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "edma3-chan0-tx", "edma3-chan1-tx",
+						  "edma3-chan2-tx", "edma3-chan3-tx",
+						  "edma3-chan4-tx", "edma3-chan5-tx",
+						  "edma3-chan6-tx", "edma3-chan7-tx",
+						  "edma3-chan8-tx", "edma3-chan9-tx",
+						  "edma3-chan10-tx", "edma3-chan11-tx",
+						  "edma3-chan12-tx", "edma3-chan13-tx",
+						  "edma3-chan14-tx", "edma3-chan15-tx",
+						  "edma3-chan16-tx", "edma3-chan17-tx",
+						  "edma3-chan18-tx", "edma3-chan19-tx",
+						  "edma3-chan20-tx", "edma3-chan21-tx",
+						  "edma3-chan22-tx", "edma3-chan23-tx",
+						  "edma3-chan24-tx", "edma3-chan25-tx",
+						  "edma3-chan26-tx", "edma3-chan27-tx",
+						  "edma3-chan28-tx", "edma3-chan29-tx",
+						  "edma3-chan30-tx", "edma3-chan31-tx",
+						  "edma3-chan32-tx", "edma3-chan33-tx",
+						  "edma3-chan34-tx", "edma3-chan35-tx",
+						  "edma3-chan36-tx", "edma3-chan37-tx",
+						  "edma3-chan38-tx", "edma3-chan39-tx",
+						  "edma3-chan40-tx", "edma3-chan41-tx",
+						  "edma3-chan42-tx", "edma3-chan43-tx",
+						  "edma3-chan44-tx", "edma3-chan45-tx",
+						  "edma3-chan46-tx", "edma3-chan47-tx",
+						  "edma3-chan48-tx", "edma3-chan49-tx",
+						  "edma3-chan50-tx", "edma3-chan51-tx",
+						  "edma3-chan52-tx", "edma3-chan53-tx",
+						  "edma3-chan54-tx", "edma3-chan55-tx",
+						  "edma3-chan56-tx", "edma3-chan57-tx",
+						  "edma3-chan58-tx", "edma3-chan59-tx",
+						  "edma3-chan60-tx", "edma3-chan61-tx",
+						  "edma3-chan62-tx", "edma3-chan63-tx";
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "edma";
+				fsl,edma-axi;
+				status = "disabled";
+			};
+
+			mu7: mailbox@42430000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x42430000 0x10000>;
+				interrupts = <GIC_SPI 234 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			flexcan2: can@425b0000 {
+				compatible = "fsl,imx95-flexcan";
+				reg = <0x425b0000 0x10000>;
+				interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_CAN2>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_CAN2>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source = /bits/ 8 <0>;
+				status = "disabled";
+			};
+
+			flexcan3: can@42600000 {
+				compatible = "fsl,imx95-flexcan";
+				reg = <0x42600000 0x10000>;
+				interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_CAN3>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_CAN3>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source = /bits/ 8 <0>;
+				status = "disabled";
+			};
+
+			mu8: mailbox@42730000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x42730000 0x10000>;
+				interrupts = <GIC_SPI 235 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			wdog3: wdog@42490000 {
+				compatible = "fsl,imx93-wdt";
+				reg = <0x42490000 0x10000>;
+				interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				timeout-sec = <40>;
+				fsl,ext-reset-output;
+				status = "disabled";
+			};
+
+			tpm3: pwm@424e0000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x424e0000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			tpm4: pwm@424f0000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x424f0000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_TPM4>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			tpm5: pwm@42500000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x42500000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_TPM5>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			tpm6: pwm@42510000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x42510000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_TPM6>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			lpi2c3: i2c@42530000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x42530000 0x10000>;
+				interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C3>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 9 0 1>, <&edma2 8 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c4: i2c@42540000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x42540000 0x10000>;
+				interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C4>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 11 0 1>, <&edma2 10 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi3: spi@42550000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x42550000 0x10000>;
+				interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI3>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 13 0 1>, <&edma2 12 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi4: spi@42560000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x42560000 0x10000>;
+				interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI4>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 15 0 1>, <&edma2 14 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart3: serial@42570000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x42570000 0x1000>;
+				interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART3>;
+				clock-names = "ipg";
+				dmas = <&edma2 18 0 1>, <&edma2 17 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart4: serial@42580000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x42580000 0x1000>;
+				interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART4>;
+				clock-names = "ipg";
+				dmas = <&edma2 20 0 1>, <&edma2 19 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart5: serial@42590000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x42590000 0x1000>;
+				interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART5>;
+				clock-names = "ipg";
+				dmas = <&edma2 22 0 1>, <&edma2 21 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart6: serial@425a0000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x425a0000 0x1000>;
+				interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART6>;
+				clock-names = "ipg";
+				dmas = <&edma2 24 0 1>, <&edma2 23 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			flexio_i2c_master: flexio@425c0000 {
+				compatible = "imx,flexio_i2c_master";
+				reg = <0x425c0000 0x10000>;
+				interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				assigned-clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				assigned-clock-rates = <24000000>;
+				status = "disabled";
+			};
+
+			flexspi1: spi@425e0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "nxp,imx95-fspi", "nxp,imx8mm-fspi";
+				reg = <0x425e0000 0x10000>, <0x28000000 0x8000000>;
+				reg-names = "fspi_base", "fspi_mmap";
+				interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_FLEXSPI1>,
+					 <&scmi_clk IMX95_CLK_FLEXSPI1>;
+				clock-names = "fspi", "fspi_en";
+				assigned-clocks = <&scmi_clk IMX95_CLK_FLEXSPI1>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1>;
+				assigned-clock-rates = <200000000>;
+				status = "disabled";
+			};
+
+			sai3: sai@42650000 {
+				compatible = "fsl,imx95-sai";
+				reg = <0x42650000 0x10000>;
+				interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>, <&dummy>,
+					 <&scmi_clk IMX95_CLK_SAI3>, <&dummy>,
+					 <&dummy>;
+				clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+				dmas = <&edma2 61 0 1>, <&edma2 60 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			sai4: sai@42660000 {
+				compatible = "fsl,imx95-sai";
+				reg = <0x42660000 0x10000>;
+				interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>, <&dummy>,
+					 <&scmi_clk IMX95_CLK_SAI4>, <&dummy>,
+					 <&dummy>;
+				clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+				dmas = <&edma2 68 0 1>, <&edma2 67 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			sai5: sai@42670000 {
+				compatible = "fsl,imx95-sai";
+				reg = <0x42670000 0x10000>;
+				interrupts = <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>, <&dummy>,
+					 <&scmi_clk IMX95_CLK_SAI5>, <&dummy>,
+					 <&dummy>;
+				clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+				dmas = <&edma2 70 0 1>, <&edma2 69 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			xcvr: xcvr@42680000 {
+				compatible = "fsl,imx95-xcvr", "fsl,imx93-xcvr";
+				reg = <0x42680000 0x800>, <0x42680800 0x400>,
+				      <0x42680c00 0x080>, <0x42680e00 0x080>;
+				reg-names = "ram", "regs", "rxfifo", "txfifo";
+				interrupts = /* XCVR IRQ 0 */
+					     <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>,
+					     /* XCVR IRQ 1 */
+					     <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_SPDIF>,
+					 <&dummy>,
+					 <&scmi_clk IMX95_CLK_AUDIOXCVR>;
+				clock-names = "ipg", "phy", "spba", "pll_ipg";
+				dmas = <&edma2 65 0 1>, <&edma2 66 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart7: serial@42690000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x42690000 0x1000>;
+				interrupts = <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART7>;
+				clock-names = "ipg";
+				dmas = <&edma2 88 0 1>, <&edma2 87 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart8: serial@426a0000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x426a0000 0x1000>;
+				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART8>;
+				clock-names = "ipg";
+				dmas = <&edma2 90 0 1>, <&edma2 89 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c5: i2c@426b0000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x426b0000 0x10000>;
+				interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C5>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 72 0 1>, <&edma2 71 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c6: i2c@426c0000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x426c0000 0x10000>;
+				interrupts = <GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C6>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 74 0 1>, <&edma2 73 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c7: i2c@426d0000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x426d0000 0x10000>;
+				interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C7>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 76 0 1>, <&edma2 75 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c8: i2c@426e0000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x426e0000 0x10000>;
+				interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C8>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 78 0 1>, <&edma2 77 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi5: spi@426f0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x426f0000 0x10000>;
+				interrupts = <GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI5>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 80 0 1>, <&edma2 79 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi6: spi@42700000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x42700000 0x10000>;
+				interrupts = <GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI6>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 82 0 1>, <&edma2 81 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi7: spi@42710000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x42710000 0x10000>;
+				interrupts = <GIC_SPI 179 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI7>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 84 0 1>, <&edma2 83 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi8: spi@42720000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x42720000 0x10000>;
+				interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI8>,
+					 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+				clock-names = "per", "ipg";
+				dmas = <&edma2 86 0 1>, <&edma2 85 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			flexcan4: can@427c0000 {
+				compatible = "fsl,imx95-flexcan";
+				reg = <0x427c0000 0x10000>;
+				interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_CAN4>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_CAN4>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source = /bits/ 8 <0>;
+				status = "disabled";
+			};
+
+			flexcan5: can@427d0000 {
+				compatible = "fsl,imx95-flexcan";
+				reg = <0x427d0000 0x10000>;
+				interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_CAN5>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_CAN5>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source = /bits/ 8 <0>;
+				status = "disabled";
+			};
+		};
+
+		aips3: bus@42800000 {
+			compatible = "fsl,aips-bus", "simple-bus";
+			reg = <0 0x42800000 0 0x800000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x42800000 0x0 0x42800000 0x800000>;
+
+			usdhc1: mmc@42850000 {
+				compatible = "fsl,imx95-usdhc", "fsl,imx8mm-usdhc";
+				reg = <0x42850000 0x10000>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_WAKEUPAXI>,
+					 <&scmi_clk IMX95_CLK_USDHC1>;
+				clock-names = "ipg", "ahb", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_USDHC1>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1>;
+				assigned-clock-rates = <400000000>;
+				bus-width = <8>;
+				fsl,tuning-start-tap = <1>;
+				fsl,tuning-step= <2>;
+				status = "disabled";
+			};
+
+			usdhc2: mmc@42860000 {
+				compatible = "fsl,imx95-usdhc", "fsl,imx8mm-usdhc";
+				reg = <0x42860000 0x10000>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_WAKEUPAXI>,
+					 <&scmi_clk IMX95_CLK_USDHC2>;
+				clock-names = "ipg", "ahb", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_USDHC2>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1>;
+				assigned-clock-rates = <200000000>;
+				bus-width = <4>;
+				fsl,tuning-start-tap = <1>;
+				fsl,tuning-step= <2>;
+				status = "disabled";
+			};
+
+			usdhc3: mmc@428b0000 {
+				compatible = "fsl,imx95-usdhc", "fsl,imx8mm-usdhc";
+				reg = <0x428b0000 0x10000>;
+				interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+					 <&scmi_clk IMX95_CLK_WAKEUPAXI>,
+					 <&scmi_clk IMX95_CLK_USDHC3>;
+				clock-names = "ipg", "ahb", "per";
+				bus-width = <4>;
+				fsl,tuning-start-tap = <1>;
+				fsl,tuning-step= <2>;
+				status = "disabled";
+			};
+		};
+
+		gpio2: gpio@43810000 {
+			compatible = "fsl,imx95-gpio", "fsl,imx8ulp-gpio";
+			reg = <0x0 0x43810000 0x0 0x1000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+				 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+			clock-names = "gpio", "port";
+			gpio-ranges = <&scmi_iomuxc 0 4 32>;
+		};
+
+		gpio3: gpio@43820000 {
+			compatible = "fsl,imx95-gpio", "fsl,imx8ulp-gpio";
+			reg = <0x0 0x43820000 0x0 0x1000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+				 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+			clock-names = "gpio", "port";
+			gpio-ranges = <&scmi_iomuxc 0 104 8>, <&scmi_iomuxc 8 74 18>,
+				      <&scmi_iomuxc 26 42 2>, <&scmi_iomuxc 28 0 4>;
+		};
+
+		gpio4: gpio@43840000 {
+			compatible = "fsl,imx95-gpio", "fsl,imx8ulp-gpio";
+			reg = <0x0 0x43840000 0x0 0x1000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+				 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+			clock-names = "gpio", "port";
+			gpio-ranges = <&scmi_iomuxc 0 46 28>, <&scmi_iomuxc 28 44 2>;
+		};
+
+		gpio5: gpio@43850000 {
+			compatible = "fsl,imx95-gpio", "fsl,imx8ulp-gpio";
+			reg = <0x0 0x43850000 0x0 0x1000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			clocks = <&scmi_clk IMX95_CLK_BUSWAKEUP>,
+				 <&scmi_clk IMX95_CLK_BUSWAKEUP>;
+			clock-names = "gpio", "port";
+			gpio-ranges = <&scmi_iomuxc 0 92 12>, <&scmi_iomuxc 12 36 6>;
+		};
+
+		aips1: bus@44000000 {
+			compatible = "fsl,aips-bus", "simple-bus";
+			reg = <0x0 0x44000000 0x0 0x800000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x44000000 0x0 0x44000000 0x800000>;
+
+			edma1: dma-controller@44000000 {
+				compatible = "fsl,imx93-edma";
+				reg = <0x44000000 0x10000>,
+				      <0x44010000 0x10000>, <0x44020000 0x10000>,
+				      <0x44030000 0x10000>, <0x44040000 0x10000>,
+				      <0x44050000 0x10000>, <0x44060000 0x10000>,
+				      <0x44070000 0x10000>, <0x44080000 0x10000>,
+				      <0x44090000 0x10000>, <0x440a0000 0x10000>,
+				      <0x440b0000 0x10000>, <0x440c0000 0x10000>,
+				      <0x440d0000 0x10000>, <0x440e0000 0x10000>,
+				      <0x440f0000 0x10000>, <0x44100000 0x10000>,
+				      <0x44110000 0x10000>, <0x44120000 0x10000>,
+				      <0x44130000 0x10000>, <0x44140000 0x10000>,
+				      <0x44150000 0x10000>, <0x44160000 0x10000>,
+				      <0x44170000 0x10000>, <0x44180000 0x10000>,
+				      <0x44190000 0x10000>, <0x441a0000 0x10000>,
+				      <0x441b0000 0x10000>, <0x441c0000 0x10000>,
+				      <0x441d0000 0x10000>, <0x441e0000 0x10000>,
+				      <0x441f0000 0x10000>;
+				#dma-cells = <3>;
+				dma-channels = <31>;
+				interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "edma1-chan0-tx", "edma1-chan1-tx",
+						  "edma1-chan2-tx", "edma1-chan3-tx",
+						  "edma1-chan4-tx", "edma1-chan5-tx",
+						  "edma1-chan6-tx", "edma1-chan7-tx",
+						  "edma1-chan8-tx", "edma1-chan9-tx",
+						  "edma1-chan10-tx", "edma1-chan11-tx",
+						  "edma1-chan12-tx", "edma1-chan13-tx",
+						  "edma1-chan14-tx", "edma1-chan15-tx",
+						  "edma1-chan16-tx", "edma1-chan17-tx",
+						  "edma1-chan18-tx", "edma1-chan19-tx",
+						  "edma1-chan20-tx", "edma1-chan21-tx",
+						  "edma1-chan22-tx", "edma1-chan23-tx",
+						  "edma1-chan24-tx", "edma1-chan25-tx",
+						  "edma1-chan26-tx", "edma1-chan27-tx",
+						  "edma1-chan28-tx", "edma1-chan29-tx",
+						  "edma1-chan30-tx", "edma1-err";
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				clock-names = "edma";
+				status = "okay";
+			};
+
+			mu1: mailbox@44220000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x44220000 0x10000>;
+				interrupts = <GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			flexcan1: can@443a0000 {
+				compatible = "fsl,imx95-flexcan";
+				reg = <0x443a0000 0x10000>;
+				interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>,
+					 <&scmi_clk IMX95_CLK_CAN1>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&scmi_clk IMX95_CLK_CAN1>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source = /bits/ 8 <0>;
+				status = "disabled";
+			};
+
+			sai1: sai@443b0000 {
+				compatible = "fsl,imx95-sai";
+				reg = <0x443b0000 0x10000>;
+				interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>, <&dummy>,
+					 <&scmi_clk IMX95_CLK_SAI1>, <&dummy>,
+					 <&dummy>;
+				clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+				dmas = <&edma1 25 0 1>, <&edma1 24 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			micfil: micfil@44520000 {
+				compatible = "fsl,imx95-micfil", "fsl,imx93-micfil";
+				reg = <0x44520000 0x10000>;
+				interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>,
+					 <&scmi_clk IMX95_CLK_PDM>,
+					 <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+					 <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+					 <&dummy>;
+				clock-names = "ipg_clk", "ipg_clk_app",
+					      "pll8k", "pll11k", "clkext3";
+				dmas = <&edma1 6 0 5>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+
+			mu2: mailbox@445b0000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x445b0000 0x1000>;
+				interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
+				/*clocks = <&scmi_clk IMX95_CLK_BUSAON>;*/
+				#mbox-cells = <2>;
+			};
+
+			mu3: mailbox@445d0000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x445d0000 0x10000>;
+				interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			mu4: mailbox@445f0000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x445f0000 0x10000>;
+				interrupts = <GIC_SPI 230 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			mu6: mailbox@44630000 {
+				compatible = "fsl,imx95-mu", "fsl,imx8ulp-mu";
+				reg = <0x44630000 0x10000>;
+				interrupts = <GIC_SPI 206 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				#mbox-cells = <2>;
+				status = "disabled";
+			};
+
+			system_counter: timer@44290000 {
+				compatible = "nxp,imx95-sysctr-timer", "nxp,sysctr-timer";
+				reg = <0x44290000 0x30000>;
+				interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&osc_24m>;
+				clock-names = "per";
+				nxp,no-divider;
+			};
+
+			tpm1: pwm@44310000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x44310000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_BUSAON>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			tpm2: pwm@44320000 {
+				compatible = "fsl,imx7ulp-pwm";
+				reg = <0x44320000 0x1000>;
+				clocks = <&scmi_clk IMX95_CLK_TPM2>;
+				assigned-clocks = <&scmi_clk IMX95_CLK_TPM2>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_24M>;
+				assigned-clock-rates = <24000000>;
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			lpi2c1: i2c@44340000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x44340000 0x10000>;
+				interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C1>,
+					 <&scmi_clk IMX95_CLK_BUSAON>;
+				clock-names = "per", "ipg";
+				dmas = <&edma1 13 0 1>, <&edma1 12 0 0> ;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpi2c2: i2c@44350000 {
+				compatible = "fsl,imx95-lpi2c", "fsl,imx7ulp-lpi2c";
+				reg = <0x44350000 0x10000>;
+				interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPI2C2>,
+					 <&scmi_clk IMX95_CLK_BUSAON>;
+				clock-names = "per", "ipg";
+				dmas = <&edma1 15 0 1>, <&edma1 14 0 0> ;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi1: spi@44360000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x44360000 0x10000>;
+				interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI1>,
+					 <&scmi_clk IMX95_CLK_BUSAON>;
+				clock-names = "per", "ipg";
+				dmas = <&edma1 17 0 1>, <&edma1 16 0 0> ;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpspi2: spi@44370000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx95-spi", "fsl,imx7ulp-spi";
+				reg = <0x44370000 0x10000>;
+				interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPSPI2>,
+					 <&scmi_clk IMX95_CLK_BUSAON>;
+				clock-names = "per", "ipg";
+				dmas = <&edma1 19 0 1>, <&edma1 18 0 0> ;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart1: serial@44380000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x44380000 0x1000>;
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART1>;
+				clock-names = "ipg";
+				dmas = <&edma1 21 0 1>, <&edma1 20 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			lpuart2: serial@44390000 {
+				compatible = "fsl,imx95-lpuart", "fsl,imx8ulp-lpuart",
+					     "fsl,imx7ulp-lpuart";
+				reg = <0x44390000 0x1000>;
+				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_LPUART2>;
+				clock-names = "ipg";
+				dmas = <&edma1 23 0 1>, <&edma1 22 0 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			adc1: adc@44530000 {
+				compatible = "nxp,imx93-adc";
+				reg = <0x44530000 0x10000>;
+				interrupts = <GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+						<GIC_SPI 201 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&scmi_clk IMX95_CLK_ADC>;
+				clock-names = "ipg";
+				status = "disabled";
+			};
+
+		};
+
+		aips4: bus@49000000 {
+			compatible = "fsl,aips-bus", "simple-bus";
+			reg = <0x0 0x49000000 0x0 0x800000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x49000000 0x0 0x49000000 0x800000>;
+
+			smmu: iommu@490d0000 {
+				compatible = "arm,smmu-v3";
+				reg = <0x490d0000 0x100000>;
+				interrupts = <GIC_SPI 325 IRQ_TYPE_EDGE_RISING>,
+					     <GIC_SPI 328 IRQ_TYPE_EDGE_RISING>,
+					     <GIC_SPI 334 IRQ_TYPE_EDGE_RISING>,
+					     <GIC_SPI 326 IRQ_TYPE_EDGE_RISING>;
+				interrupt-names = "eventq", "gerror", "priq", "cmdq-sync";
+				#iommu-cells = <1>;
+			};
+		};
+
+		gpio1: gpio@47400000 {
+			compatible = "fsl,imx95-gpio", "fsl,imx8ulp-gpio";
+			reg = <0x0 0x47400000 0x0 0x1000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			clocks = <&scmi_clk IMX95_CLK_M33>,
+				 <&scmi_clk IMX95_CLK_M33>;
+			clock-names = "gpio", "port";
+			gpio-ranges = <&scmi_iomuxc 0 112 16>;
+			status = "disabled";
+		};
+
+		ocotp: efuse@47510000 {
+			compatible = "fsl,imx95-ocotp";
+			reg = <0x0 0x47510000 0x0 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			eth_mac0: mac-address@0 {
+				reg = <0x0514 0x6>;
+			};
+
+			eth_mac1: mac-address@1 {
+				reg = <0x1514 0x6>;
+			};
+
+			eth_mac2: mac-address@2 {
+				reg = <0x2514 0x6>;
+			};
+		};
+
+		elemu0: mailbox@47520000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47520000 0x0 0x10000>;
+			interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		elemu1: mailbox@47530000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47530000 0x0 0x10000>;
+			interrupts = <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		elemu2: mailbox@47540000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47540000 0x0 0x10000>;
+			interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		elemu3: mailbox@47550000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47550000 0x0 0x10000>;
+			interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+		};
+
+		elemu4: mailbox@47560000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47560000 0x0 0x10000>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		elemu5: mailbox@47570000 {
+			compatible = "fsl,imx95-mu-ele";
+			reg = <0x0 0x47570000 0x0 0x10000>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		v2x_mu: v2x-mu@47350000 {
+			compatible = "fsl,imx95-mu-v2x";
+			reg = <0x0 0x47350000 0x0 0x10000>;
+			interrupts = <GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			#mbox-cells = <2>;
+			status = "okay";
+		};
+
+		v2x_mu4: mailbox@47300000 {
+			compatible = "fsl,imx95-mu-v2x";
+			reg = <0x0 0x47300000 0x0 0x10000>;
+			interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			#mbox-cells = <2>;
+			status = "okay";
+		};
+
+		v2x_mu6: mailbox@47320000 {
+			compatible = "fsl,imx95-mu-v2x";
+			reg = <0x0 0x47320000 0x0 0x10000>;
+			interrupts = <GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "tx", "rx";
+			#mbox-cells = <2>;
+			status = "okay";
+		};
+
+		cameramix_csr: syscon@4ac10000 {
+			compatible = "fsl,imx95-cameramix-csr", "syscon";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x0 0x4ac10000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+
+			csi_pixel_formatter_0: formatter@20 {
+				compatible = "fsl,imx95-csi-formatter";
+				reg = <0x20 0x100>;
+				clocks = <&cameramix_csr IMX95_CLK_CAMBLK_CSI2_FOR0>;
+				power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+				status = "disabled";
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+					};
+
+					port@1 {
+						reg = <1>;
+					};
+				};
+			};
+
+			csi_pixel_formatter_1: formatter@120 {
+				compatible = "fsl,imx95-csi-formatter";
+				reg = <0x120 0x100>;
+				clocks = <&cameramix_csr IMX95_CLK_CAMBLK_CSI2_FOR1>;
+				power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+				status = "disabled";
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+					};
+
+					port@1 {
+						reg = <1>;
+					};
+				};
+			};
+		};
+
+		neoisp0: isp@4ae00000 {
+			compatible = "nxp,imx95-a0-neoisp";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x4ae00000 0x0 0x8000>,
+			      <0x0 0x4afe0000 0x0 0x10000>;
+			reg-names = "registers", "stats";
+			interrupts = <GIC_SPI 222 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&gic>;
+			clocks = <&cameramix_csr IMX95_CLK_CAMBLK_ISP_AXI>,
+				 <&cameramix_csr IMX95_CLK_CAMBLK_ISP_PIXEL>,
+				 <&cameramix_csr IMX95_CLK_CAMBLK_ISP>;
+			clock-names = "camblk_isp_axi", "camblk_isp_pixel", "camblk_isp";
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			nxp,blk-ctrl = <&cameramix_csr>;
+			status = "disabled";
+		};
+
+		cameramix_mu1: mailbox@4ac60000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4ac60000 0x0 0x10000>;
+			interrupts = <GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu2: mailbox@4ac70000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4ac70000 0x0 0x10000>;
+			interrupts = <GIC_SPI 336 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu3: mailbox@4ac80000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4ac80000 0x0 0x10000>;
+			interrupts = <GIC_SPI 337 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu4: mailbox@4ac90000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4ac90000 0x0 0x10000>;
+			interrupts = <GIC_SPI 338 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu5: mailbox@4aca0000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4aca0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 339 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu6: mailbox@4acb0000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4acb0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 340 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu7: mailbox@4acc0000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4acc0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 341 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu8: mailbox@4acd0000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4acd0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 342 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		cameramix_mu9: mailbox@4ace0000 {
+			compatible = "fsl,imx95-mu-isp";
+			reg = <0x0 0x4ace0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 343 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+		};
+
+		ocram_c_config: syscon@4add0000 {
+			compatible = "fsl,imx95-ocram-config", "syscon";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x0 0x4add0000 0x0 0x10000>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+
+			interrupt-parent = <&gic>;
+			interrupts =
+				<GIC_SPI 251 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 252 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		ocram_c: ocram@4af80000 {
+			reg = <0x0 0x4af80000 0x0 0x18000>;
+			no-map;
+		};
+
+		isp_fw_core: remoteproc {
+			compatible = "nxp,imx95-isp-rproc";
+			nxp,blk-ctrl = <&cameramix_csr>;
+			nxp,ocram-cfg = <&ocram_c_config>;
+			nxp,isp-firmware = "imx9xm0p_isp_fw.bin";
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+
+			mba {
+				memory-region = <&ocram_c>;
+				ocram-map = <0x0 0x14000>;
+			};
+		};
+
+		mipi_dsi: dsi@4acf0000 {
+			compatible = "nxp,imx95-mipi-dsi";
+			reg = <0x0 0x4acf0000 0x0 0x10000>;
+			interrupt-parent = <&displaymix_irqsteer>;
+			interrupts = <48>;
+			clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>,
+				 <&scmi_clk IMX95_CLK_MIPIPHYPLLBYPASS>,
+				 <&scmi_clk IMX95_CLK_MIPIPHYPLLREF>,
+				 <&scmi_clk IMX95_CLK_CAMAPB>,
+				 <&scmi_clk IMX95_CLK_DISP1PIX>;
+			clock-names = "cfg", "bypass", "ref", "pclk", "pix";
+			assigned-clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>,
+					  <&scmi_clk IMX95_CLK_MIPIPHYPLLBYPASS>,
+					  <&scmi_clk IMX95_CLK_MIPIPHYPLLREF>;
+			assigned-clock-parents = <&scmi_clk IMX95_CLK_24M>,
+						 <&scmi_clk IMX95_CLK_VIDEOPLL1>,
+						 <&scmi_clk IMX95_CLK_24M>;
+			mux-controls = <&mux 0>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			nxp,disp-master-csr = <&display_master_csr>;
+			nxp,disp-stream-csr = <&display_stream_csr>;
+			nxp,mipi-combo-phy-csr = <&mipi_tx_phy_csr>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					mipi_dsi_to_display_pixel_link0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&display_pixel_link0_to_mipi_dsi>;
+					};
+
+					mipi_dsi_to_display_pixel_link1: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&display_pixel_link1_to_mipi_dsi>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		display_stream_csr: syscon@4ad00000 {
+			compatible = "nxp,imx95-display-stream-csr", "syscon", "simple-mfd";
+			reg = <0x0 0x4ad00000 0x0 0x10000>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+		};
+
+		display_master_csr: syscon@4ad10000 {
+			compatible = "fsl,imx95-display-master-csr", "syscon";
+			reg = <0x0 0x4ad10000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+
+			mux: mux-controller {
+				compatible = "mmio-mux";
+				#mux-control-cells = <1>;
+				mux-reg-masks = <0x4 0x00000001>; /* Pixel_link_sel */
+				idle-states = <0>;
+			};
+		};
+
+		mipi_dsi_intf: syscon@4acf0000 {
+			compatible = "syscon", "simple-mfd";
+			reg = <0x0 0x4acf0000 0x0 0x10000>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+			status = "disabled";
+		};
+
+		combo_phy_csr: syscon@4ad20000 {
+			compatible = "syscon", "simple-mfd";
+			reg = <0x0 0x4ad20000 0x0 0x114>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+
+			dphy_rx: dphy-rx {
+				compatible = "fsl,imx95-dphy-rx";
+				clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>;
+				clock-names = "phy_cfg";
+				assigned-clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_24M>;
+				assigned-clock-rate = <24000000>;
+				#phy-cells = <0>;
+				fsl,csis = <&mipi_csi0>;
+				power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+				status = "disabled";
+			};
+
+			combo_rx: combo-rx {
+				compatible = "fsl,imx95-combo-rx";
+				clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>;
+				clock-names = "phy_cfg";
+				assigned-clocks = <&scmi_clk IMX95_CLK_MIPIPHYCFG>;
+				assigned-clock-parents = <&scmi_clk IMX95_CLK_24M>;
+				assigned-clock-rate = <24000000>;
+				#phy-cells = <0>;
+				fsl,reg-offset = <0x100>;
+				fsl,csis = <&mipi_csi1>;
+				fsl,dsi = <&mipi_dsi_intf>;
+				power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+				status = "disabled";
+			};
+
+		};
+
+		mipi_tx_phy_csr: syscon@4ad20100 {
+			compatible = "fsl,imx95-mipi-tx-phy-csr", "syscon";
+			reg = <0x0 0x4ad20100 0x0 0x14>;
+			clocks = <&scmi_clk IMX95_CLK_CAMAPB>;
+		};
+
+		mipi_csi0: csi@4ad30000 {
+			compatible = "snps,dw-mipi-csi2", "syscon";
+			reg = <0x0 0x4ad30000 0x0 0x10000>;
+			interrupts = <GIC_SPI 374 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cameramix_csr IMX95_CLK_CAMBLK_CSI2_FOR0>,
+				 <&scmi_clk IMX95_CLK_CAMAPB>;
+			clock-names = "per", "pixel";
+			phys = <&dphy_rx>;
+			phy-names = "dphy-rx";
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		mipi_csi1: csi@4ad40000 {
+			compatible = "snps,dw-mipi-csi2", "syscon";
+			reg = <0x0 0x4ad40000 0x0 0x10000>;
+			interrupts = <GIC_SPI 375 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cameramix_csr IMX95_CLK_CAMBLK_CSI2_FOR1>,
+				 <&scmi_clk IMX95_CLK_CAMAPB>;
+			clock-names = "per", "pixel";
+			phys = <&combo_rx>;
+			phy-names = "dphy-rx";
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		isi: isi@4ad50000 {
+			compatible = "nxp,imx95-isi";
+			reg = <0x0 0x4ad50000 0x0 0x80000>;
+			interrupts = <GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 344 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 345 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 346 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 347 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 348 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 349 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 350 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_CAMISI>;
+			clock-names = "axi";
+			fsl,blk-ctrl = <&cameramix_csr>;
+			power-domains = <&scmi_devpd IMX95_PD_CAMERA>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+
+				port@2 {
+					reg = <2>;
+				};
+
+				port@3 {
+					reg = <3>;
+				};
+			};
+		};
+
+		dispmix_csr: syscon@4b010000 {
+			compatible = "fsl,imx95-dispmix-csr", "syscon";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x0 0x4b010000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+			assigned-clocks = <&scmi_clk IMX95_CLK_DISPAXI>,
+					  <&scmi_clk IMX95_CLK_DISPOCRAM>,
+					  <&scmi_clk IMX95_CLK_DISPAPB>;
+			assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD1>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+			assigned-clock-rates = <400000000>, <400000000>, <133333333>;
+
+			display_pixel_link: bridge@8 {
+				compatible = "nxp,imx95-dc-pixel-link";
+				reg = <0x8 0x4>;
+				status = "disabled";
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+
+						display_pixel_link0_to_pixel_interleaver_disp0: endpoint {
+							remote-endpoint = <&pixel_interleaver_disp0_to_display_pixel_link0>;
+						};
+					};
+
+					port@1 {
+						reg = <1>;
+
+						display_pixel_link1_to_pixel_interleaver_disp1: endpoint {
+							remote-endpoint = <&pixel_interleaver_disp1_to_display_pixel_link1>;
+						};
+					};
+
+					port@2 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						reg = <2>;
+
+						display_pixel_link0_to_mipi_dsi: endpoint@0 {
+							reg = <0>;
+							remote-endpoint = <&mipi_dsi_to_display_pixel_link0>;
+						};
+
+						display_pixel_link0_to_ldb_ch0: endpoint@1 {
+							reg = <1>;
+							remote-endpoint = <&ldb_ch0_to_display_pixel_link0>;
+						};
+					};
+
+					port@3 {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						reg = <3>;
+
+						display_pixel_link1_to_mipi_dsi: endpoint@1 {
+							reg = <1>;
+							remote-endpoint = <&mipi_dsi_to_display_pixel_link1>;
+						};
+
+						display_pixel_link1_to_ldb_ch1: endpoint@0 {
+							reg = <0>;
+							remote-endpoint = <&ldb_ch1_to_display_pixel_link1>;
+						};
+					};
+				};
+			};
+		};
+
+		displaymix_irqsteer: interrupt-controller@4b0b0000 {
+			compatible = "fsl,imx-irqsteer";
+			reg = <0x0 0x4b0b0000 0x0 0x1000>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 303 IRQ_TYPE_LEVEL_HIGH>,	/* reserved */
+				     <GIC_SPI 303 IRQ_TYPE_LEVEL_HIGH>,	/* reserved */
+				     <GIC_SPI 219 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+			clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+			clock-names = "ipg";
+			fsl,channel = <0>;
+			fsl,num-irqs = <512>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			status = "disabled";
+		};
+
+		lvds_csr: syscon@4b0c0000 {
+			compatible = "fsl,imx95-dispmix-lvds-csr", "syscon";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x0 0x4b0c0000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+
+			ldb: ldb@4 {
+				compatible = "fsl,imx95-ldb";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x4 0x4>;
+				clocks = <&lvds_csr IMX95_CLK_DISPMIX_PIX_DI0_GATE>,
+					 <&lvds_csr IMX95_CLK_DISPMIX_PIX_DI1_GATE>,
+					 <&lvds_csr IMX95_CLK_DISPMIX_LVDS_CH0_GATE>,
+					 <&lvds_csr IMX95_CLK_DISPMIX_LVDS_CH1_GATE>;
+				clock-names = "ldb_di0", "ldb_di1", "ldb_ch0", "ldb_ch1";
+				status = "disabled";
+
+				channel@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+					phys = <&ldb0_phy1>;
+					phy-names = "lvds_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch0_to_display_pixel_link0: endpoint {
+							remote-endpoint = <&display_pixel_link0_to_ldb_ch0>;
+						};
+					};
+
+					port@1 {
+						reg = <1>;
+					};
+				};
+
+				channel@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+					phys = <&ldb1_phy1>;
+					phy-names = "lvds_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch1_to_display_pixel_link1: endpoint {
+							remote-endpoint = <&display_pixel_link1_to_ldb_ch1>;
+						};
+					};
+
+					port@1 {
+						reg = <1>;
+					};
+				};
+			};
+
+			ldb0_phy: phy@8 {
+				compatible = "fsl,imx95-lvds0-phy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x8 0x4>;
+				gpr = <&lvds_csr>;
+				clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+				clock-names = "apb";
+				power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+				status = "disabled";
+
+				ldb0_phy1: port@0 {
+					reg = <0>;
+					#phy-cells = <0>;
+				};
+			};
+
+			ldb1_phy: phy@c {
+				compatible = "fsl,imx95-lvds1-phy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0xc 0x4>;
+				gpr = <&lvds_csr>;
+				clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+				clock-names = "apb";
+				power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+				status = "disabled";
+
+				ldb1_phy1: port@0 {
+					reg = <0>;
+					#phy-cells = <0>;
+				};
+			};
+		};
+
+		pixel_interleaver: bridge@4b0d0000 {
+			compatible = "nxp,imx95-pixel-interleaver";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x4b0d0000 0x0 0x20000>;
+			interrupt-parent = <&displaymix_irqsteer>;
+			interrupts = <62>;
+			clocks = <&scmi_clk IMX95_CLK_DISPAPB>;
+			nxp,blk-ctrl = <&dispmix_csr>;
+			status = "disabled";
+
+			channel@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0>;
+				status = "disabled";
+
+				port@0 {
+					reg = <0>;
+
+					pixel_interleaver_disp0_to_dpu_disp0: endpoint {
+						remote-endpoint = <&dpu_disp0_to_pixel_interleaver_disp0>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+
+					pixel_interleaver_disp0_to_display_pixel_link0: endpoint {
+						remote-endpoint = <&display_pixel_link0_to_pixel_interleaver_disp0>;
+					};
+				};
+			};
+
+			channel@1 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <1>;
+				status = "disabled";
+
+				port@0 {
+					reg = <0>;
+
+					pixel_interleaver_disp1_to_dpu_disp1: endpoint {
+						remote-endpoint = <&dpu_disp1_to_pixel_interleaver_disp1>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+
+					pixel_interleaver_disp1_to_display_pixel_link1: endpoint {
+						remote-endpoint = <&display_pixel_link1_to_pixel_interleaver_disp1>;
+					};
+				};
+			};
+		};
+
+		dpu: display-controller@4b400000 {
+			compatible = "nxp,imx95-dpu";
+			reg = <0x0 0x4b400000 0x0 0x400000>;
+			interrupt-parent = <&displaymix_irqsteer>;
+			interrupts = <448>, <449>, <450>,  <64>,
+				      <65>,  <66>,  <67>,  <68>,
+				      <69>, <192>, <193>, <194>,
+				     <195>, <196>, <197>,  <70>,
+				      <71>,  <72>,  <73>,  <74>,
+				      <75>,  <76>,  <77>,  <78>,
+				      <79>,  <80>,  <81>,  <82>,
+				      <83>,  <84>,  <85>,  <86>,
+				      <87>,  <88>,  <89>,  <90>,
+				      <91>,  <92>, <198>, <199>,
+				     <200>, <201>, <202>, <203>,
+				     <204>, <205>, <206>, <207>,
+				     <208>, <209>, <210>, <211>,
+				     <212>, <451>,   <1>,   <2>,
+				       <3>,   <4>,  <93>,  <94>,
+				      <95>,  <96>,  <97>,  <98>,
+				      <99>, <100>, <101>, <102>,
+				     <103>, <104>, <105>, <106>,
+				     <213>, <214>, <215>, <216>,
+				     <217>, <218>, <219>, <220>,
+				     <221>, <222>, <223>, <224>,
+				     <225>, <226>;
+			interrupt-names = "store9_shdload",
+					  "store9_framecomplete",
+					  "store9_seqcomplete",
+					  "extdst0_shdload",
+					  "extdst0_framecomplete",
+					  "extdst0_seqcomplete",
+					  "extdst4_shdload",
+					  "extdst4_framecomplete",
+					  "extdst4_seqcomplete",
+					  "extdst1_shdload",
+					  "extdst1_framecomplete",
+					  "extdst1_seqcomplete",
+					  "extdst5_shdload",
+					  "extdst5_framecomplete",
+					  "extdst5_seqcomplete",
+					  "domainblend0_shdload",
+					  "domainblend0_framecomplete",
+					  "domainblend0_seqcomplete",
+					  "disengcfg_shdload0",
+					  "disengcfg_framecomplete0",
+					  "disengcfg_seqcomplete0",
+					  "framegen0_int0",
+					  "framegen0_int1",
+					  "framegen0_int2",
+					  "framegen0_int3",
+					  "sig0_shdload",
+					  "sig0_valid",
+					  "sig0_error",
+					  "sig0_cluster_error",
+					  "sig0_cluster_match",
+					  "sig2_shdload",
+					  "sig2_valid",
+					  "sig2_error",
+					  "sig2_cluster_error",
+					  "sig2_cluster_match",
+					  "idhash0_shdload",
+					  "idhash0_valid",
+					  "idhash0_window_error",
+					  "domainblend1_shdload",
+					  "domainblend1_framecomplete",
+					  "domainblend1_seqcomplete",
+					  "disengcfg_shdload1",
+					  "disengcfg_framecomplete1",
+					  "disengcfg_seqcomplete1",
+					  "framegen1_int0",
+					  "framegen1_int1",
+					  "framegen1_int2",
+					  "framegen1_int3",
+					  "sig1_shdload",
+					  "sig1_valid",
+					  "sig1_error",
+					  "sig1_cluster_error",
+					  "sig1_cluster_match",
+					  "cmdseq_error",
+					  "comctrl_sw0",
+					  "comctrl_sw1",
+					  "comctrl_sw2",
+					  "comctrl_sw3",
+					  "framegen0_primsync_on",
+					  "framegen0_primsync_off",
+					  "framegen0_overflow0_on",
+					  "framegen0_overflow0_off",
+					  "framegen0_underrun0_on",
+					  "framegen0_underrun0_off",
+					  "framegen0_threshold0_rise",
+					  "framegen0_threshold0_fail",
+					  "framegen0_overflow1_on",
+					  "framegen0_overflow1_off",
+					  "framegen0_underrun1_on",
+					  "framegen0_underrun1_off",
+					  "framegen0_threshold1_rise",
+					  "framegen0_threshold1_fail",
+					  "framegen1_primsync_on",
+					  "framegen1_primsync_off",
+					  "framegen1_overflow0_on",
+					  "framegen1_overflow0_off",
+					  "framegen1_underrun0_on",
+					  "framegen1_underrun0_off",
+					  "framegen1_threshold0_rise",
+					  "framegen1_threshold0_fail",
+					  "framegen1_overflow1_on",
+					  "framegen1_overflow1_off",
+					  "framegen1_underrun1_on",
+					  "framegen1_underrun1_off",
+					  "framegen1_threshold1_rise",
+					  "framegen1_threshold1_fail";
+			clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+				 <&scmi_clk IMX95_CLK_DISPAPB>,
+				 <&scmi_clk IMX95_CLK_DISPAXI>,
+				 <&scmi_clk IMX95_CLK_DISPOCRAM>,
+				 <&ldb_pll_pixel>,
+				 <&scmi_clk IMX95_CLK_LDBPLL_VCO>;
+			clock-names = "pix", "apb", "axi", "ocram", "ldb", "ldb_vco";
+			power-domains = <&scmi_devpd IMX95_PD_DISPLAY>;
+			nxp,blk-ctrl = <&dispmix_csr>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+
+					dpu_disp0_to_pixel_interleaver_disp0: endpoint {
+						remote-endpoint = <&pixel_interleaver_disp0_to_dpu_disp0>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+
+					dpu_disp1_to_pixel_interleaver_disp1: endpoint {
+						remote-endpoint = <&pixel_interleaver_disp1_to_dpu_disp1>;
+					};
+				};
+			};
+		};
+
+		usb3_phy: phy@4c1f0040 {
+			compatible = "fsl,imx95-usb-phy";
+			reg = <0x0 0x4c1f0040 0x0 0x40>,
+			      <0x0 0x4c1fc000 0x0 0x100>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>;
+			clock-names = "phy";
+			#phy-cells = <0>;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			orientation-switch;
+			status = "disabled";
+		};
+
+		usb3: usb@4c010010 {
+			compatible = "fsl,imx95-dwc3", "fsl,imx8mp-dwc3";
+			reg = <0x0 0x4c010010 0x0 0x04>,
+			      <0x0 0x4c1f0000 0x0 0x20>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>,
+				 <&scmi_clk IMX95_CLK_32K>;
+			clock-names = "hsio", "suspend";
+			interrupts = <GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			dma-ranges = <0x0 0x0 0x0 0x0 0x10 0x0>;
+			status = "disabled";
+
+			usb3_dwc3: usb@4c100000 {
+				compatible = "snps,dwc3";
+				reg = <0x0 0x4c100000 0x0 0x10000>;
+				clocks = <&scmi_clk IMX95_CLK_HSIO>,
+					 <&scmi_clk IMX95_CLK_24M>,
+					 <&scmi_clk IMX95_CLK_32K>;
+				clock-names = "bus_early", "ref", "suspend";
+				interrupts = <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>;
+				phys = <&usb3_phy>, <&usb3_phy>;
+				phy-names = "usb2-phy", "usb3-phy";
+				snps,gfladj-refclk-lpm-sel-quirk;
+				snps,parkmode-disable-ss-quirk;
+				snps,tx-max-burst = /bits/ 8 <4>;
+				snps,tx-thr-num-pkt = /bits/ 8 <1>;
+				iommus = <&smmu 0xe>;
+			};
+		};
+
+		usb2: usb@4c200000 {
+			compatible = "fsl,imx95-usb", "fsl,imx7d-usb";
+			reg = <0x0 0x4c200000 0x0 0x200>;
+			interrupts = <GIC_SPI 176 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>,
+				 <&scmi_clk IMX95_CLK_32K>;
+			clock-names = "usb1_ctrl_root_clk", "usb_wakeup_clk";
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			phys = <&usbphynop>;
+			fsl,usbmisc = <&usbmisc 0>;
+			iommus = <&smmu 0xf>;
+			status = "disabled";
+		};
+
+		usbmisc: usbmisc@4c200200 {
+			compatible = "fsl,imx95-usbmisc", "fsl,imx7d-usbmisc";
+			#index-cells = <1>;
+			reg = <0x0 0x4c200200 0x0 0x200>,
+			      <0x0 0x4c010014 0x0 0x04>;
+		};
+
+		hsio_blk_ctrl: syscon@4c0100c0 {
+			compatible = "fsl,imx95-hsio-blk-ctrl", "syscon";
+			reg = <0x0 0x4c0100c0 0x0 0x1>;
+			#clock-cells = <1>;
+			clocks = <&dummy>;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+		};
+
+		pcie0: pcie@4c300000 {
+			compatible = "fsl,imx95-pcie";
+			reg = <0 0x4c300000 0 0x10000>,
+			      <0 0x4c360000 0 0x20000>,
+			      <0 0x60100000 0 0xfe00000>;
+			reg-names = "dbi", "atu", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			linux,pci-domain = <0>;
+			msi-parent = <&its>;
+			msi-map = <0x0 &its 0x10 0x1>,
+				  <0x100 &its 0x11 0x7>;
+			msi-map-mask = <0x1ff>; /* Suppose only 1 physic device connect */
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0x0 0x00000000 0x0 0x6ff00000 0 0x00100000>,
+				 <0x82000000 0x0 0x10000000 0x9 0x10000000 0 0x10000000>;
+			num-lanes = <1>;
+			num-viewport = <8>;
+			interrupts = <GIC_SPI 310 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 311 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "msi", "dma";
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 0x7>;
+			interrupt-map = <0 0 0 1 &gic 0 0 GIC_SPI 306 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 2 &gic 0 0 GIC_SPI 307 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 3 &gic 0 0 GIC_SPI 308 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 4 &gic 0 0 GIC_SPI 309 IRQ_TYPE_LEVEL_HIGH>;
+			fsl,max-link-speed = <3>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+				 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>,
+				 <&hsio_blk_ctrl 0>;
+			clock-names = "pcie", "pcie_bus", "pcie_phy", "pcie_aux", "ref";
+			assigned-clocks =<&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+					 <&scmi_clk IMX95_CLK_HSIOPLL>,
+					 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>;
+			assigned-clock-rates = <3600000000>, <100000000>, <10000000>;
+			assigned-clock-parents = <0>, <0>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+			ctrl-ssr = <&serdes0_ssr>;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			power-domain-names = "pd_pcie";
+			/* 0x10~0x17 stream id for pci0 */
+			iommu-map = <0x000 &smmu 0x10 0x1>,
+				    <0x100 &smmu 0x11 0x7>;
+			iommu-map-mask = <0x1ff>;
+			status = "disabled";
+		};
+
+		serdes0_ssr: ssr@4c340000 {
+			compatible = "fsl,imx95-serdes-syscfg", "syscon";
+			reg = <0 0x4c340000 0 0x2000>;
+		};
+
+		pcie1: pcie@4c380000 {
+			compatible = "fsl,imx95-pcie";
+			reg = <0 0x4c380000 0 0x10000>,
+			      <0 0x4c3e0000 0 0x20000>,
+			      <8 0x80100000 0 0xfe00000>;
+			reg-names = "dbi", "atu", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			linux,pci-domain = <1>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0 0x00000000 0x8 0x8ff00000 0 0x00100000>,
+				 <0x82000000 0 0x10000000 0xa 0x10000000 0 0x10000000>;
+			num-lanes = <1>;
+			num-viewport = <8>;
+			interrupts = <GIC_SPI 316 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 317 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "msi", "dma";
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 0x7>;
+			interrupt-map = <0 0 0 1 &gic 0 0 GIC_SPI 312 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 2 &gic 0 0 GIC_SPI 313 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 3 &gic 0 0 GIC_SPI 314 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 4 &gic 0 0 GIC_SPI 315 IRQ_TYPE_LEVEL_HIGH>;
+			fsl,max-link-speed = <3>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+				 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>,
+				 <&hsio_blk_ctrl 0>;
+			clock-names = "pcie", "pcie_bus", "pcie_phy", "pcie_aux", "ref";
+			assigned-clocks =<&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+					 <&scmi_clk IMX95_CLK_HSIOPLL>,
+					 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>;
+			assigned-clock-rates = <3600000000>, <100000000>, <10000000>;
+			assigned-clock-parents = <0>, <0>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+			ctrl-ssr = <&serdes1_ssr>;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			power-domain-names = "pd_pcie";
+			/* 0x18~0x1F stream id for pci1 */
+			iommu-map = <0x000 &smmu 0x18 0x1>,
+				    <0x100 &smmu 0x19 0x7>;
+			iommu-map-mask = <0x1ff>;
+			status = "disabled";
+		};
+
+		pcie1_ep: pcie-ep@4c380000 {
+			compatible = "fsl,imx95-pcie-ep";
+			reg = <0 0x4c380000 0 0x10000>,
+			      <0 0x4c3a0000 0 0x1000>,
+			      <0 0x4c3e0000 0 0x1000>,
+			      <0 0x4c3f0000 0 0x10000>,
+			      <0xa 0 1 0>;
+			reg-names = "dbi", "dbi2", "atu", "dma", "addr_space";
+			num-lanes = <1>;
+			interrupts = <GIC_SPI 317 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "dma";
+			fsl,max-link-speed = <3>;
+			clocks = <&scmi_clk IMX95_CLK_HSIO>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL>,
+				 <&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+				 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>;
+			clock-names = "pcie", "pcie_bus", "pcie_phy", "pcie_aux";
+			assigned-clocks =<&scmi_clk IMX95_CLK_HSIOPLL_VCO>,
+					 <&scmi_clk IMX95_CLK_HSIOPLL>,
+					 <&scmi_clk IMX95_CLK_HSIOPCIEAUX>;
+			assigned-clock-rates = <3600000000>, <100000000>, <10000000>;
+			assigned-clock-parents = <0>, <0>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+			ctrl-ssr = <&serdes1_ssr>;
+			power-domains = <&scmi_devpd IMX95_PD_HSIO_TOP>;
+			power-domain-names = "pd_pcie";
+			num-ib-windows = <8>;
+			num-ob-windows = <8>;
+			status = "disabled";
+		};
+
+		serdes1_ssr: ssr@4c3c0000 {
+			compatible = "fsl,imx95-serdes-syscfg", "syscon";
+			reg = <0 0x4c3c0000 0 0x2000>;
+		};
+
+		vpu_blk_ctrl: syscon@4c410000 {
+			compatible = "fsl,imx95-vpumix-blk-ctrl", "syscon";
+			reg = <0x0 0x4c410000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_VPUAPB>;
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			assigned-clocks = <&scmi_clk IMX95_CLK_VPUAPB>,
+					  <&scmi_clk IMX95_CLK_VPU>,
+					  <&scmi_clk IMX95_CLK_VPUJPEG>;
+			assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD2>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD0>;
+			assigned-clock-rates = <133333333>, <667000000>, <500000000>;
+		};
+
+		mali: gpu@4d900000 {
+			compatible = "arm,mali-valhall", "nxp,imx95-mali";
+			reg = <0 0x4d900000 0 0x700000>, <0 0x4d810000 0 0x10000>;
+			reg-names = "gpu_base", "gpumix_blk_ctrl";
+			interrupts = <GIC_SPI 288 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 289 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 290 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "gpu", "job", "mmu";
+			clocks = <&scmi_clk IMX95_CLK_GPU>, <&scmi_clk IMX95_CLK_GPUAPB>;
+			clock-names = "gpu", "gpu_apb";
+			power-domains = <&scmi_devpd IMX95_PD_GPU>, <&scmi_perf IMX95_PERF_GPU>;
+			power-domain-names = "gpumix", "gpuperf";
+			operating-points-v2 = <&gpu_opp_table>;
+			#cooling-cells = <2>;
+			simple_power: power_model@0 {
+			    compatible = "arm,mali-simple-power-model";
+			    static-coefficient = <59073>;
+			    dynamic-coefficient = <1013>;
+			    reference_voltage = <920>;
+			    ts = <20000 2000 (-20) 2>;
+			    thermal-zone = "ana";
+			};
+
+			ipa_power:power_model@1 {
+			    compatible = "arm,mali-tvax-power-model";
+			    reference_voltage = <920>;
+			};
+		};
+
+		vpu0: vpu@4c480000 {
+			compatible = "fsl,cnm633c-vpu";
+			reg = <0x0 0x4c480000 0x0 0x10000>;
+			interrupts = <GIC_SPI 299 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_WAVE>;
+			clock-names = "vpu", "vpublk_wave";
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			cnm,ctrl = <&vpuctrl>;
+		};
+
+		vpu1: vpu@4c490000 {
+			compatible = "fsl,cnm633c-vpu";
+			reg = <0x0 0x4c490000 0x0 0x10000>;
+			interrupts = <GIC_SPI 300 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_WAVE>;
+			clock-names = "vpu", "vpublk_wave";
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			cnm,ctrl = <&vpuctrl>;
+			status = "disabled";
+		};
+
+		vpu2: vpu@4c4a0000 {
+			compatible = "fsl,cnm633c-vpu";
+			reg = <0x0 0x4c4a0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 301 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_WAVE>;
+			clock-names = "vpu", "vpublk_wave";
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			cnm,ctrl = <&vpuctrl>;
+			status = "disabled";
+		};
+
+		vpu3: vpu@4c4b0000 {
+			compatible = "fsl,cnm633c-vpu";
+			reg = <0x0 0x4c4b0000 0x0 0x10000>;
+			interrupts = <GIC_SPI 302 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_WAVE>;
+			clock-names = "vpu", "vpublk_wave";
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			cnm,ctrl = <&vpuctrl>;
+			status = "disabled";
+		};
+
+		vpuctrl: vpu-ctrl@4c4c0000 {
+			compatible = "fsl,cm633c-vpu-ctrl";
+			reg = <0x0 0x4c4c0000 0x0 0x10000>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_WAVE>;
+			clock-names = "vpu", "vpublk_wave";
+			power-domains = <&scmi_devpd IMX95_PD_VPU>, <&scmi_perf IMX95_PERF_VPU>;
+			power-domain-names = "vpumix", "vpuperf";
+			#cooling-cells = <2>;
+		};
+
+		jpegdec: jpegdec@4c500000 {
+			compatible = "fsl,imx9-jpgdec";
+			reg = <0x0 0x4C500000 0x0 0x00050000>;
+			interrupts = <GIC_SPI 295 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 296 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 297 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 298 IRQ_TYPE_LEVEL_HIGH>;
+			slot = <0>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&scmi_clk IMX95_CLK_VPUJPEG>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_JPEG_DEC>;
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			power-domain-names = "pd_dec";
+		};
+
+		jpegenc: jpegenc@4c550000 {
+			compatible = "fsl,imx9-jpgenc";
+			reg = <0x0 0x4C550000 0x0 0x00050000>;
+			interrupts = <GIC_SPI 291 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 292 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 293 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 294 IRQ_TYPE_LEVEL_HIGH>;
+			slot = <0>;
+			clocks = <&scmi_clk IMX95_CLK_VPU>,
+				 <&scmi_clk IMX95_CLK_VPUJPEG>,
+				 <&vpu_blk_ctrl IMX95_CLK_VPUBLK_JPEG_ENC>;
+			power-domains = <&scmi_devpd IMX95_PD_VPU>;
+			power-domain-names = "pd_enc";
+		};
+
+		netcmix_blk_ctrl: syscon@4c810000 {
+			compatible = "fsl,imx95-netcmix-blk-ctrl", "syscon";
+			reg = <0x0 0x4c810000 0x0 0x10000>;
+			#clock-cells = <1>;
+			clocks = <&scmi_clk IMX95_CLK_BUSNETCMIX>;
+			assigned-clocks = <&scmi_clk IMX95_CLK_BUSNETCMIX>;
+			assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD1_DIV2>;
+			assigned-clock-rates = <133333333>;
+			power-domains = <&scmi_devpd IMX95_PD_NETC>;
+		};
+
+		sai2: sai@4c880000 {
+			compatible = "fsl,imx95-sai";
+			reg = <0x0 0x4c880000 0x0 0x10000>;
+			interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_BUSNETCMIX>, <&dummy>,
+				 <&scmi_clk IMX95_CLK_SAI2>, <&dummy>,
+				 <&dummy>;
+			clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+			power-domains = <&scmi_devpd IMX95_PD_NETC>;
+			dmas = <&edma2 59 0 1>, <&edma2 58 0 0>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		pcie_4ca00000: pcie@4ca00000 {
+			compatible = "pci-host-ecam-generic";
+			reg = <0x0 0x4ca00000 0x0 0x100000>;
+			/* Must be 3. */
+			#address-cells = <3>;
+			/* Must be 2. */
+			#size-cells = <2>;
+			msi-parent = <&its>;
+			device_type = "pci";
+			bus-range = <0x0 0x0>;
+			msi-map = <0x0 &its 0x60 0x1>,	//ENETC0 PF
+				  <0x10 &its 0x61 0x1>, //ENETC0 VF0
+				  <0x20 &its 0x62 0x1>, //ENETC0 VF1
+				  <0x40 &its 0x63 0x1>, //ENETC1 PF
+				  <0x80 &its 0x64 0x1>, //ENETC2 PF
+				  <0x90 &its 0x65 0x1>, //ENETC2 VF0
+				  <0xa0 &its 0x66 0x1>, //ENETC2 VF1
+				  <0xc0 &its 0x67 0x1>; //NETC Timer
+				  /* ENETC0~2 and Timer BAR0 - non-prefetchable memory */
+			ranges = <0x82000000 0x0 0x4cc00000  0x0 0x4cc00000  0x0 0xe0000
+				  /* Timer BAR2 - prefetchable memory */
+				  0xc2000000 0x0 0x4cd00000  0x0 0x4cd00000  0x0 0x10000
+				  /* ENETC0~2: VF0-1 BAR0 - non-prefetchable memory */
+				  0x82000000 0x0 0x4cd20000  0x0 0x4cd20000  0x0 0x60000
+				  /* ENETC0~2: VF0-1 BAR2 - prefetchable memory */
+				  0xc2000000 0x0 0x4cd80000  0x0 0x4cd80000  0x0 0x60000>;
+			power-domains = <&scmi_devpd IMX95_PD_NETC>;
+
+			enetc_port0: ethernet@0,0 {
+				compatible = "fsl,imx95-enetc";
+				reg = <0x000000 0 0 0 0>;
+				clocks = <&scmi_clk IMX95_CLK_ENETREF>;
+				clock-names = "enet_ref_clk";
+				nvmem-cells = <&eth_mac0>;
+				nvmem-cell-names = "mac-address";
+				status = "disabled";
+			};
+
+			enetc_port1: ethernet@8,0 {
+				compatible = "fsl,imx95-enetc";
+				reg = <0x004000 0 0 0 0>;
+				clocks = <&scmi_clk IMX95_CLK_ENETREF>;
+				clock-names = "enet_ref_clk";
+				nvmem-cells = <&eth_mac1>;
+				nvmem-cell-names = "mac-address";
+				status = "disabled";
+			};
+
+			enetc_port2: ethernet@10,0 {
+				compatible = "fsl,imx95-enetc";
+				reg = <0x008000 0 0 0 0>;
+				nvmem-cells = <&eth_mac2>;
+				nvmem-cell-names = "mac-address";
+				status = "disabled";
+			};
+
+			netc_timer: ethernet@18,0 {
+				compatible = "fsl,imx95-netc-timer";
+				reg = <0x00c000 0 0 0 0>;
+				status = "disabled";
+			};
+
+			rcec@1,0 {
+				compatible = "pci1131,e001";
+				reg = <0x000800 0 0 0 0>;
+				interrupts = <GIC_SPI 304 IRQ_TYPE_LEVEL_HIGH>;
+			};
+		};
+
+		pcie_4cb00000: pcie@4cb00000 {
+			compatible = "pci-host-ecam-generic";
+			reg = <0x0 0x4cb00000 0x0 0x100000>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			bus-range = <0x1 0x1>;
+				  /* EMDIO BAR0 - non-prefetchable memory */
+			ranges = <0x82000000 0x0 0x4cce0000  0x0 0x4cce0000  0x0 0x20000
+				  /* EMDIO BAR2 - prefetchable memory */
+				  0xc2000000 0x0 0x4cd10000  0x0 0x4cd10000  0x0 0x10000>;
+			power-domains = <&scmi_devpd IMX95_PD_NETC>;
+
+			netc_emdio: mdio@0,0 {
+				compatible = "fsl,imx95-netc-emdio";
+				reg = <0x010000 0 0 0 0>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+		};
+
+		netc_prb_ierb: netc-prb-ierb@4cde0000 {
+			compatible = "fsl,imx95-netc-prb-ierb";
+			reg = <0x0 0x4cde0000 0x0 0x10000>,
+			      <0x0 0x4cdf0000 0x0 0x10000>;
+			reg-names = "ierb_base", "prb_base";
+			power-domains = <&scmi_devpd IMX95_PD_NETC>;
+			assigned-clocks = <&scmi_clk IMX95_CLK_ENET>,
+					  <&scmi_clk IMX95_CLK_ENETREF>;
+			assigned-clock-parents = <&scmi_clk IMX95_CLK_SYSPLL1_PFD2>,
+						 <&scmi_clk IMX95_CLK_SYSPLL1_PFD0>;
+			assigned-clock-rates = <666666666>, <250000000>;
+			clocks = <&scmi_clk IMX95_CLK_ENET>;
+			clock-names = "ipg_clk";
+		};
+
+		ddr-pmu@4e090dc0 {
+			compatible = "fsl,imx95-ddr-pmu";
+			reg = <0x0 0x4e090dc0 0x0 0x200>;
+			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		neutron_core: imx95-neutron-remoteproc@4ab00000 {
+			compatible = "fsl,imx95-neutron-rproc";
+			reg = <0x0 0x4ab00000 0x0 0x4>;
+			power-domains = <&scmi_devpd IMX95_PD_NPU>;
+		};
+
+		neutron: imx95-neutron@4ab00004 {
+			compatible = "fsl,imx95-neutron";
+			reg = <0x0 0x4ab00004 0x0 0x400>;
+			fsl,neutron-rproc = <&neutron_core>;
+			interrupts = <GIC_SPI 318 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk IMX95_CLK_NPU>,
+				 <&scmi_clk IMX95_CLK_NPUAPB>;
+			clock-names = "npu", "npu_apb";
+			power-domains = <&scmi_devpd IMX95_PD_NPU>;
+		};
+	};
+
+	rpmsg-lifecycle {
+		compatible = "nxp,rpmsg-lifecycle";
+	};
+
+	ele_fw2: se-fw2 {
+		compatible = "fsl,imx95-se-fw";
+		mbox-names = "tx", "rx";
+		mboxes = <&elemu3 0 0>,
+			 <&elemu3 1 0>;
+	};
+
+	v2x_dbg: v2x-fw0 {
+		compatible = "fsl,imx95-se-fw";
+		mbox-names = "tx", "rx";
+		mboxes = <&v2x_mu 0 0>,
+			<&v2x_mu 1 0>;
+	};
+
+	v2x_sv0: v2x-fw4 {
+		compatible = "fsl,imx95-se-fw";
+		mbox-names = "tx", "rx";
+		mboxes = <&v2x_mu4 0 0>,
+			<&v2x_mu4 1 0>;
+	};
+
+	v2x_she: v2x-fw6 {
+		compatible = "fsl,imx95-se-fw";
+		mbox-names = "tx", "rx";
+		mboxes = <&v2x_mu6 0 0>,
+			<&v2x_mu6 1 0>;
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-cameras-lvds.dts b/arch/arm64/boot/dts/adlink/lec-imx95-cameras-lvds.dts
new file mode 100644
index 000000000000..12ad902677b1
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-cameras-lvds.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov5640-basic.dts"
+#include "ov13855-basic.dts"
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-g080uan02.dts b/arch/arm64/boot/dts/adlink/lec-imx95-g080uan02.dts
new file mode 100644
index 000000000000..7b332a3685ee
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-g080uan02.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g080uan02-basic.dts"
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-g156hat02.dts b/arch/arm64/boot/dts/adlink/lec-imx95-g156hat02.dts
new file mode 100644
index 000000000000..7faa6340ec78
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-g156hat02.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+#include "g156hat02.6-basic.dts"
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-noconsole.dts b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-noconsole.dts
new file mode 100644
index 000000000000..0e440e5edca0
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-noconsole.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&ch {
+    /delete-property/ stdout-path;
+};
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-pcie8997.dts b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-pcie8997.dts
new file mode 100644
index 000000000000..b316f72b6a89
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-pcie8997.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&pcie1 {
+	vpcie-supply = <&reg_usdhc3_en>;
+};
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-uart2.dts b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-uart2.dts
new file mode 100644
index 000000000000..1d948c8ce0b1
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611-uart2.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&ch {
+    /delete-property/ stdout-path;
+};
+
+&scmi_iomuxc {
+    pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART2_RX      0x31e
+			IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART2_TX      0x31e
+		>;
+	};
+};
+
+&lpuart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-lt9611.dts b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611.dts
new file mode 100644
index 000000000000..d94709e5b9ae
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-lt9611.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-lt96114k.dts b/arch/arm64/boot/dts/adlink/lec-imx95-lt96114k.dts
new file mode 100644
index 000000000000..5ef44a49131e
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-lt96114k.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt96114k-basic.dts"
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-ov13855-lvds.dts b/arch/arm64/boot/dts/adlink/lec-imx95-ov13855-lvds.dts
new file mode 100644
index 000000000000..3e4f59735973
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-ov13855-lvds.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov13855-basic.dts"
+
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-ov13855.dts b/arch/arm64/boot/dts/adlink/lec-imx95-ov13855.dts
new file mode 100644
index 000000000000..4b9f1f6daf2b
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-ov13855.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+//#include "g156hat02.6-basic.dts"
+#include "ov13855-basic.dts"
+
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-ov5640.dts b/arch/arm64/boot/dts/adlink/lec-imx95-ov5640.dts
new file mode 100644
index 000000000000..59b332543e0d
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-ov5640.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov5640-basic.dts"
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95-uart2.dts b/arch/arm64/boot/dts/adlink/lec-imx95-uart2.dts
new file mode 100644
index 000000000000..73bce121ecb0
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95-uart2.dts
@@ -0,0 +1,1263 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/phy/phy-imx8-pcie.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/usb/pd.h>
+#include "imx95.dtsi"
+
+#define FALLING_EDGE		BIT(0)
+#define RISING_EDGE		BIT(1)
+
+#define BRD_SM_CTRL_SD3_WAKE		0x8000	/*!< PCAL6408A-0 */
+#define BRD_SM_CTRL_PCIE1_WAKE		0x8001	/*!< PCAL6408A-4 */
+#define BRD_SM_CTRL_BT_WAKE		0x8002	/*!< PCAL6408A-5 */
+#define BRD_SM_CTRL_PCIE2_WAKE		0x8003	/*!< PCAL6408A-6 */
+#define BRD_SM_CTRL_BUTTON		0x8004	/*!< PCAL6408A-7 */
+
+/ {
+	model = "NXP i.MX95 19X19 board";
+	compatible = "fsl,imx95-19x19-evk", "fsl,imx95";
+
+	aliases {
+		ethernet0 = &enetc_port0;
+		ethernet1 = &enetc_port1;
+	};
+
+	chosen {
+		//stdout-path = &lpuart1;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		/* will be updated by U-boot when booting Xen */
+		module@0 {
+			bootargs = "earlycon=xen console=hvc0 loglevel=8 root=/dev/mmcblk1p2 rw rootwait";
+			compatible = "xen,linux-zimage", "xen,multiboot-module";
+			reg = <0x00000000 0x9e000000 0x00000000 0x2000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+
+		key_sleep {
+			label = "SLEEP";
+			linux,code = <KEY_SLEEP>;
+			gpios = <&i2c2_gpio_expander_71 10 GPIO_ACTIVE_LOW>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		led-1 {
+			label = "sys_status_1v8";
+			default-state = "on";
+			gpios = <&gpio5 7 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+
+	/*
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		pwms = <&tpm5 1 4000000 PWM_POLARITY_INVERTED>;
+		cooling-levels = <64 128 192 255>;
+	};
+*/
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux_cma: linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x3c000000>;
+			alloc-ranges = <0 0x80000000 0 0x7F000000>;
+			linux,cma-default;
+		};
+
+		vpu_boot: vpu_boot@a0000000 {
+			reg = <0 0xa0000000 0 0x100000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@88000000 {
+			reg = <0 0x88000000 0 0x8000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@88008000 {
+			reg = <0 0x88008000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring0: vdev1vring0@88010000 {
+			reg = <0 0x88010000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring1: vdev1vring1@88018000 {
+			reg = <0 0x88018000 0 0x8000>;
+			no-map;
+		};
+
+		rsc_table: rsc-table@88220000 {
+			reg = <0 0x88220000 0 0x1000>;
+			no-map;
+		};
+
+		vdevbuffer: vdevbuffer@88020000 {
+			compatible = "shared-dma-pool";
+			reg = <0 0x88020000 0 0x100000>;
+			no-map;
+		};
+	};
+
+	reg_1p8v: regulator-1p8v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <1800000>;
+		regulator-min-microvolt = <1800000>;
+		regulator-name = "+V1.8_SW";
+	};
+
+	reg_3p3v: regulator-3p3v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <3300000>;
+		regulator-min-microvolt = <3300000>;
+		regulator-name = "+V3.3_SW";
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VDD_SD2_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		off-on-delay-us = <12000>;
+		enable-active-high;
+	};
+
+	reg_usdhc3_en: regulator-usdhc3-en {
+		compatible = "regulator-fixed";
+		regulator-name = "usdhc3-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c3_adl1000 22 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_pcie0: regulator-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "PCIE_WLAN_EN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c2_gpio_expander_71 3 GPIO_ACTIVE_HIGH>; //RC210_EN_3V
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_vref_1v8: regulator-adc-vref {
+		compatible = "regulator-fixed";
+		regulator-name = "vref_1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_usb_vbus: regulator-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		/*
+		gpio = <&i2c7_pcal6524 3 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		*/
+	};
+
+	reg_serdes_en: regulator-mac-en {
+		compatible = "regulator-fixed";
+		regulator-name = "mac-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		//vin-supply = <&reg_serdes_stby>;
+		gpio = <&i2c3_adl1000 6 GPIO_ACTIVE_HIGH>;//ETH_CLK_EN_1V8 
+	};
+
+	cm7: imx95-cm7 {
+		compatible = "fsl,imx95-cm7";
+		mbox-names = "tx", "rx", "rxdb";
+		mboxes = <&mu7 0 1
+			  &mu7 1 1
+			  &mu7 3 1>;
+		memory-region = <&vdevbuffer>, <&vdev0vring0>, <&vdev0vring1>,
+				<&vdev1vring0>, <&vdev1vring1>, <&rsc_table>;
+		fsl,startup-delay-ms = <50>;
+		status = "okay";
+	};
+
+	/* SMARC BB CN1701 */
+	sound-tlv320aic3x {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tlv320aic3x";
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"MIC3L", "Microphone Jack",
+			"MIC3R", "Microphone Jack",
+			"Headphone Jack", "HPLOUT",
+			"Headphone Jack", "HPROUT";
+
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&sound_master>;
+		simple-audio-card,frame-master = <&sound_master>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+		};
+
+		sound_master: simple-audio-card,codec {
+			sound-dai = <&tlv320aic3x07>;
+		};
+	};
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&displaymix_irqsteer {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+/*
+&tpm5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm5>;
+	pwm-rst;
+	status = "okay";
+};
+*/
+&tpm6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm6>;
+	pwm-rst;
+	status = "okay";
+};
+
+/* pin conflict with PDM */
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	/*xceiver-supply = <&reg_can1_stby>;*/
+	status = "okay";
+};
+
+&flexcan5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan5>;
+	status = "okay";
+};
+
+&flexspi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_flexspi1>;
+	pinctrl-1 = <&pinctrl_flexspi1>;
+	status = "okay";
+
+	/*U2200 W25Q64JWXGIQ*/
+	flash0: W25Q64JWXGIQ@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <80000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c2>;
+	pinctrl-1 = <&pinctrl_lpi2c2>;
+	status = "okay";
+
+	/*U1000 SX1509BIULTRT_SEMTECH */
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		/* GPIO Expander  Mapping :
+		 * - 0: ENET1_RST_B_3V			=>			U2001
+		 * - 1: ENET2_RST_B_3V			=>			U2101			
+		 * - 2: USB_HUB_RST#_3V			=>			U1800			
+		 * - 3: RC210_EN_3V			=>			U1300 ,RC21008B001GND
+		 * - 4: LT9611_RSTN_3V			=>			U1500
+		 * - 5: HDMI_INT_3V				<= 			U1500
+		 * - 6: PCIEA_RST#_3V			=>			SMARC P75	
+		 * - 7: PCIEB_RST#_3V			=>			SMARC S76			
+		 * - 8: TPM_RST_N_1V8			=> 			U2400
+		 * - 9: LID#_1V8				<= R1005	SMARC S148
+		 * - 10: SLEEP#_1V8				<= R1010	SMARC S149
+		 * - 11: CHARGING#_1V8			<= R1007	SMARC S151
+		 * - 12: CHARGER_PRSNT#_1V8		<= R1011	SMARC S152
+		 * - 13: BATLOW#_1V8			<= R1014	SMARC S156
+		 * - 14: TEST#_1V8				<= R1015	SMARC S157
+		 * - 15: DSI0_TE_1V8    		<= R1087	SMARC S144
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x71>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sx1509q>;
+
+		status = "okay";
+	};
+	/* U2400 TPM - ST33HTPH2X32AHD5_ST */
+	st33tphf2xi2c@2e {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		//compatible = "st,st33htpm-i2c";
+		compatible = "infineon,slb9673";
+		reg = <0x2e>;
+
+		label = "tpm";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c2_tpm>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpio = <&i2c2_gpio_expander_71 8 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c3>;
+	pinctrl-1 = <&pinctrl_lpi2c3>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU GPIO */
+	i2c3_adl1000: i2c3_adl1000@20 {
+		compatible = "adlink,adl1000";
+		pinctrl-names = "default";
+		//interrupt pin A3, A4, B0, B1, B2, B5, B6, B10, B11, B12, B13, B14, B15
+		//INT : PC2 , SCL : PB8 , SDA : PB9
+		/* GPIO Expander  Mapping :
+		 * - 0: PA0 		LCD1_VDD_EN_1V8			=>			SMARC S116 LCD1_VDD_EN
+		 * - 1: PA1 		LCD1_BKLT_EN_1V8		=>			SMARC S107 LCD1_BKLT_EN
+		 * - 2: PA3(int)	CN_GPIO13_1V8			=>			SMARC S123 GPIO13
+		 * - 3: PA4(int) 	CN_GPIO12_1V8			=>			SMARC S142 GPIO12
+		 * - 4: PA5 		Detect_SYS_1V8			<=			R1040 VDD_1V8_S
+		 * - 5: PA6 		MCU_PWRBTN_ON_1V8		=>			R2812 U2802(AND gate) PMIC_ON_MCU_1V8
+		 * - 6: PA7 		ETH_CLK_EN_1V8			=>			U1300 RC21008B001GND#BB0_RENESAS GPIO4
+		 * - 7: PA10 		ONOFF_1V8	    		=> 			U600 (IMX95)
+
+		 * - 8: PA11 		LCD0_VDD_EN_1V8	    	=> 			SMARC S133 LCD0_VDD_EN
+		 * - 9: PA12 		LCD0_BKLT_EN_1V8		=>			SMARC S127 LCD0_BKLT_EN
+		 * - 10: PB0(int) 	CN_GPIO0_CAM0_PWR#_1V8			=>	SMARC P108 CAM0_PWR
+		 * - 11: PB1(int) 	CN_GPIO1_CAM1_PWR#_1V8			=> 	SMARC P109 CAM1_PWR
+		 * - 12: PB2(int) 	CN_GPIO2_CAM0_RST#_1V8			=> 	SMARC P110 CAM0_RST
+		 * - 13: PB5(int) 	CN_GPIO3_CAM1_RST#_1V8			=>  SMARC P111 CAM1_RST
+		 * - 14: PB6(int) 	CN_GPIO4_1V8			=> 			SMARC P112 GPIO4
+		 * - 15: PB10(int) 	CN_GPIO11_1V8			=>			SMARC P119 GPIO11
+
+		 * - 16: PB11(int) 	CN_GPIO6_1V8			=>			SMARC P114 GPIO6
+		 * - 17: PB12(int) 	CN_GPIO7_1V8			=>			SMARC P115 GPIO7
+		 * - 18: PB13(int) 	CN_GPIO8_1V8			=> 			SMARC P116 GPIO8
+		 * - 19: PB14(int) 	CN_GPIO9_1V8    		=>			SMARC P117 GPIO9
+		 * - 20: PB15(int) 	CN_GPIO10_1V8			=>			SMARC P118 GPIO10
+		 * - 21: PC3 		HOST_WAKE_BT_IN#_1V8	=>			U1900 AW-CM276NF pull-up
+		 * - 22: PC4 		WL_PWR_DOWN#_1V8		=>			U1900 AW-CM276NF pull-up
+		 * - 23: PC5 		HOST_WAKE_WL_IN_1V8		=>			U1900 AW-CM276NF pull-down
+		 */
+		pinctrl-0 = <&pinctrl_i2c3_adl1000>;
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>; // MCU_INTB1_1V8 , PC2
+
+	};
+	/*U2401 RTC PCF8563BS/4_NXP */
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c3_rtc>;
+		reg = <0x51>;
+		#clock-cells = <0>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&lpi2c8 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c8>;
+	pinctrl-1 = <&pinctrl_lpi2c8>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU UART */
+	i2c8_adl1001: i2c8_adl1001@48 {
+		compatible = "adlink,adl1001";
+		pinctrl-names = "default";
+		
+		pinctrl-0 = <&pinctrl_i2c8_adl1001>;
+		reg = <0x48>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>; //MCU_INTB2_1V8 , PD2
+	};
+	/* SMARC BB CN1701 */
+    tlv320aic3x07: tlv320aic310x@18 {
+		clock-names = "mclk";
+		clocks = <&scmi_clk IMX95_CLK_SAI3>;
+		compatible = "ti,tlv320aic3x";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		ai3x-micbias-vg = <2>; /* MICBIAS_2_5V */
+		status = "okay";
+        };
+
+	/* SX1509(2) U1001@IPi SMARC Plus */
+	gpio8: i2c2_gpioext0@3e {
+		/* GPIO Expander 2 Mapping :
+		 * - 0: E_GPIO1_0	<=>					IPi SMARC Plus CN101_PIN29: E_GPIO1_0
+		 * - 1: E_GPIO1_1	<=>					IPi SMARC Plus CN101_PIN31: E_GPIO1_1
+		 * - 2: E_GPIO1_2	<=>					IPi SMARC Plus CN101_PIN32: E_GPIO1_2
+		 * - 3: E_GPIO1_3	<=>					IPi SMARC Plus CN101_PIN33: E_GPIO1_3
+		 * - 4: E_GPIO1_4	<=>					IPi SMARC Plus CN101_PIN35: E_GPIO1_4
+		 * - 5: E_GPIO1_5	<=>					IPi SMARC Plus CN101_PIN36: E_GPIO1_5
+		 * - 6: E_GPIO1_6	<=>					IPi SMARC Plus CN101_PIN37: E_GPIO1_6
+		 * - 7: E_GPIO1_7	<=>					IPi SMARC Plus CN101_PIN38: E_GPIO1_7
+		 * - 8: E_GPIO2_8	<=>					IPi SMARC Plus CN101_PIN40: E_GPIO2_8
+		 * - 9: TP1002		<=>					IPi SMARC Plus TP1002 (won't use)
+		 * - 10: TP1003		<=>					IPi SMARC Plus TP1003 (won't use)
+		 * - 11: TP1004		<=>					IPi SMARC Plus TP1004 (won't use)
+		 * - 12: TP1005		<=>					IPi SMARC Plus TP1005 (won't use)
+		 * - 13: TP1006		<=>					IPi SMARC Plus TP1006 (won't use)
+		 * - 14: TP1007		<=>					IPi SMARC Plus TP1007 (won't use)
+		 * - 15: TP1008		<=>					IPi SMARC Plus TP1008 (won't use)
+		 * - 16: OSCIO		<=>					IPi SMARC Plus TP1001 (won't use)
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio8_int>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio2>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+};
+
+&lpuart1 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&lpuart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&lpuart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&lpuart5 {
+	/* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "nxp,88w8997-bt";
+	};
+};
+//SMARC SER0
+&lpuart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart7>;
+	status = "okay";
+};
+//SMARC SPI0
+&lpspi6 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi6>;
+	pinctrl-1 = <&pinctrl_lpspi6>;
+	cs-gpios = <&gpio2 0 GPIO_ACTIVE_LOW>,<&gpio2 24 GPIO_ACTIVE_LOW>;
+	status = "okay";
+        spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+
+};
+//SMARC SPI1
+&lpspi7 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi7>;
+	pinctrl-1 = <&pinctrl_lpspi7>;
+	cs-gpios = <&gpio2 4 GPIO_ACTIVE_LOW>,<&gpio2 25 GPIO_ACTIVE_LOW>;
+	status = "okay";
+    
+	spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        
+	spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+};
+
+&mu7 {
+	status = "okay";
+};
+//U1200 PTE7AAMI-64GI EMMC
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	no-sdio;
+	no-sd;
+	status = "okay";
+};
+//SMARC SDIO
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-3 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio3 00 GPIO_ACTIVE_LOW>;
+	//wp-gpios = <&gpio5 8 GPIO_ACTIVE_HIGH>; //need to remove if want to test on EVK
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&usdhc3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc3>;
+	keep-power-in-suspend;
+	wakeup-source;
+
+	vmmc-supply = <&reg_usdhc3_en>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+
+	mwifiex: wifi@1 {
+		compatible = "marvell,sd8997";
+		reg = <1>;
+
+		marvell,caldata_00_txpwrlimit_2g_cfg_set = /bits/ 8 <
+			 0x01 0x00 0x06 0x00 0x08 0x02 0x89 0x01>;
+		marvell,wakeup-pin = <14>;
+	};
+};
+/*U2001 RTL8211FI-CG_REALTEK*/
+&enetc_port0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc0>,<&pinctrl_ethphy0>;
+	phy-handle = <&ethphy0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+/*U2101 RTL8211FI-CG_REALTEK*/
+&enetc_port1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc1>,<&pinctrl_ethphy1>;
+	phy-handle = <&ethphy1>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+//SMARC
+&enetc_port2 {
+	phy-handle = <&ethphy2>;
+	phy-mode = "10gbase-r";
+	serdes-supply = <&reg_serdes_en>;
+	managed = "in-band-status";
+	//status = "okay";
+};
+
+&netc_timer {
+	status = "okay";
+};
+
+&netc_prb_ierb {
+	netc-interfaces = <NXP_NETC_RGMII
+			   NXP_NETC_RGMII
+			   NXP_NETC_SERIAL>;
+};
+
+&netc_emdio {	
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_emdio>;
+	status = "okay";
+
+	/*U2001 RTL8211FI-CG_REALTEK*/
+	ethphy0: ethernet-phy@1 {
+		reg = <1>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <16 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+	/*U2101 RTL8211FI-CG_REALTEK*/
+	ethphy1: ethernet-phy@4 {
+		reg = <4>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+//SMARC
+	ethphy2: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <8>;
+	};
+	
+};
+//4c200000 USB2 controller
+&usb2 {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&thermal_zones {
+
+	pf09 {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 2>;
+		trips {
+			pf09_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf09_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+
+	pf53_arm {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 4>;
+		trips {
+			pf5301_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5301_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+
+		cooling-maps {
+			map0 {
+				trip = <&pf5301_alert>;
+				cooling-device =
+					<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+	};
+
+	pf53_soc {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 3>;
+		trips {
+			pf5302_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5302_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+};
+//4c010010
+&usb3 {
+	status = "okay";
+};
+//4c1f0040
+&usb3_phy {
+	status = "okay";
+};
+//4c100000 USB1 controller
+&usb3_dwc3 {
+	dr_mode = "host";//this causes USB can't work , need to check
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	role-switch-default-mode = "none";
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	status = "okay";
+};
+
+&scmi_misc {
+	wakeup-sources = <BRD_SM_CTRL_SD3_WAKE		1
+			  BRD_SM_CTRL_PCIE1_WAKE	1
+			  BRD_SM_CTRL_BT_WAKE		1
+			  BRD_SM_CTRL_PCIE2_WAKE	1
+			  BRD_SM_CTRL_BUTTON		1>;
+};
+
+&scmi_iomuxc {
+
+	pinctrl_gpio8_int: gpio8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO22__GPIO2_IO_BIT22			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_tpm6: tpm6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO19__TPM6_CH2			0x51e
+			IMX95_PAD_GPIO_IO23__TPM6_CH1			0x51e
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			IMX95_PAD_PDM_CLK__AONMIX_TOP_CAN1_TX		0x39e
+			IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_CAN1_RX	0x39e
+		>;
+	};
+
+	pinctrl_flexcan5: flexcan5grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO30__CAN5_TX			0x39e
+			IMX95_PAD_GPIO_IO31__CAN5_RX			0x39e
+		>;
+	};
+
+	pinctrl_lpi2c2: lpi2c2grp {
+		fsl,pins = <
+			IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPI2C2_SCL	0x40000b9e
+			IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA	0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c3: lpi2c3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO28__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO29__LPI2C3_SCL			0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c8: lpi2c8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO12__LPI2C8_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO13__LPI2C8_SCL 		0x40000b9e
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			IMX95_PAD_UART1_RXD__AONMIX_TOP_LPUART1_RX      0x31e
+			IMX95_PAD_UART1_TXD__AONMIX_TOP_LPUART1_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART2_RX      0x31e
+			IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART2_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO15__LPUART3_RX      0x31e
+			IMX95_PAD_GPIO_IO14__LPUART3_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			IMX95_PAD_DAP_TDO_TRACESWO__LPUART5_TX			0x31e
+			IMX95_PAD_DAP_TDI__LPUART5_RX				0x31e
+			IMX95_PAD_DAP_TMS_SWDIO__LPUART5_RTS_B			0x31e
+			IMX95_PAD_DAP_TCLK_SWCLK__LPUART5_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_uart7: uart7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO08__LPUART7_TX			0x31e
+			IMX95_PAD_GPIO_IO09__LPUART7_RX				0x31e
+			IMX95_PAD_GPIO_IO11__LPUART7_RTS_B			0x31e
+			IMX95_PAD_GPIO_IO10__LPUART7_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_pcie0: pcie0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO32__HSIOMIX_TOP_PCIE1_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_pcie1: pcie1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO35__HSIOMIX_TOP_PCIE2_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_lpspi6: lpspi6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO00__GPIO2_IO_BIT0	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO24__GPIO2_IO_BIT24	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO01__LPSPI6_SIN		0x3fe
+			IMX95_PAD_GPIO_IO02__LPSPI6_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO03__LPSPI6_SCK		0x3fe
+		>;
+	};
+	pinctrl_lpspi7: lpspi7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO25__GPIO2_IO_BIT25	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO04__GPIO2_IO_BIT4	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO05__LPSPI7_SIN		0x3fe
+			IMX95_PAD_GPIO_IO06__LPSPI7_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO07__LPSPI7_SCK		0x3fe
+		>;
+	};
+
+	pinctrl_emdio: emdiogrp{
+		fsl,pins = <
+			IMX95_PAD_ENET1_MDC__NETCMIX_TOP_NETC_MDC		0x57e
+			IMX95_PAD_ENET1_MDIO__NETCMIX_TOP_NETC_MDIO		0x97e
+		>;
+	};
+
+
+	pinctrl_enetc0: enetc0grp {
+		fsl,pins = <
+			IMX95_PAD_ENET1_TD3__NETCMIX_TOP_ETH0_RGMII_TD3		0x57e
+			IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RGMII_TD2		0x57e
+			IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RGMII_TD1		0x57e
+			IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RGMII_TD0		0x57e
+			IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET1_TXC__NETCMIX_TOP_ETH0_RGMII_TX_CLK	0x58e
+			IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RGMII_RX_CLK	0x58e
+			IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RGMII_RD0		0x57e
+			IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RGMII_RD1		0x57e
+			IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RGMII_RD2		0x57e
+			IMX95_PAD_ENET1_RD3__NETCMIX_TOP_ETH0_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_enetc1: enetc1grp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_TD3__NETCMIX_TOP_ETH1_RGMII_TD3		0x57e
+			IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RGMII_TD2		0x57e
+			IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RGMII_TD1		0x57e
+			IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RGMII_TD0		0x57e
+			IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET2_TXC__NETCMIX_TOP_ETH1_RGMII_TX_CLK	0x5fe
+			IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RGMII_RX_CLK	0x5fe
+			IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RGMII_RD0		0x57e
+			IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RGMII_RD1		0x57e
+			IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RGMII_RD2		0x57e
+			IMX95_PAD_ENET2_RD3__NETCMIX_TOP_ETH1_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_flexspi1: flexspi1grp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_SS0_B__FLEXSPI1_A_SS0_B			0x3fe
+			IMX95_PAD_XSPI1_SCLK__FLEXSPI1_A_SCLK			0x3fe
+			IMX95_PAD_XSPI1_DATA0__FLEXSPI1_A_DATA_BIT0		0x3fe
+			IMX95_PAD_XSPI1_DATA1__FLEXSPI1_A_DATA_BIT1		0x3fe
+			IMX95_PAD_XSPI1_DATA2__FLEXSPI1_A_DATA_BIT2		0x3fe
+			IMX95_PAD_XSPI1_DATA3__FLEXSPI1_A_DATA_BIT3		0x3fe
+		>;
+	};
+
+	pinctrl_i2c2_tpm: i2c2tpmgrp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO27__GPIO2_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_rtc: i2c3rtcgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDC__GPIO4_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_SMB_INT_B_1V8: SMB_INT_B_1V8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO18__GPIO2_IO_BIT18			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_ethphy0: ethphy0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO36__GPIO5_IO_BIT16			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_ethphy1: ethphy1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO37__GPIO5_IO_BIT17			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_i2c8_adl1001: i2c8adl1001grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_adl1000: i2c8adl1000grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO33__GPIO5_IO_BIT13			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_mipi_dsi_csi: mipidsigrp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO2__GPIO3_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_pcal6416: pcal6416grp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO3__GPIO4_IO_BIT28			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sx1509q: sx1509qgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sai1: sai1grp {
+		fsl,pins = <
+			IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0    0x31e
+			IMX95_PAD_SAI1_TXC__AONMIX_TOP_SAI1_TX_BCLK      0x31e
+			IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_SYNC     0x31e
+			IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0    0x31e
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO17__SAI3_MCLK				0x31e
+			IMX95_PAD_GPIO_IO16__SAI3_TX_BCLK			0x31e
+			IMX95_PAD_GPIO_IO26__SAI3_TX_SYNC			0x31e
+			IMX95_PAD_GPIO_IO20__SAI3_RX_DATA_BIT0			0x31e
+			IMX95_PAD_GPIO_IO21__SAI3_TX_DATA_BIT0			0x31e
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x15fe
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x13fe
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x13fe
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x13fe
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x13fe
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x13fe
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x13fe
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x13fe
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x13fe
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x13fe
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x15fe
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_RESET_B__GPIO3_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_leds: ledsgrp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_DATA7__GPIO5_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CD_B__GPIO3_IO_BIT0			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_XSPI1_DQS__GPIO5_IO_BIT8			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x158e
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x138e
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x138e
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x138e
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x138e
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x138e
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x15fe
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x13fe
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x13fe
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x13fe
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x13fe
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x13fe
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x15fe
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x13fe
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x13fe
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x13fe
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x13fe
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x13fe
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+};
+
+&vpuctrl {
+	boot = <&vpu_boot>;
+	sram = <&sram1>;
+};
+
+&wdog3 {
+	status = "okay";
+};
+/* SMARC PCIE_A*/
+&pcie0 {
+	pinctrl-0 = <&pinctrl_pcie0>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 6 GPIO_ACTIVE_LOW>; //PCIEA_RST#_3V
+	vpcie-supply = <&reg_pcie0>;
+	status = "okay";
+};
+/* U1900 AW-CM276NF */
+&pcie1 {
+	pinctrl-0 = <&pinctrl_pcie1>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 7 GPIO_ACTIVE_LOW>; //PCIEB_RST#_3V
+	status = "okay";
+};
+
+&pcie1_ep {
+       pinctrl-0 = <&pinctrl_pcie1>;
+       pinctrl-names = "default";
+       fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+       //vpcie-supply = <&reg_slot_pwr>;
+       status = "disabled";
+};
+
+
+/* U1500 LT9611_LONTIUM */
+&sai1 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI1>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&sai3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI3>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+
diff --git a/arch/arm64/boot/dts/adlink/lec-imx95.dts b/arch/arm64/boot/dts/adlink/lec-imx95.dts
new file mode 100644
index 000000000000..0c7150bf2759
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lec-imx95.dts
@@ -0,0 +1,1265 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/phy/phy-imx8-pcie.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/usb/pd.h>
+#include "imx95.dtsi"
+
+#define FALLING_EDGE		BIT(0)
+#define RISING_EDGE		BIT(1)
+
+#define BRD_SM_CTRL_SD3_WAKE		0x8000	/*!< PCAL6408A-0 */
+#define BRD_SM_CTRL_PCIE1_WAKE		0x8001	/*!< PCAL6408A-4 */
+#define BRD_SM_CTRL_BT_WAKE		0x8002	/*!< PCAL6408A-5 */
+#define BRD_SM_CTRL_PCIE2_WAKE		0x8003	/*!< PCAL6408A-6 */
+#define BRD_SM_CTRL_BUTTON		0x8004	/*!< PCAL6408A-7 */
+
+/ {
+	model = "NXP i.MX95 19X19 board";
+	compatible = "fsl,imx95-19x19-evk", "fsl,imx95";
+
+	aliases {
+		ethernet0 = &enetc_port0;
+		ethernet1 = &enetc_port1;
+	};
+
+	ch: chosen {
+		stdout-path = &lpuart1;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		/* will be updated by U-boot when booting Xen */
+		module@0 {
+			bootargs = "earlycon=xen console=hvc0 loglevel=8 root=/dev/mmcblk1p2 rw rootwait";
+			compatible = "xen,linux-zimage", "xen,multiboot-module";
+			reg = <0x00000000 0x9e000000 0x00000000 0x2000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+
+		key_sleep {
+			label = "SLEEP";
+			linux,code = <KEY_SLEEP>;
+			gpios = <&i2c2_gpio_expander_71 10 GPIO_ACTIVE_LOW>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		led-1 {
+			label = "sys_status_1v8";
+			default-state = "on";
+			gpios = <&gpio5 7 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+
+	/*
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		pwms = <&tpm5 1 4000000 PWM_POLARITY_INVERTED>;
+		cooling-levels = <64 128 192 255>;
+	};
+*/
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux_cma: linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x3c000000>;
+			alloc-ranges = <0 0x80000000 0 0x7F000000>;
+			linux,cma-default;
+		};
+
+		vpu_boot: vpu_boot@a0000000 {
+			reg = <0 0xa0000000 0 0x100000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@88000000 {
+			reg = <0 0x88000000 0 0x8000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@88008000 {
+			reg = <0 0x88008000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring0: vdev1vring0@88010000 {
+			reg = <0 0x88010000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring1: vdev1vring1@88018000 {
+			reg = <0 0x88018000 0 0x8000>;
+			no-map;
+		};
+
+		rsc_table: rsc-table@88220000 {
+			reg = <0 0x88220000 0 0x1000>;
+			no-map;
+		};
+
+		vdevbuffer: vdevbuffer@88020000 {
+			compatible = "shared-dma-pool";
+			reg = <0 0x88020000 0 0x100000>;
+			no-map;
+		};
+	};
+
+	reg_1p8v: regulator-1p8v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <1800000>;
+		regulator-min-microvolt = <1800000>;
+		regulator-name = "+V1.8_SW";
+	};
+
+	reg_3p3v: regulator-3p3v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <3300000>;
+		regulator-min-microvolt = <3300000>;
+		regulator-name = "+V3.3_SW";
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VDD_SD2_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		off-on-delay-us = <12000>;
+		enable-active-high;
+	};
+
+	reg_usdhc3_en: regulator-usdhc3-en {
+		compatible = "regulator-fixed";
+		regulator-name = "usdhc3-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c3_adl1000 22 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_pcie0: regulator-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "PCIE_WLAN_EN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c2_gpio_expander_71 3 GPIO_ACTIVE_HIGH>; //RC210_EN_3V
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_vref_1v8: regulator-adc-vref {
+		compatible = "regulator-fixed";
+		regulator-name = "vref_1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_usb_vbus: regulator-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		/*
+		gpio = <&i2c7_pcal6524 3 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		*/
+	};
+
+	reg_tpm_rst: regulator-tmp {
+		compatible = "regulator-fixed";
+		regulator-name = "TPM_RST";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio =  <&i2c2_gpio_expander_71 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		startup-delay-us = <5000>;
+	};
+
+	reg_serdes_en: regulator-mac-en {
+		compatible = "regulator-fixed";
+		regulator-name = "mac-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		//vin-supply = <&reg_serdes_stby>;
+		gpio = <&i2c3_adl1000 6 GPIO_ACTIVE_HIGH>;//ETH_CLK_EN_1V8 
+	};
+
+	cm7: imx95-cm7 {
+		compatible = "fsl,imx95-cm7";
+		mbox-names = "tx", "rx", "rxdb";
+		mboxes = <&mu7 0 1
+			  &mu7 1 1
+			  &mu7 3 1>;
+		memory-region = <&vdevbuffer>, <&vdev0vring0>, <&vdev0vring1>,
+				<&vdev1vring0>, <&vdev1vring1>, <&rsc_table>;
+		fsl,startup-delay-ms = <50>;
+		status = "okay";
+	};
+
+	/* SMARC BB CN1701 */
+	sound-tlv320aic3x {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tlv320aic3x";
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"MIC3L", "Microphone Jack",
+			"MIC3R", "Microphone Jack",
+			"Headphone Jack", "HPLOUT",
+			"Headphone Jack", "HPROUT";
+
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&sound_master>;
+		simple-audio-card,frame-master = <&sound_master>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+		};
+
+		sound_master: simple-audio-card,codec {
+			sound-dai = <&tlv320aic3x07>;
+		};
+	};
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&displaymix_irqsteer {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+/*
+&tpm5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm5>;
+	pwm-rst;
+	status = "okay";
+};
+*/
+&tpm6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm6>;
+	pwm-rst;
+	status = "okay";
+};
+
+/* pin conflict with PDM */
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	/*xceiver-supply = <&reg_can1_stby>;*/
+	status = "okay";
+};
+
+&flexcan5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan5>;
+	status = "okay";
+};
+
+&flexspi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_flexspi1>;
+	pinctrl-1 = <&pinctrl_flexspi1>;
+	status = "okay";
+
+	/*U2200 W25Q64JWXGIQ*/
+	flash0: W25Q64JWXGIQ@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <133000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c2>;
+	pinctrl-1 = <&pinctrl_lpi2c2>;
+	status = "okay";
+
+	/*U1000 SX1509BIULTRT_SEMTECH */
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		/* GPIO Expander  Mapping :
+		 * - 0: ENET1_RST_B_3V			=>			U2001
+		 * - 1: ENET2_RST_B_3V			=>			U2101			
+		 * - 2: USB_HUB_RST#_3V			=>			U1800			
+		 * - 3: RC210_EN_3V			=>			U1300 ,RC21008B001GND
+		 * - 4: LT9611_RSTN_3V			=>			U1500
+		 * - 5: HDMI_INT_3V				<= 			U1500
+		 * - 6: PCIEA_RST#_3V			=>			SMARC P75	
+		 * - 7: PCIEB_RST#_3V			=>			SMARC S76			
+		 * - 8: TPM_RST_N_1V8			=> 			U2400
+		 * - 9: LID#_1V8				<= R1005	SMARC S148
+		 * - 10: SLEEP#_1V8				<= R1010	SMARC S149
+		 * - 11: CHARGING#_1V8			<= R1007	SMARC S151
+		 * - 12: CHARGER_PRSNT#_1V8		<= R1011	SMARC S152
+		 * - 13: BATLOW#_1V8			<= R1014	SMARC S156
+		 * - 14: TEST#_1V8				<= R1015	SMARC S157
+		 * - 15: DSI0_TE_1V8    		<= R1087	SMARC S144
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x71>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sx1509q>;
+
+		status = "okay";
+	};
+	/* U2400 TPM - ST33HTPH2X32AHD5_ST */
+	st33tphf2xi2c@2e {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		//compatible = "st,st33htpm-i2c";
+		compatible = "infineon,slb9673";
+		reg = <0x2e>;
+
+		label = "tpm";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c2_tpm>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+
+		tpm-supply = <&reg_tpm_rst>;
+		status = "okay";
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c3>;
+	pinctrl-1 = <&pinctrl_lpi2c3>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU GPIO */
+	i2c3_adl1000: i2c3_adl1000@20 {
+		compatible = "adlink,adl1000";
+		pinctrl-names = "default";
+		//interrupt pin A3, A4, B0, B1, B2, B5, B6, B10, B11, B12, B13, B14, B15
+		//INT : PC2 , SCL : PB8 , SDA : PB9
+		/* GPIO Expander  Mapping :
+		 * - 0: PA0 		LCD1_VDD_EN_1V8			=>			SMARC S116 LCD1_VDD_EN
+		 * - 1: PA1 		LCD1_BKLT_EN_1V8		=>			SMARC S107 LCD1_BKLT_EN
+		 * - 2: PA3(int)	CN_GPIO13_1V8			=>			SMARC S123 GPIO13
+		 * - 3: PA4(int) 	CN_GPIO12_1V8			=>			SMARC S142 GPIO12
+		 * - 4: PA5 		Detect_SYS_1V8			<=			R1040 VDD_1V8_S
+		 * - 5: PA6 		MCU_PWRBTN_ON_1V8		=>			R2812 U2802(AND gate) PMIC_ON_MCU_1V8
+		 * - 6: PA7 		ETH_CLK_EN_1V8			=>			U1300 RC21008B001GND#BB0_RENESAS GPIO4
+		 * - 7: PA10 		ONOFF_1V8	    		=> 			U600 (IMX95)
+
+		 * - 8: PA11 		LCD0_VDD_EN_1V8	    	=> 			SMARC S133 LCD0_VDD_EN
+		 * - 9: PA12 		LCD0_BKLT_EN_1V8		=>			SMARC S127 LCD0_BKLT_EN
+		 * - 10: PB0(int) 	CN_GPIO0_CAM0_PWR#_1V8			=>	SMARC P108 CAM0_PWR
+		 * - 11: PB1(int) 	CN_GPIO1_CAM1_PWR#_1V8			=> 	SMARC P109 CAM1_PWR
+		 * - 12: PB2(int) 	CN_GPIO2_CAM0_RST#_1V8			=> 	SMARC P110 CAM0_RST
+		 * - 13: PB5(int) 	CN_GPIO3_CAM1_RST#_1V8			=>  SMARC P111 CAM1_RST
+		 * - 14: PB6(int) 	CN_GPIO4_1V8			=> 			SMARC P112 GPIO4
+		 * - 15: PB10(int) 	CN_GPIO11_1V8			=>			SMARC P119 GPIO11
+
+		 * - 16: PB11(int) 	CN_GPIO6_1V8			=>			SMARC P114 GPIO6
+		 * - 17: PB12(int) 	CN_GPIO7_1V8			=>			SMARC P115 GPIO7
+		 * - 18: PB13(int) 	CN_GPIO8_1V8			=> 			SMARC P116 GPIO8
+		 * - 19: PB14(int) 	CN_GPIO9_1V8    		=>			SMARC P117 GPIO9
+		 * - 20: PB15(int) 	CN_GPIO10_1V8			=>			SMARC P118 GPIO10
+		 * - 21: PC3 		HOST_WAKE_BT_IN#_1V8	=>			U1900 AW-CM276NF pull-up
+		 * - 22: PC4 		WL_PWR_DOWN#_1V8		=>			U1900 AW-CM276NF pull-up
+		 * - 23: PC5 		HOST_WAKE_WL_IN_1V8		=>			U1900 AW-CM276NF pull-down
+		 */
+		pinctrl-0 = <&pinctrl_i2c3_adl1000>;
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>; // MCU_INTB1_1V8 , PC2
+
+	};
+	/*U2401 RTC PCF8563BS/4_NXP */
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c3_rtc>;
+		reg = <0x51>;
+		#clock-cells = <0>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&lpi2c8 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c8>;
+	pinctrl-1 = <&pinctrl_lpi2c8>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU UART */
+	i2c8_adl1001: i2c8_adl1001@48 {
+		compatible = "adlink,adl1001";
+		pinctrl-names = "default";
+		
+		pinctrl-0 = <&pinctrl_i2c8_adl1001>;
+		reg = <0x48>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>; //MCU_INTB2_1V8 , PD2
+	};
+	/* SMARC BB CN1701 */
+    tlv320aic3x07: tlv320aic310x@18 {
+		clock-names = "mclk";
+		clocks = <&scmi_clk IMX95_CLK_SAI3>;
+		compatible = "ti,tlv320aic3x";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		ai3x-micbias-vg = <2>; /* MICBIAS_2_5V */
+		status = "okay";
+        };
+
+	/* SX1509(2) U1001@IPi SMARC Plus */
+	gpio8: i2c2_gpioext0@3e {
+		/* GPIO Expander 2 Mapping :
+		 * - 0: E_GPIO1_0	<=>					IPi SMARC Plus CN101_PIN29: E_GPIO1_0
+		 * - 1: E_GPIO1_1	<=>					IPi SMARC Plus CN101_PIN31: E_GPIO1_1
+		 * - 2: E_GPIO1_2	<=>					IPi SMARC Plus CN101_PIN32: E_GPIO1_2
+		 * - 3: E_GPIO1_3	<=>					IPi SMARC Plus CN101_PIN33: E_GPIO1_3
+		 * - 4: E_GPIO1_4	<=>					IPi SMARC Plus CN101_PIN35: E_GPIO1_4
+		 * - 5: E_GPIO1_5	<=>					IPi SMARC Plus CN101_PIN36: E_GPIO1_5
+		 * - 6: E_GPIO1_6	<=>					IPi SMARC Plus CN101_PIN37: E_GPIO1_6
+		 * - 7: E_GPIO1_7	<=>					IPi SMARC Plus CN101_PIN38: E_GPIO1_7
+		 * - 8: E_GPIO2_8	<=>					IPi SMARC Plus CN101_PIN40: E_GPIO2_8
+		 * - 9: TP1002		<=>					IPi SMARC Plus TP1002 (won't use)
+		 * - 10: TP1003		<=>					IPi SMARC Plus TP1003 (won't use)
+		 * - 11: TP1004		<=>					IPi SMARC Plus TP1004 (won't use)
+		 * - 12: TP1005		<=>					IPi SMARC Plus TP1005 (won't use)
+		 * - 13: TP1006		<=>					IPi SMARC Plus TP1006 (won't use)
+		 * - 14: TP1007		<=>					IPi SMARC Plus TP1007 (won't use)
+		 * - 15: TP1008		<=>					IPi SMARC Plus TP1008 (won't use)
+		 * - 16: OSCIO		<=>					IPi SMARC Plus TP1001 (won't use)
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio8_int>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio2>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+};
+
+&lpuart1 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&lpuart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&lpuart5 {
+	/* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "nxp,88w8997-bt";
+	};
+};
+//SMARC SER0
+&lpuart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart7>;
+	status = "okay";
+};
+//SMARC SPI0
+&lpspi6 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi6>;
+	pinctrl-1 = <&pinctrl_lpspi6>;
+	cs-gpios = <&gpio2 0 GPIO_ACTIVE_LOW>,<&gpio2 24 GPIO_ACTIVE_LOW>;
+	status = "okay";
+        spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+
+};
+//SMARC SPI1
+&lpspi7 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi7>;
+	pinctrl-1 = <&pinctrl_lpspi7>;
+	cs-gpios = <&gpio2 4 GPIO_ACTIVE_LOW>,<&gpio2 25 GPIO_ACTIVE_LOW>;
+	status = "okay";
+    
+	spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        
+	spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+};
+
+&mu7 {
+	status = "okay";
+};
+//U1200 PTE7AAMI-64GI EMMC
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	no-sdio;
+	no-sd;
+	status = "okay";
+};
+//SMARC SDIO
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-3 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio3 00 GPIO_ACTIVE_LOW>;
+	//wp-gpios = <&gpio5 8 GPIO_ACTIVE_HIGH>; //need to remove if want to test on EVK
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&usdhc3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc3>;
+	keep-power-in-suspend;
+	wakeup-source;
+
+	vmmc-supply = <&reg_usdhc3_en>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+
+	mwifiex: wifi@1 {
+		compatible = "marvell,sd8997";
+		reg = <1>;
+
+		marvell,caldata_00_txpwrlimit_2g_cfg_set = /bits/ 8 <
+			 0x01 0x00 0x06 0x00 0x08 0x02 0x89 0x01>;
+		marvell,wakeup-pin = <14>;
+	};
+};
+/*U2001 RTL8211FI-CG_REALTEK*/
+&enetc_port0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc0>,<&pinctrl_ethphy0>;
+	phy-handle = <&ethphy0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+/*U2101 RTL8211FI-CG_REALTEK*/
+&enetc_port1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc1>,<&pinctrl_ethphy1>;
+	phy-handle = <&ethphy1>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+//SMARC
+&enetc_port2 {
+	phy-handle = <&ethphy2>;
+	phy-mode = "10gbase-r";
+	serdes-supply = <&reg_serdes_en>;
+	managed = "in-band-status";
+	//status = "okay";
+};
+
+&netc_timer {
+	status = "okay";
+};
+
+&netc_prb_ierb {
+	netc-interfaces = <NXP_NETC_RGMII
+			   NXP_NETC_RGMII
+			   NXP_NETC_SERIAL>;
+};
+
+&netc_emdio {	
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_emdio>;
+	status = "okay";
+
+	/*U2001 RTL8211FI-CG_REALTEK*/
+	ethphy0: ethernet-phy@1 {
+		reg = <1>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <16 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+	/*U2101 RTL8211FI-CG_REALTEK*/
+	ethphy1: ethernet-phy@4 {
+		reg = <4>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+//SMARC
+	ethphy2: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <8>;
+	};
+	
+};
+//4c200000 USB2 controller
+&usb2 {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&thermal_zones {
+
+	pf09 {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 2>;
+		trips {
+			pf09_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf09_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+
+	pf53_arm {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 4>;
+		trips {
+			pf5301_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5301_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+
+		cooling-maps {
+			map0 {
+				trip = <&pf5301_alert>;
+				cooling-device =
+					<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+	};
+
+	pf53_soc {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 3>;
+		trips {
+			pf5302_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5302_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+};
+//4c010010
+&usb3 {
+	status = "okay";
+};
+//4c1f0040
+&usb3_phy {
+	fsl,phy-tx-vref-tune-percent = <0x73>;
+	status = "okay";
+};
+//4c100000 USB1 controller
+&usb3_dwc3 {
+	dr_mode = "host";//this causes USB can't work , need to check
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	role-switch-default-mode = "none";
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	status = "okay";
+};
+
+&scmi_misc {
+	wakeup-sources = <BRD_SM_CTRL_SD3_WAKE		1
+			  BRD_SM_CTRL_PCIE1_WAKE	1
+			  BRD_SM_CTRL_BT_WAKE		1
+			  BRD_SM_CTRL_PCIE2_WAKE	1
+			  BRD_SM_CTRL_BUTTON		1>;
+};
+
+&scmi_iomuxc {
+
+	pinctrl_gpio8_int: gpio8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO22__GPIO2_IO_BIT22			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_tpm6: tpm6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO19__TPM6_CH2			0x51e
+			IMX95_PAD_GPIO_IO23__TPM6_CH1			0x51e
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			IMX95_PAD_PDM_CLK__AONMIX_TOP_CAN1_TX		0x39e
+			IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_CAN1_RX	0x39e
+		>;
+	};
+
+	pinctrl_flexcan5: flexcan5grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO30__CAN5_TX			0x39e
+			IMX95_PAD_GPIO_IO31__CAN5_RX			0x39e
+		>;
+	};
+
+	pinctrl_lpi2c2: lpi2c2grp {
+		fsl,pins = <
+			IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPI2C2_SCL	0x40000b9e
+			IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA	0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c3: lpi2c3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO28__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO29__LPI2C3_SCL			0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c8: lpi2c8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO12__LPI2C8_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO13__LPI2C8_SCL 		0x40000b9e
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			IMX95_PAD_UART1_RXD__AONMIX_TOP_LPUART1_RX      0x31e
+			IMX95_PAD_UART1_TXD__AONMIX_TOP_LPUART1_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO15__LPUART3_RX      0x31e
+			IMX95_PAD_GPIO_IO14__LPUART3_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			IMX95_PAD_DAP_TDO_TRACESWO__LPUART5_TX			0x31e
+			IMX95_PAD_DAP_TDI__LPUART5_RX				0x31e
+			IMX95_PAD_DAP_TMS_SWDIO__LPUART5_RTS_B			0x31e
+			IMX95_PAD_DAP_TCLK_SWCLK__LPUART5_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_uart7: uart7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO08__LPUART7_TX			0x31e
+			IMX95_PAD_GPIO_IO09__LPUART7_RX				0x31e
+			IMX95_PAD_GPIO_IO11__LPUART7_RTS_B			0x31e
+			IMX95_PAD_GPIO_IO10__LPUART7_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_pcie0: pcie0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO32__HSIOMIX_TOP_PCIE1_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_pcie1: pcie1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO35__HSIOMIX_TOP_PCIE2_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_lpspi6: lpspi6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO00__GPIO2_IO_BIT0	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO24__GPIO2_IO_BIT24	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO01__LPSPI6_SIN		0x3fe
+			IMX95_PAD_GPIO_IO02__LPSPI6_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO03__LPSPI6_SCK		0x3fe
+		>;
+	};
+	pinctrl_lpspi7: lpspi7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO25__GPIO2_IO_BIT25	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO04__GPIO2_IO_BIT4	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO05__LPSPI7_SIN		0x3fe
+			IMX95_PAD_GPIO_IO06__LPSPI7_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO07__LPSPI7_SCK		0x3fe
+		>;
+	};
+
+	pinctrl_emdio: emdiogrp{
+		fsl,pins = <
+			IMX95_PAD_ENET1_MDC__NETCMIX_TOP_NETC_MDC		0x57e
+			IMX95_PAD_ENET1_MDIO__NETCMIX_TOP_NETC_MDIO		0x97e
+		>;
+	};
+
+
+	pinctrl_enetc0: enetc0grp {
+		fsl,pins = <
+			IMX95_PAD_ENET1_TD3__NETCMIX_TOP_ETH0_RGMII_TD3		0x57e
+			IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RGMII_TD2		0x57e
+			IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RGMII_TD1		0x57e
+			IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RGMII_TD0		0x57e
+			IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET1_TXC__NETCMIX_TOP_ETH0_RGMII_TX_CLK	0x58e
+			IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RGMII_RX_CLK	0x58e
+			IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RGMII_RD0		0x57e
+			IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RGMII_RD1		0x57e
+			IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RGMII_RD2		0x57e
+			IMX95_PAD_ENET1_RD3__NETCMIX_TOP_ETH0_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_enetc1: enetc1grp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_TD3__NETCMIX_TOP_ETH1_RGMII_TD3		0x57e
+			IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RGMII_TD2		0x57e
+			IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RGMII_TD1		0x57e
+			IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RGMII_TD0		0x57e
+			IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET2_TXC__NETCMIX_TOP_ETH1_RGMII_TX_CLK	0x5fe
+			IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RGMII_RX_CLK	0x5fe
+			IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RGMII_RD0		0x57e
+			IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RGMII_RD1		0x57e
+			IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RGMII_RD2		0x57e
+			IMX95_PAD_ENET2_RD3__NETCMIX_TOP_ETH1_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_flexspi1: flexspi1grp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_SS0_B__FLEXSPI1_A_SS0_B			0x3fe
+			IMX95_PAD_XSPI1_SCLK__FLEXSPI1_A_SCLK			0x3fe
+			IMX95_PAD_XSPI1_DATA0__FLEXSPI1_A_DATA_BIT0		0x3fe
+			IMX95_PAD_XSPI1_DATA1__FLEXSPI1_A_DATA_BIT1		0x3fe
+			IMX95_PAD_XSPI1_DATA2__FLEXSPI1_A_DATA_BIT2		0x3fe
+			IMX95_PAD_XSPI1_DATA3__FLEXSPI1_A_DATA_BIT3		0x3fe
+		>;
+	};
+
+	pinctrl_i2c2_tpm: i2c2tpmgrp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO27__GPIO2_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_rtc: i2c3rtcgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDC__GPIO4_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_SMB_INT_B_1V8: SMB_INT_B_1V8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO18__GPIO2_IO_BIT18			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_ethphy0: ethphy0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO36__GPIO5_IO_BIT16			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_ethphy1: ethphy1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO37__GPIO5_IO_BIT17			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_i2c8_adl1001: i2c8adl1001grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_adl1000: i2c8adl1000grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO33__GPIO5_IO_BIT13			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_mipi_dsi_csi: mipidsigrp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO2__GPIO3_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_pcal6416: pcal6416grp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO3__GPIO4_IO_BIT28			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sx1509q: sx1509qgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sai1: sai1grp {
+		fsl,pins = <
+			IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0    0x31e
+			IMX95_PAD_SAI1_TXC__AONMIX_TOP_SAI1_TX_BCLK      0x31e
+			IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_SYNC     0x31e
+			IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0    0x31e
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO17__SAI3_MCLK				0x31e
+			IMX95_PAD_GPIO_IO16__SAI3_TX_BCLK			0x31e
+			IMX95_PAD_GPIO_IO26__SAI3_TX_SYNC			0x31e
+			IMX95_PAD_GPIO_IO20__SAI3_RX_DATA_BIT0			0x31e
+			IMX95_PAD_GPIO_IO21__SAI3_TX_DATA_BIT0			0x31e
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x15fe
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x13fe
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x13fe
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x13fe
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x13fe
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x13fe
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x13fe
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x13fe
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x13fe
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x13fe
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x15fe
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_RESET_B__GPIO3_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_leds: ledsgrp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_DATA7__GPIO5_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CD_B__GPIO3_IO_BIT0			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_XSPI1_DQS__GPIO5_IO_BIT8			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x158e
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x138e
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x138e
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x138e
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x138e
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x138e
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x15fe
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x13fe
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x13fe
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x13fe
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x13fe
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x13fe
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x15fe
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x13fe
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x13fe
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x13fe
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x13fe
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x13fe
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+};
+
+&vpuctrl {
+	boot = <&vpu_boot>;
+	sram = <&sram1>;
+};
+
+&wdog3 {
+	status = "okay";
+};
+/* SMARC PCIE_A*/
+&pcie0 {
+	pinctrl-0 = <&pinctrl_pcie0>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 6 GPIO_ACTIVE_LOW>; //PCIEA_RST#_3V
+	vpcie-supply = <&reg_pcie0>;
+	status = "okay";
+};
+/* U1900 AW-CM276NF */
+&pcie1 {
+	pinctrl-0 = <&pinctrl_pcie1>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 7 GPIO_ACTIVE_LOW>; //PCIEB_RST#_3V
+	status = "okay";
+};
+
+&pcie1_ep {
+       pinctrl-0 = <&pinctrl_pcie1>;
+       pinctrl-names = "default";
+       fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+       //vpcie-supply = <&reg_slot_pwr>;
+       status = "disabled";
+};
+
+
+/* U1500 LT9611_LONTIUM */
+&sai1 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI1>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&sai3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI3>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+
diff --git a/arch/arm64/boot/dts/adlink/lt9611-basic.dts b/arch/arm64/boot/dts/adlink/lt9611-basic.dts
new file mode 100644
index 000000000000..199db4f19f1e
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lt9611-basic.dts
@@ -0,0 +1,116 @@
+
+
+&{/} {
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&lt9611_out>;
+			};
+		};
+	};
+
+	sound-hdmi {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "sound-hdmi";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&hdmicpu>;
+		simple-audio-card,bitclock-master = <&hdmicpu>;
+
+		hdmicpu:simple-audio-card,cpu {
+			sound-dai = <&sai1>;
+			system-clock-direction-out;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&lt9611_codec 0>;
+		};
+	};
+
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <4008000000>, <445333334>;
+	status = "okay";
+};
+
+&lpi2c3 {
+	clock-frequency = <400000>;
+	status = "okay";
+
+
+	/* U1500 LT9611_LONTIUM */
+	lt9611_codec: hdmi-bridge@3b {
+		#sound-dai-cells = <1>;
+		compatible = "adlink,lt9611";
+		reg = <0x3b>;
+		interrupts-extended = <&i2c2_gpio_expander_71 5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&i2c2_gpio_expander_71 4 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mipi_dsi_csi>;
+
+		clocks = <&scmi_clk IMX95_CLK_DISP1PIX>, <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>, <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+		clock-names = "pix","vco","videopll1";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				lt9611_to_dsi: endpoint {
+					remote-endpoint = <&dsi_to_lt9611>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				lt9611_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_to_lt9611: endpoint {
+				remote-endpoint = <&lt9611_to_dsi>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@1 {
+		reg = <1>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/lt96114k-basic.dts b/arch/arm64/boot/dts/adlink/lt96114k-basic.dts
new file mode 100644
index 000000000000..c0f2b533647b
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/lt96114k-basic.dts
@@ -0,0 +1,117 @@
+
+
+
+&{/} {
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&lt9611_out>;
+			};
+		};
+	};
+
+	sound-hdmi {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "sound-hdmi";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&hdmicpu>;
+		simple-audio-card,bitclock-master = <&hdmicpu>;
+
+		hdmicpu:simple-audio-card,cpu {
+			sound-dai = <&sai1>;
+			system-clock-direction-out;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&lt9611_codec 0>;
+		};
+	};
+
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <2673000000>, <297000000>;
+	status = "okay";
+};
+
+&lpi2c3 {
+	clock-frequency = <400000>;
+	status = "okay";
+
+
+	/* U1500 LT9611_LONTIUM */
+	lt9611_codec: hdmi-bridge@3b {
+		#sound-dai-cells = <1>;
+		compatible = "adlink,lt9611";
+		reg = <0x3b>;
+		interrupts-extended = <&i2c2_gpio_expander_71 5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&i2c2_gpio_expander_71 4 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mipi_dsi_csi>;
+
+		clocks = <&scmi_clk IMX95_CLK_DISP1PIX>, <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>, <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+		clock-names = "pix","vco","videopll1";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				lt9611_to_dsi: endpoint {
+					remote-endpoint = <&dsi_to_lt9611>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				lt9611_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_to_lt9611: endpoint {
+				remote-endpoint = <&lt9611_to_dsi>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@1 {
+		reg = <1>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/adlink/ov13855-basic.dts b/arch/arm64/boot/dts/adlink/ov13855-basic.dts
new file mode 100644
index 000000000000..c3dff4bdc7c9
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/ov13855-basic.dts
@@ -0,0 +1,147 @@
+
+&scmi_iomuxc {
+	pinctrl_csi_mclk: csi_mclk {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO1__CCMSRCGPCMIX_TOP_CLKO_1	0x39e
+		>;
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	/*
+	ov5640_0: ov5640_mipi@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "xclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+		powerdown-gpios = <&i2c3_adl1000 10 GPIO_ACTIVE_HIGH>; 	//CN_GPIO0_CAM0_PWR#_1V8
+		reset-gpios = <&i2c3_adl1000 12 GPIO_ACTIVE_LOW>;	//CN_GPIO2_CAM0_RST#_1V8
+		status = "okay";
+
+		port {
+			ov13855_mipi_0_ep: endpoint {
+				remote-endpoint = <&mipi_csi0_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+	*/
+	
+	ov13855_mipi: ov13855_mipi@36 {
+		compatible = "ov13855_mipi";
+		reg = <0x36>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+
+		//pwn-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		//rst-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		pwn-gpios = <&i2c3_adl1000 11 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		rst-gpios = <&i2c3_adl1000 13 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		//pwn-gpios = <&i2c3_adl1000 11 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		//rst-gpios = <&i2c3_adl1000 13 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		virtual_channel = <0>;
+		mipi_csi;
+
+		port@0 {
+			ov13855_mipi_0_ep: endpoint {
+				remote-endpoint = <&mipi_csi0_ep>;
+				data-lanes = <1 2 3 4>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+	
+
+};
+
+&dphy_rx {
+	status = "okay";
+};
+
+&mipi_csi0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			mipi_csi0_ep: endpoint {
+				remote-endpoint = <&ov13855_mipi_0_ep>;
+				data-lanes = <1 2 3 4>;
+				clock-lanes = <0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+				mipi_csi0_out: endpoint {
+				remote-endpoint = <&formatter_0_in>;
+				//remote-endpoint = <&isi_in_2>;
+			};
+		};
+	};
+};
+
+&csi_pixel_formatter_0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			formatter_0_in: endpoint {
+				remote-endpoint = <&mipi_csi0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			formatter_0_out: endpoint {
+				remote-endpoint = <&isi_in_2>;
+			};
+		};
+	};
+};
+
+&isi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@2 {
+			reg = <2>;
+
+			isi_in_2: endpoint {
+				remote-endpoint = <&formatter_0_out>;
+				//remote-endpoint = <&mipi_csi0_out>;
+			};
+		};
+	};
+};
+
+
diff --git a/arch/arm64/boot/dts/adlink/ov5640-basic.dts b/arch/arm64/boot/dts/adlink/ov5640-basic.dts
new file mode 100644
index 000000000000..49ae3d110087
--- /dev/null
+++ b/arch/arm64/boot/dts/adlink/ov5640-basic.dts
@@ -0,0 +1,127 @@
+
+&scmi_iomuxc {
+	pinctrl_csi_mclk: csi_mclk {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO1__CCMSRCGPCMIX_TOP_CLKO_1	0x39e
+		>;
+	};
+};
+
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+
+	ov5640_0: ov5640_mipi@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "xclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+		powerdown-gpios = <&i2c3_adl1000 10 GPIO_ACTIVE_HIGH>; 	//CN_GPIO0_CAM0_PWR#_1V8
+		reset-gpios = <&i2c3_adl1000 12 GPIO_ACTIVE_LOW>;	//CN_GPIO2_CAM0_RST#_1V8
+		status = "okay";
+
+		port {
+			ov5640_mipi_1_ep: endpoint {
+				remote-endpoint = <&mipi_csi1_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+};
+
+&display_stream_csr {
+	status = "disabled";
+};
+
+&display_master_csr {
+	status = "disabled";
+};
+
+&mipi_tx_phy_csr {
+	status = "disabled";
+};
+
+&mipi_dsi_intf {
+	status = "okay";
+};
+
+&combo_rx {
+	status = "okay";
+};
+
+&mipi_csi1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			mipi_csi1_ep: endpoint {
+				remote-endpoint = <&ov5640_mipi_1_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+				mipi_csi1_out: endpoint {
+				remote-endpoint = <&formatter_1_in>;
+			};
+		};
+	};
+};
+
+
+&csi_pixel_formatter_1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			formatter_1_in: endpoint {
+				remote-endpoint = <&mipi_csi1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			formatter_1_out: endpoint {
+				remote-endpoint = <&isi_in_3>;
+			};
+		};
+	};
+};
+
+&isi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@3 {
+			reg = <3>;
+
+			isi_in_3: endpoint {
+				remote-endpoint = <&formatter_1_out>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index e648366ca0ba..20afac195829 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -460,6 +460,13 @@ dtb-$(CONFIG_ARCH_MXC) += imx91-9x9-qsb-ld.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx91-9x9-qsb-i2c-spi-slave.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx91-9x9-qsb-i3c.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx95-15x15-evk.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-g080uan02.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-g156hat02.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-lt9611.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-ov13855.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-ov13855-lvds.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-cameras-lvds.dtb
+dtb-$(CONFIG_ARCH_MXC) += lec-imx95-lt96114k.dtb  lec-imx95-ov5640.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx95-15x15-evk-flexspi-m2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx95-15x15-evk-mqs.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx95-15x15-evk-aud-hat.dtb
diff --git a/arch/arm64/boot/dts/freescale/g080uan02-basic.dts b/arch/arm64/boot/dts/freescale/g080uan02-basic.dts
new file mode 100644
index 000000000000..fc2ffc1cc038
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/g080uan02-basic.dts
@@ -0,0 +1,72 @@
+
+
+
+&{/} {
+
+	lcd0_backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&tpm6 2 6666667 PWM_POLARITY_INVERTED>;
+		brightness-levels = <0 45 63 88 119 158 203 255>;
+		default-brightness-level = <6>;
+		enable-gpios = <&i2c3_adl1000 9 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <4008000000>, <445333334>;
+};
+
+&mipi_dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	panel@0 {
+		compatible = "auo,g080uan02";
+		reg = <0>;
+		enable-gpios = <&i2c3_adl1000 8 GPIO_ACTIVE_HIGH>; //LCD0_VDD_EN_1V8
+		dsi-lanes = <4>;
+		v3p3-supply = <&reg_3p3v>;
+		v1p8-supply = <&reg_1p8v>;
+		backlight = <&lcd0_backlight>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@1 {
+		reg = <1>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/g156hat02.6-basic.dts b/arch/arm64/boot/dts/freescale/g156hat02.6-basic.dts
new file mode 100644
index 000000000000..b55cd4ea6523
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/g156hat02.6-basic.dts
@@ -0,0 +1,101 @@
+
+
+&{/} {
+	lvds0_panel {
+		compatible = "auo,g156hat026";
+		backlight = <&lcd0_backlight>;
+		enable-gpios = <&i2c3_adl1000 8 GPIO_ACTIVE_HIGH>; //LCD0_VDD_EN_1V8
+		
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				dual-lvds-odd-pixels;
+				panel_in_odd: endpoint {
+					remote-endpoint = <&lvds0_out>;
+				};
+			};
+
+
+			port@1 {
+				reg = <1>;
+				dual-lvds-even-pixels;
+				panel_in_even: endpoint {
+					remote-endpoint = <&lvds1_out>;
+				};
+			};
+		};
+	};
+
+	lcd0_backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&tpm6 2 6666667 PWM_POLARITY_INVERTED>;
+		brightness-levels = <0 45 63 88 119 158 203 255>;
+		default-brightness-level = <6>;
+		enable-gpios = <&i2c3_adl1000 9 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&ldb {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_LDBPLL_VCO>,
+			  <&scmi_clk IMX95_CLK_LDBPLL>;
+	assigned-clock-rates = <3291120000>, <1097040000>;
+	status = "okay";
+
+	channel@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+
+			lvds0_out: endpoint {
+				remote-endpoint = <&panel_in_odd>;
+			};
+		};
+	};
+
+	channel@1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <1>;
+		status = "okay";
+
+		port@1 {
+			reg = <1>;
+
+			lvds1_out: endpoint {
+				remote-endpoint = <&panel_in_even>;
+			};
+		};
+	};
+};
+
+&ldb0_phy {
+	status = "okay";
+};
+
+&ldb1_phy {
+	status = "okay";
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@0 {
+		reg = <0>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx95-19x19-evk-adv7535.dtso b/arch/arm64/boot/dts/freescale/imx95-19x19-evk-adv7535.dtso
index ade631466546..2b17fb5aeccf 100644
--- a/arch/arm64/boot/dts/freescale/imx95-19x19-evk-adv7535.dtso
+++ b/arch/arm64/boot/dts/freescale/imx95-19x19-evk-adv7535.dtso
@@ -7,6 +7,9 @@
 /plugin/;
 
 #include <dt-bindings/clock/fsl,imx95-clock.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
 
 &{/} {
 	hdmi-connector {
@@ -35,21 +38,30 @@ &dpu {
 };
 
 &lpi2c2 {
-	#address-cells = <1>;
-	#size-cells = <0>;
+	status = "okay";
+	
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		status = "okay";
+	};
+};
+
+&lpi2c3 {
+	clock-frequency = <100000>;
+	status = "okay";
+
+
+	/* U1500 LT9611_LONTIUM */
+	lt9611_codec: hdmi-bridge@3b {
+		#sound-dai-cells = <1>;
+		compatible = "adlink,lt9611";
+		reg = <0x3b>;
+		interrupts-extended = <&i2c2_gpio_expander_71 5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&i2c2_gpio_expander_71 4 GPIO_ACTIVE_LOW>;
 
-	hdmi@3d {
-		compatible = "adi,adv7535";
-		reg = <0x3d>;
-		avdd-supply = <&reg_1p8v>;
-		dvdd-supply = <&reg_1p8v>;
-		pvdd-supply = <&reg_1p8v>;
-		a2vdd-supply = <&reg_3p3v>;
-		v3p3-supply = <&reg_1p8v>;
-		v1p2-supply = <&reg_1p8v>;
-		adi,dsi-lanes = <4>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_mipi_dsi_csi>;
+		clocks = <&scmi_clk IMX95_CLK_DISP1PIX>, <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>, <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+		clock-names = "pix","vco","videopll1";
 
 		ports {
 			#address-cells = <1>;
@@ -63,8 +75,8 @@ adv7535_to_dsi: endpoint {
 				};
 			};
 
-			port@1 {
-				reg = <1>;
+			port@2 {
+				reg = <2>;
 
 				adv7533_out: endpoint {
 					remote-endpoint = <&hdmi_connector_in>;
diff --git a/arch/arm64/boot/dts/freescale/imx95-19x19-evk.dts b/arch/arm64/boot/dts/freescale/imx95-19x19-evk.dts
index c4c6fff87bb0..e368fc81e3c0 100644
--- a/arch/arm64/boot/dts/freescale/imx95-19x19-evk.dts
+++ b/arch/arm64/boot/dts/freescale/imx95-19x19-evk.dts
@@ -398,6 +398,42 @@ &lpi2c2 {
 	pinctrl-1 = <&pinctrl_lpi2c2>;
 	status = "okay";
 
+	/*U1000 SX1509BIULTRT_SEMTECH */
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		/* GPIO Expander  Mapping :
+		 * - 0: ENET1_RST_B_3V			=>			U2001
+		 * - 1: ENET2_RST_B_3V			=>			U2101			
+		 * - 2: USB_HUB_RST#_3V			=>			U1800			
+		 * - 3: RC210_EN_3V			=>			U1300 ,RC21008B001GND
+		 * - 4: LT9611_RSTN_3V			=>			U1500
+		 * - 5: HDMI_INT_3V				<= 			U1500
+		 * - 6: PCIEA_RST#_3V			=>			SMARC P75	
+		 * - 7: PCIEB_RST#_3V			=>			SMARC S76			
+		 * - 8: TPM_RST_N_1V8			=> 			U2400
+		 * - 9: LID#_1V8				<= R1005	SMARC S148
+		 * - 10: SLEEP#_1V8				<= R1010	SMARC S149
+		 * - 11: CHARGING#_1V8			<= R1007	SMARC S151
+		 * - 12: CHARGER_PRSNT#_1V8		<= R1011	SMARC S152
+		 * - 13: BATLOW#_1V8			<= R1014	SMARC S156
+		 * - 14: TEST#_1V8				<= R1015	SMARC S157
+		 * - 15: DSI0_TE_1V8    		<= R1087	SMARC S144
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x71>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sx1509q>;
+
+		status = "okay";
+	};
+
 	adp5585: mfd@34 {
 		compatible = "adi,adp5585";
 		reg = <0x34>;
@@ -913,8 +949,10 @@ IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA	0x40000b9e
 
 	pinctrl_lpi2c3: lpi2c3grp {
 		fsl,pins = <
-			IMX95_PAD_GPIO_IO00__LPI2C3_SDA			0x40000b9e
-			IMX95_PAD_GPIO_IO01__LPI2C3_SCL			0x40000b9e
+			IMX95_PAD_GPIO_IO28__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO29__LPI2C3_SCL			0x40000b9e
+			/*IMX95_PAD_GPIO_IO00__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO01__LPI2C3_SCL			0x40000b9e*/
 		>;
 	};
 
@@ -1073,6 +1111,12 @@ IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14			0x31e
 		>;
 	};
 
+	pinctrl_sx1509q: sx1509qgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
 	pinctrl_sai1: sai1grp {
 		fsl,pins = <
 			IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0    0x31e
@@ -1084,7 +1128,7 @@ IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0    0x31e
 
 	pinctrl_sai2: sai2grp {
 		fsl,pins = <
-			IMX95_PAD_ENET2_MDIO__NETCMIX_TOP_SAI2_RX_BCLK			0x31e
+			/*IMX95_PAD_ENET2_MDIO__NETCMIX_TOP_SAI2_RX_BCLK			0x31e*/
 			IMX95_PAD_ENET2_MDC__NETCMIX_TOP_SAI2_RX_SYNC			0x31e
 			IMX95_PAD_ENET2_TD3__NETCMIX_TOP_SAI2_RX_DATA_BIT0		0x31e
 			IMX95_PAD_ENET2_TD2__NETCMIX_TOP_SAI2_RX_DATA_BIT1		0x31e
diff --git a/arch/arm64/boot/dts/freescale/imx95.dtsi b/arch/arm64/boot/dts/freescale/imx95.dtsi
index 239b0d6e8a70..31d05e6fa990 100644
--- a/arch/arm64/boot/dts/freescale/imx95.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx95.dtsi
@@ -644,23 +644,23 @@ its: msi-controller@48040000 {
 	gpu_opp_table: opp_table {
 		compatible = "operating-points-v2", "operating-points-v2-mali";
 
-		opp-500000000 {
-			opp-hz = /bits/ 64 <500000000>;
-			opp-hz-real = /bits/ 64 <500000000>;
+		opp-1000000000 {
+			opp-hz = /bits/ 64 <1000000000>;
+			opp-hz-real = /bits/ 64 <1000000000>, /bits/ 64 <133333333>;
 			opp-microvolt = <920000>;
 		};
 
 		opp-800000000 {
 			opp-hz = /bits/ 64 <800000000>;
-			opp-hz-real = /bits/ 64 <800000000>;
+			opp-hz-real = /bits/ 64 <800000000>, /bits/ 64 <133333333>;
 			opp-microvolt = <920000>;
 		};
-
-		opp-1000000000 {
-			opp-hz = /bits/ 64 <1000000000>;
-			opp-hz-real = /bits/ 64 <1000000000>;
+		opp-500000000 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-hz-real = /bits/ 64 <500000000>, /bits/ 64 <133333333>;
 			opp-microvolt = <920000>;
 		};
+
 	};
 
 	usbphynop: usbphynop {
@@ -2392,13 +2392,13 @@ port@3 {
 						#size-cells = <0>;
 						reg = <3>;
 
-						display_pixel_link1_to_mipi_dsi: endpoint@0 {
-							reg = <0>;
+						display_pixel_link1_to_mipi_dsi: endpoint@1 {
+							reg = <1>;
 							remote-endpoint = <&mipi_dsi_to_display_pixel_link1>;
 						};
 
-						display_pixel_link1_to_ldb_ch1: endpoint@1 {
-							reg = <1>;
+						display_pixel_link1_to_ldb_ch1: endpoint@0 {
+							reg = <0>;
 							remote-endpoint = <&ldb_ch1_to_display_pixel_link1>;
 						};
 					};
@@ -2960,14 +2960,14 @@ vpu_blk_ctrl: syscon@4c410000 {
 
 		mali: gpu@4d900000 {
 			compatible = "arm,mali-valhall", "nxp,imx95-mali";
-			reg = <0 0x4d900000 0 0x480000>, <0 0x4d810000 0 0x10000>;
+			reg = <0 0x4d900000 0 0x700000>, <0 0x4d810000 0 0x10000>;
 			reg-names = "gpu_base", "gpumix_blk_ctrl";
 			interrupts = <GIC_SPI 288 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 289 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 290 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "gpu", "job", "mmu";
-			clocks = <&scmi_clk IMX95_CLK_GPU>;
-			clock-names = "gpu";
+			clocks = <&scmi_clk IMX95_CLK_GPU>, <&scmi_clk IMX95_CLK_GPUAPB>;
+			clock-names = "gpu", "gpu_apb";
 			power-domains = <&scmi_devpd IMX95_PD_GPU>, <&scmi_perf IMX95_PERF_GPU>;
 			power-domain-names = "gpumix", "gpuperf";
 			operating-points-v2 = <&gpu_opp_table>;
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-cameras-lvds.dts b/arch/arm64/boot/dts/freescale/lec-imx95-cameras-lvds.dts
new file mode 100644
index 000000000000..12ad902677b1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-cameras-lvds.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov5640-basic.dts"
+#include "ov13855-basic.dts"
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-g080uan02.dts b/arch/arm64/boot/dts/freescale/lec-imx95-g080uan02.dts
new file mode 100644
index 000000000000..7b332a3685ee
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-g080uan02.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g080uan02-basic.dts"
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-g156hat02.dts b/arch/arm64/boot/dts/freescale/lec-imx95-g156hat02.dts
new file mode 100644
index 000000000000..7faa6340ec78
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-g156hat02.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+#include "g156hat02.6-basic.dts"
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-noconsole.dts b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-noconsole.dts
new file mode 100644
index 000000000000..0e440e5edca0
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-noconsole.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&ch {
+    /delete-property/ stdout-path;
+};
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-pcie8997.dts b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-pcie8997.dts
new file mode 100644
index 000000000000..b316f72b6a89
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-pcie8997.dts
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&pcie1 {
+	vpcie-supply = <&reg_usdhc3_en>;
+};
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-uart2.dts b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-uart2.dts
new file mode 100644
index 000000000000..1d948c8ce0b1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611-uart2.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
+&ch {
+    /delete-property/ stdout-path;
+};
+
+&scmi_iomuxc {
+    pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART2_RX      0x31e
+			IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART2_TX      0x31e
+		>;
+	};
+};
+
+&lpuart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-lt9611.dts b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611.dts
new file mode 100644
index 000000000000..d94709e5b9ae
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-lt9611.dts
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-lt96114k.dts b/arch/arm64/boot/dts/freescale/lec-imx95-lt96114k.dts
new file mode 100644
index 000000000000..5ef44a49131e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-lt96114k.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+
+#include "lec-imx95.dts"
+#include "lt96114k-basic.dts"
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-ov13855-lvds.dts b/arch/arm64/boot/dts/freescale/lec-imx95-ov13855-lvds.dts
new file mode 100644
index 000000000000..3e4f59735973
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-ov13855-lvds.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov13855-basic.dts"
+
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-ov13855.dts b/arch/arm64/boot/dts/freescale/lec-imx95-ov13855.dts
new file mode 100644
index 000000000000..4b9f1f6daf2b
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-ov13855.dts
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "lt9611-basic.dts"
+//#include "g156hat02.6-basic.dts"
+#include "ov13855-basic.dts"
+
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-ov5640.dts b/arch/arm64/boot/dts/freescale/lec-imx95-ov5640.dts
new file mode 100644
index 000000000000..59b332543e0d
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-ov5640.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+#include "lec-imx95.dts"
+#include "g156hat02.6-basic.dts"
+#include "ov5640-basic.dts"
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95-uart2.dts b/arch/arm64/boot/dts/freescale/lec-imx95-uart2.dts
new file mode 100644
index 000000000000..73bce121ecb0
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95-uart2.dts
@@ -0,0 +1,1263 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/phy/phy-imx8-pcie.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/usb/pd.h>
+#include "imx95.dtsi"
+
+#define FALLING_EDGE		BIT(0)
+#define RISING_EDGE		BIT(1)
+
+#define BRD_SM_CTRL_SD3_WAKE		0x8000	/*!< PCAL6408A-0 */
+#define BRD_SM_CTRL_PCIE1_WAKE		0x8001	/*!< PCAL6408A-4 */
+#define BRD_SM_CTRL_BT_WAKE		0x8002	/*!< PCAL6408A-5 */
+#define BRD_SM_CTRL_PCIE2_WAKE		0x8003	/*!< PCAL6408A-6 */
+#define BRD_SM_CTRL_BUTTON		0x8004	/*!< PCAL6408A-7 */
+
+/ {
+	model = "NXP i.MX95 19X19 board";
+	compatible = "fsl,imx95-19x19-evk", "fsl,imx95";
+
+	aliases {
+		ethernet0 = &enetc_port0;
+		ethernet1 = &enetc_port1;
+	};
+
+	chosen {
+		//stdout-path = &lpuart1;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		/* will be updated by U-boot when booting Xen */
+		module@0 {
+			bootargs = "earlycon=xen console=hvc0 loglevel=8 root=/dev/mmcblk1p2 rw rootwait";
+			compatible = "xen,linux-zimage", "xen,multiboot-module";
+			reg = <0x00000000 0x9e000000 0x00000000 0x2000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+
+		key_sleep {
+			label = "SLEEP";
+			linux,code = <KEY_SLEEP>;
+			gpios = <&i2c2_gpio_expander_71 10 GPIO_ACTIVE_LOW>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		led-1 {
+			label = "sys_status_1v8";
+			default-state = "on";
+			gpios = <&gpio5 7 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+
+	/*
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		pwms = <&tpm5 1 4000000 PWM_POLARITY_INVERTED>;
+		cooling-levels = <64 128 192 255>;
+	};
+*/
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux_cma: linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x3c000000>;
+			alloc-ranges = <0 0x80000000 0 0x7F000000>;
+			linux,cma-default;
+		};
+
+		vpu_boot: vpu_boot@a0000000 {
+			reg = <0 0xa0000000 0 0x100000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@88000000 {
+			reg = <0 0x88000000 0 0x8000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@88008000 {
+			reg = <0 0x88008000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring0: vdev1vring0@88010000 {
+			reg = <0 0x88010000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring1: vdev1vring1@88018000 {
+			reg = <0 0x88018000 0 0x8000>;
+			no-map;
+		};
+
+		rsc_table: rsc-table@88220000 {
+			reg = <0 0x88220000 0 0x1000>;
+			no-map;
+		};
+
+		vdevbuffer: vdevbuffer@88020000 {
+			compatible = "shared-dma-pool";
+			reg = <0 0x88020000 0 0x100000>;
+			no-map;
+		};
+	};
+
+	reg_1p8v: regulator-1p8v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <1800000>;
+		regulator-min-microvolt = <1800000>;
+		regulator-name = "+V1.8_SW";
+	};
+
+	reg_3p3v: regulator-3p3v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <3300000>;
+		regulator-min-microvolt = <3300000>;
+		regulator-name = "+V3.3_SW";
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VDD_SD2_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		off-on-delay-us = <12000>;
+		enable-active-high;
+	};
+
+	reg_usdhc3_en: regulator-usdhc3-en {
+		compatible = "regulator-fixed";
+		regulator-name = "usdhc3-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c3_adl1000 22 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_pcie0: regulator-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "PCIE_WLAN_EN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c2_gpio_expander_71 3 GPIO_ACTIVE_HIGH>; //RC210_EN_3V
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_vref_1v8: regulator-adc-vref {
+		compatible = "regulator-fixed";
+		regulator-name = "vref_1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_usb_vbus: regulator-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		/*
+		gpio = <&i2c7_pcal6524 3 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		*/
+	};
+
+	reg_serdes_en: regulator-mac-en {
+		compatible = "regulator-fixed";
+		regulator-name = "mac-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		//vin-supply = <&reg_serdes_stby>;
+		gpio = <&i2c3_adl1000 6 GPIO_ACTIVE_HIGH>;//ETH_CLK_EN_1V8 
+	};
+
+	cm7: imx95-cm7 {
+		compatible = "fsl,imx95-cm7";
+		mbox-names = "tx", "rx", "rxdb";
+		mboxes = <&mu7 0 1
+			  &mu7 1 1
+			  &mu7 3 1>;
+		memory-region = <&vdevbuffer>, <&vdev0vring0>, <&vdev0vring1>,
+				<&vdev1vring0>, <&vdev1vring1>, <&rsc_table>;
+		fsl,startup-delay-ms = <50>;
+		status = "okay";
+	};
+
+	/* SMARC BB CN1701 */
+	sound-tlv320aic3x {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tlv320aic3x";
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"MIC3L", "Microphone Jack",
+			"MIC3R", "Microphone Jack",
+			"Headphone Jack", "HPLOUT",
+			"Headphone Jack", "HPROUT";
+
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&sound_master>;
+		simple-audio-card,frame-master = <&sound_master>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+		};
+
+		sound_master: simple-audio-card,codec {
+			sound-dai = <&tlv320aic3x07>;
+		};
+	};
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&displaymix_irqsteer {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+/*
+&tpm5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm5>;
+	pwm-rst;
+	status = "okay";
+};
+*/
+&tpm6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm6>;
+	pwm-rst;
+	status = "okay";
+};
+
+/* pin conflict with PDM */
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	/*xceiver-supply = <&reg_can1_stby>;*/
+	status = "okay";
+};
+
+&flexcan5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan5>;
+	status = "okay";
+};
+
+&flexspi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_flexspi1>;
+	pinctrl-1 = <&pinctrl_flexspi1>;
+	status = "okay";
+
+	/*U2200 W25Q64JWXGIQ*/
+	flash0: W25Q64JWXGIQ@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <80000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c2>;
+	pinctrl-1 = <&pinctrl_lpi2c2>;
+	status = "okay";
+
+	/*U1000 SX1509BIULTRT_SEMTECH */
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		/* GPIO Expander  Mapping :
+		 * - 0: ENET1_RST_B_3V			=>			U2001
+		 * - 1: ENET2_RST_B_3V			=>			U2101			
+		 * - 2: USB_HUB_RST#_3V			=>			U1800			
+		 * - 3: RC210_EN_3V			=>			U1300 ,RC21008B001GND
+		 * - 4: LT9611_RSTN_3V			=>			U1500
+		 * - 5: HDMI_INT_3V				<= 			U1500
+		 * - 6: PCIEA_RST#_3V			=>			SMARC P75	
+		 * - 7: PCIEB_RST#_3V			=>			SMARC S76			
+		 * - 8: TPM_RST_N_1V8			=> 			U2400
+		 * - 9: LID#_1V8				<= R1005	SMARC S148
+		 * - 10: SLEEP#_1V8				<= R1010	SMARC S149
+		 * - 11: CHARGING#_1V8			<= R1007	SMARC S151
+		 * - 12: CHARGER_PRSNT#_1V8		<= R1011	SMARC S152
+		 * - 13: BATLOW#_1V8			<= R1014	SMARC S156
+		 * - 14: TEST#_1V8				<= R1015	SMARC S157
+		 * - 15: DSI0_TE_1V8    		<= R1087	SMARC S144
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x71>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sx1509q>;
+
+		status = "okay";
+	};
+	/* U2400 TPM - ST33HTPH2X32AHD5_ST */
+	st33tphf2xi2c@2e {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		//compatible = "st,st33htpm-i2c";
+		compatible = "infineon,slb9673";
+		reg = <0x2e>;
+
+		label = "tpm";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c2_tpm>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpio = <&i2c2_gpio_expander_71 8 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c3>;
+	pinctrl-1 = <&pinctrl_lpi2c3>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU GPIO */
+	i2c3_adl1000: i2c3_adl1000@20 {
+		compatible = "adlink,adl1000";
+		pinctrl-names = "default";
+		//interrupt pin A3, A4, B0, B1, B2, B5, B6, B10, B11, B12, B13, B14, B15
+		//INT : PC2 , SCL : PB8 , SDA : PB9
+		/* GPIO Expander  Mapping :
+		 * - 0: PA0 		LCD1_VDD_EN_1V8			=>			SMARC S116 LCD1_VDD_EN
+		 * - 1: PA1 		LCD1_BKLT_EN_1V8		=>			SMARC S107 LCD1_BKLT_EN
+		 * - 2: PA3(int)	CN_GPIO13_1V8			=>			SMARC S123 GPIO13
+		 * - 3: PA4(int) 	CN_GPIO12_1V8			=>			SMARC S142 GPIO12
+		 * - 4: PA5 		Detect_SYS_1V8			<=			R1040 VDD_1V8_S
+		 * - 5: PA6 		MCU_PWRBTN_ON_1V8		=>			R2812 U2802(AND gate) PMIC_ON_MCU_1V8
+		 * - 6: PA7 		ETH_CLK_EN_1V8			=>			U1300 RC21008B001GND#BB0_RENESAS GPIO4
+		 * - 7: PA10 		ONOFF_1V8	    		=> 			U600 (IMX95)
+
+		 * - 8: PA11 		LCD0_VDD_EN_1V8	    	=> 			SMARC S133 LCD0_VDD_EN
+		 * - 9: PA12 		LCD0_BKLT_EN_1V8		=>			SMARC S127 LCD0_BKLT_EN
+		 * - 10: PB0(int) 	CN_GPIO0_CAM0_PWR#_1V8			=>	SMARC P108 CAM0_PWR
+		 * - 11: PB1(int) 	CN_GPIO1_CAM1_PWR#_1V8			=> 	SMARC P109 CAM1_PWR
+		 * - 12: PB2(int) 	CN_GPIO2_CAM0_RST#_1V8			=> 	SMARC P110 CAM0_RST
+		 * - 13: PB5(int) 	CN_GPIO3_CAM1_RST#_1V8			=>  SMARC P111 CAM1_RST
+		 * - 14: PB6(int) 	CN_GPIO4_1V8			=> 			SMARC P112 GPIO4
+		 * - 15: PB10(int) 	CN_GPIO11_1V8			=>			SMARC P119 GPIO11
+
+		 * - 16: PB11(int) 	CN_GPIO6_1V8			=>			SMARC P114 GPIO6
+		 * - 17: PB12(int) 	CN_GPIO7_1V8			=>			SMARC P115 GPIO7
+		 * - 18: PB13(int) 	CN_GPIO8_1V8			=> 			SMARC P116 GPIO8
+		 * - 19: PB14(int) 	CN_GPIO9_1V8    		=>			SMARC P117 GPIO9
+		 * - 20: PB15(int) 	CN_GPIO10_1V8			=>			SMARC P118 GPIO10
+		 * - 21: PC3 		HOST_WAKE_BT_IN#_1V8	=>			U1900 AW-CM276NF pull-up
+		 * - 22: PC4 		WL_PWR_DOWN#_1V8		=>			U1900 AW-CM276NF pull-up
+		 * - 23: PC5 		HOST_WAKE_WL_IN_1V8		=>			U1900 AW-CM276NF pull-down
+		 */
+		pinctrl-0 = <&pinctrl_i2c3_adl1000>;
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>; // MCU_INTB1_1V8 , PC2
+
+	};
+	/*U2401 RTC PCF8563BS/4_NXP */
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c3_rtc>;
+		reg = <0x51>;
+		#clock-cells = <0>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&lpi2c8 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c8>;
+	pinctrl-1 = <&pinctrl_lpi2c8>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU UART */
+	i2c8_adl1001: i2c8_adl1001@48 {
+		compatible = "adlink,adl1001";
+		pinctrl-names = "default";
+		
+		pinctrl-0 = <&pinctrl_i2c8_adl1001>;
+		reg = <0x48>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>; //MCU_INTB2_1V8 , PD2
+	};
+	/* SMARC BB CN1701 */
+    tlv320aic3x07: tlv320aic310x@18 {
+		clock-names = "mclk";
+		clocks = <&scmi_clk IMX95_CLK_SAI3>;
+		compatible = "ti,tlv320aic3x";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		ai3x-micbias-vg = <2>; /* MICBIAS_2_5V */
+		status = "okay";
+        };
+
+	/* SX1509(2) U1001@IPi SMARC Plus */
+	gpio8: i2c2_gpioext0@3e {
+		/* GPIO Expander 2 Mapping :
+		 * - 0: E_GPIO1_0	<=>					IPi SMARC Plus CN101_PIN29: E_GPIO1_0
+		 * - 1: E_GPIO1_1	<=>					IPi SMARC Plus CN101_PIN31: E_GPIO1_1
+		 * - 2: E_GPIO1_2	<=>					IPi SMARC Plus CN101_PIN32: E_GPIO1_2
+		 * - 3: E_GPIO1_3	<=>					IPi SMARC Plus CN101_PIN33: E_GPIO1_3
+		 * - 4: E_GPIO1_4	<=>					IPi SMARC Plus CN101_PIN35: E_GPIO1_4
+		 * - 5: E_GPIO1_5	<=>					IPi SMARC Plus CN101_PIN36: E_GPIO1_5
+		 * - 6: E_GPIO1_6	<=>					IPi SMARC Plus CN101_PIN37: E_GPIO1_6
+		 * - 7: E_GPIO1_7	<=>					IPi SMARC Plus CN101_PIN38: E_GPIO1_7
+		 * - 8: E_GPIO2_8	<=>					IPi SMARC Plus CN101_PIN40: E_GPIO2_8
+		 * - 9: TP1002		<=>					IPi SMARC Plus TP1002 (won't use)
+		 * - 10: TP1003		<=>					IPi SMARC Plus TP1003 (won't use)
+		 * - 11: TP1004		<=>					IPi SMARC Plus TP1004 (won't use)
+		 * - 12: TP1005		<=>					IPi SMARC Plus TP1005 (won't use)
+		 * - 13: TP1006		<=>					IPi SMARC Plus TP1006 (won't use)
+		 * - 14: TP1007		<=>					IPi SMARC Plus TP1007 (won't use)
+		 * - 15: TP1008		<=>					IPi SMARC Plus TP1008 (won't use)
+		 * - 16: OSCIO		<=>					IPi SMARC Plus TP1001 (won't use)
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio8_int>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio2>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+};
+
+&lpuart1 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+&lpuart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&lpuart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&lpuart5 {
+	/* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "nxp,88w8997-bt";
+	};
+};
+//SMARC SER0
+&lpuart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart7>;
+	status = "okay";
+};
+//SMARC SPI0
+&lpspi6 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi6>;
+	pinctrl-1 = <&pinctrl_lpspi6>;
+	cs-gpios = <&gpio2 0 GPIO_ACTIVE_LOW>,<&gpio2 24 GPIO_ACTIVE_LOW>;
+	status = "okay";
+        spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+
+};
+//SMARC SPI1
+&lpspi7 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi7>;
+	pinctrl-1 = <&pinctrl_lpspi7>;
+	cs-gpios = <&gpio2 4 GPIO_ACTIVE_LOW>,<&gpio2 25 GPIO_ACTIVE_LOW>;
+	status = "okay";
+    
+	spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        
+	spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+};
+
+&mu7 {
+	status = "okay";
+};
+//U1200 PTE7AAMI-64GI EMMC
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	no-sdio;
+	no-sd;
+	status = "okay";
+};
+//SMARC SDIO
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-3 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio3 00 GPIO_ACTIVE_LOW>;
+	//wp-gpios = <&gpio5 8 GPIO_ACTIVE_HIGH>; //need to remove if want to test on EVK
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&usdhc3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc3>;
+	keep-power-in-suspend;
+	wakeup-source;
+
+	vmmc-supply = <&reg_usdhc3_en>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+
+	mwifiex: wifi@1 {
+		compatible = "marvell,sd8997";
+		reg = <1>;
+
+		marvell,caldata_00_txpwrlimit_2g_cfg_set = /bits/ 8 <
+			 0x01 0x00 0x06 0x00 0x08 0x02 0x89 0x01>;
+		marvell,wakeup-pin = <14>;
+	};
+};
+/*U2001 RTL8211FI-CG_REALTEK*/
+&enetc_port0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc0>,<&pinctrl_ethphy0>;
+	phy-handle = <&ethphy0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+/*U2101 RTL8211FI-CG_REALTEK*/
+&enetc_port1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc1>,<&pinctrl_ethphy1>;
+	phy-handle = <&ethphy1>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+//SMARC
+&enetc_port2 {
+	phy-handle = <&ethphy2>;
+	phy-mode = "10gbase-r";
+	serdes-supply = <&reg_serdes_en>;
+	managed = "in-band-status";
+	//status = "okay";
+};
+
+&netc_timer {
+	status = "okay";
+};
+
+&netc_prb_ierb {
+	netc-interfaces = <NXP_NETC_RGMII
+			   NXP_NETC_RGMII
+			   NXP_NETC_SERIAL>;
+};
+
+&netc_emdio {	
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_emdio>;
+	status = "okay";
+
+	/*U2001 RTL8211FI-CG_REALTEK*/
+	ethphy0: ethernet-phy@1 {
+		reg = <1>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <16 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+	/*U2101 RTL8211FI-CG_REALTEK*/
+	ethphy1: ethernet-phy@4 {
+		reg = <4>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+//SMARC
+	ethphy2: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <8>;
+	};
+	
+};
+//4c200000 USB2 controller
+&usb2 {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&thermal_zones {
+
+	pf09 {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 2>;
+		trips {
+			pf09_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf09_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+
+	pf53_arm {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 4>;
+		trips {
+			pf5301_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5301_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+
+		cooling-maps {
+			map0 {
+				trip = <&pf5301_alert>;
+				cooling-device =
+					<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+	};
+
+	pf53_soc {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 3>;
+		trips {
+			pf5302_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5302_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+};
+//4c010010
+&usb3 {
+	status = "okay";
+};
+//4c1f0040
+&usb3_phy {
+	status = "okay";
+};
+//4c100000 USB1 controller
+&usb3_dwc3 {
+	dr_mode = "host";//this causes USB can't work , need to check
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	role-switch-default-mode = "none";
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	status = "okay";
+};
+
+&scmi_misc {
+	wakeup-sources = <BRD_SM_CTRL_SD3_WAKE		1
+			  BRD_SM_CTRL_PCIE1_WAKE	1
+			  BRD_SM_CTRL_BT_WAKE		1
+			  BRD_SM_CTRL_PCIE2_WAKE	1
+			  BRD_SM_CTRL_BUTTON		1>;
+};
+
+&scmi_iomuxc {
+
+	pinctrl_gpio8_int: gpio8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO22__GPIO2_IO_BIT22			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_tpm6: tpm6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO19__TPM6_CH2			0x51e
+			IMX95_PAD_GPIO_IO23__TPM6_CH1			0x51e
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			IMX95_PAD_PDM_CLK__AONMIX_TOP_CAN1_TX		0x39e
+			IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_CAN1_RX	0x39e
+		>;
+	};
+
+	pinctrl_flexcan5: flexcan5grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO30__CAN5_TX			0x39e
+			IMX95_PAD_GPIO_IO31__CAN5_RX			0x39e
+		>;
+	};
+
+	pinctrl_lpi2c2: lpi2c2grp {
+		fsl,pins = <
+			IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPI2C2_SCL	0x40000b9e
+			IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA	0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c3: lpi2c3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO28__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO29__LPI2C3_SCL			0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c8: lpi2c8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO12__LPI2C8_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO13__LPI2C8_SCL 		0x40000b9e
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			IMX95_PAD_UART1_RXD__AONMIX_TOP_LPUART1_RX      0x31e
+			IMX95_PAD_UART1_TXD__AONMIX_TOP_LPUART1_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			IMX95_PAD_UART2_RXD__AONMIX_TOP_LPUART2_RX      0x31e
+			IMX95_PAD_UART2_TXD__AONMIX_TOP_LPUART2_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO15__LPUART3_RX      0x31e
+			IMX95_PAD_GPIO_IO14__LPUART3_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			IMX95_PAD_DAP_TDO_TRACESWO__LPUART5_TX			0x31e
+			IMX95_PAD_DAP_TDI__LPUART5_RX				0x31e
+			IMX95_PAD_DAP_TMS_SWDIO__LPUART5_RTS_B			0x31e
+			IMX95_PAD_DAP_TCLK_SWCLK__LPUART5_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_uart7: uart7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO08__LPUART7_TX			0x31e
+			IMX95_PAD_GPIO_IO09__LPUART7_RX				0x31e
+			IMX95_PAD_GPIO_IO11__LPUART7_RTS_B			0x31e
+			IMX95_PAD_GPIO_IO10__LPUART7_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_pcie0: pcie0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO32__HSIOMIX_TOP_PCIE1_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_pcie1: pcie1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO35__HSIOMIX_TOP_PCIE2_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_lpspi6: lpspi6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO00__GPIO2_IO_BIT0	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO24__GPIO2_IO_BIT24	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO01__LPSPI6_SIN		0x3fe
+			IMX95_PAD_GPIO_IO02__LPSPI6_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO03__LPSPI6_SCK		0x3fe
+		>;
+	};
+	pinctrl_lpspi7: lpspi7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO25__GPIO2_IO_BIT25	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO04__GPIO2_IO_BIT4	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO05__LPSPI7_SIN		0x3fe
+			IMX95_PAD_GPIO_IO06__LPSPI7_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO07__LPSPI7_SCK		0x3fe
+		>;
+	};
+
+	pinctrl_emdio: emdiogrp{
+		fsl,pins = <
+			IMX95_PAD_ENET1_MDC__NETCMIX_TOP_NETC_MDC		0x57e
+			IMX95_PAD_ENET1_MDIO__NETCMIX_TOP_NETC_MDIO		0x97e
+		>;
+	};
+
+
+	pinctrl_enetc0: enetc0grp {
+		fsl,pins = <
+			IMX95_PAD_ENET1_TD3__NETCMIX_TOP_ETH0_RGMII_TD3		0x57e
+			IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RGMII_TD2		0x57e
+			IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RGMII_TD1		0x57e
+			IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RGMII_TD0		0x57e
+			IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET1_TXC__NETCMIX_TOP_ETH0_RGMII_TX_CLK	0x58e
+			IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RGMII_RX_CLK	0x58e
+			IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RGMII_RD0		0x57e
+			IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RGMII_RD1		0x57e
+			IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RGMII_RD2		0x57e
+			IMX95_PAD_ENET1_RD3__NETCMIX_TOP_ETH0_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_enetc1: enetc1grp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_TD3__NETCMIX_TOP_ETH1_RGMII_TD3		0x57e
+			IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RGMII_TD2		0x57e
+			IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RGMII_TD1		0x57e
+			IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RGMII_TD0		0x57e
+			IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET2_TXC__NETCMIX_TOP_ETH1_RGMII_TX_CLK	0x5fe
+			IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RGMII_RX_CLK	0x5fe
+			IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RGMII_RD0		0x57e
+			IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RGMII_RD1		0x57e
+			IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RGMII_RD2		0x57e
+			IMX95_PAD_ENET2_RD3__NETCMIX_TOP_ETH1_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_flexspi1: flexspi1grp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_SS0_B__FLEXSPI1_A_SS0_B			0x3fe
+			IMX95_PAD_XSPI1_SCLK__FLEXSPI1_A_SCLK			0x3fe
+			IMX95_PAD_XSPI1_DATA0__FLEXSPI1_A_DATA_BIT0		0x3fe
+			IMX95_PAD_XSPI1_DATA1__FLEXSPI1_A_DATA_BIT1		0x3fe
+			IMX95_PAD_XSPI1_DATA2__FLEXSPI1_A_DATA_BIT2		0x3fe
+			IMX95_PAD_XSPI1_DATA3__FLEXSPI1_A_DATA_BIT3		0x3fe
+		>;
+	};
+
+	pinctrl_i2c2_tpm: i2c2tpmgrp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO27__GPIO2_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_rtc: i2c3rtcgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDC__GPIO4_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_SMB_INT_B_1V8: SMB_INT_B_1V8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO18__GPIO2_IO_BIT18			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_ethphy0: ethphy0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO36__GPIO5_IO_BIT16			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_ethphy1: ethphy1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO37__GPIO5_IO_BIT17			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_i2c8_adl1001: i2c8adl1001grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_adl1000: i2c8adl1000grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO33__GPIO5_IO_BIT13			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_mipi_dsi_csi: mipidsigrp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO2__GPIO3_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_pcal6416: pcal6416grp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO3__GPIO4_IO_BIT28			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sx1509q: sx1509qgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sai1: sai1grp {
+		fsl,pins = <
+			IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0    0x31e
+			IMX95_PAD_SAI1_TXC__AONMIX_TOP_SAI1_TX_BCLK      0x31e
+			IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_SYNC     0x31e
+			IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0    0x31e
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO17__SAI3_MCLK				0x31e
+			IMX95_PAD_GPIO_IO16__SAI3_TX_BCLK			0x31e
+			IMX95_PAD_GPIO_IO26__SAI3_TX_SYNC			0x31e
+			IMX95_PAD_GPIO_IO20__SAI3_RX_DATA_BIT0			0x31e
+			IMX95_PAD_GPIO_IO21__SAI3_TX_DATA_BIT0			0x31e
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x15fe
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x13fe
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x13fe
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x13fe
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x13fe
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x13fe
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x13fe
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x13fe
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x13fe
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x13fe
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x15fe
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_RESET_B__GPIO3_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_leds: ledsgrp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_DATA7__GPIO5_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CD_B__GPIO3_IO_BIT0			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_XSPI1_DQS__GPIO5_IO_BIT8			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x158e
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x138e
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x138e
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x138e
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x138e
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x138e
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x15fe
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x13fe
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x13fe
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x13fe
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x13fe
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x13fe
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x15fe
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x13fe
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x13fe
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x13fe
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x13fe
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x13fe
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+};
+
+&vpuctrl {
+	boot = <&vpu_boot>;
+	sram = <&sram1>;
+};
+
+&wdog3 {
+	status = "okay";
+};
+/* SMARC PCIE_A*/
+&pcie0 {
+	pinctrl-0 = <&pinctrl_pcie0>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 6 GPIO_ACTIVE_LOW>; //PCIEA_RST#_3V
+	vpcie-supply = <&reg_pcie0>;
+	status = "okay";
+};
+/* U1900 AW-CM276NF */
+&pcie1 {
+	pinctrl-0 = <&pinctrl_pcie1>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 7 GPIO_ACTIVE_LOW>; //PCIEB_RST#_3V
+	status = "okay";
+};
+
+&pcie1_ep {
+       pinctrl-0 = <&pinctrl_pcie1>;
+       pinctrl-names = "default";
+       fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+       //vpcie-supply = <&reg_slot_pwr>;
+       status = "disabled";
+};
+
+
+/* U1500 LT9611_LONTIUM */
+&sai1 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI1>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&sai3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI3>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+
diff --git a/arch/arm64/boot/dts/freescale/lec-imx95.dts b/arch/arm64/boot/dts/freescale/lec-imx95.dts
new file mode 100644
index 000000000000..81a40e64eb92
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lec-imx95.dts
@@ -0,0 +1,1264 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2023 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/phy/phy-imx8-pcie.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/usb/pd.h>
+#include "imx95.dtsi"
+
+#define FALLING_EDGE		BIT(0)
+#define RISING_EDGE		BIT(1)
+
+#define BRD_SM_CTRL_SD3_WAKE		0x8000	/*!< PCAL6408A-0 */
+#define BRD_SM_CTRL_PCIE1_WAKE		0x8001	/*!< PCAL6408A-4 */
+#define BRD_SM_CTRL_BT_WAKE		0x8002	/*!< PCAL6408A-5 */
+#define BRD_SM_CTRL_PCIE2_WAKE		0x8003	/*!< PCAL6408A-6 */
+#define BRD_SM_CTRL_BUTTON		0x8004	/*!< PCAL6408A-7 */
+
+/ {
+	model = "ADLINK i.MX95 19X19 board";
+	compatible = "fsl,imx95-19x19-evk", "fsl,imx95";
+
+	aliases {
+		ethernet0 = &enetc_port0;
+		ethernet1 = &enetc_port1;
+	};
+
+	chosen {
+		stdout-path = &lpuart1;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		/* will be updated by U-boot when booting Xen */
+		module@0 {
+			bootargs = "earlycon=xen console=hvc0 loglevel=8 root=/dev/mmcblk1p2 rw rootwait";
+			compatible = "xen,linux-zimage", "xen,multiboot-module";
+			reg = <0x00000000 0x9e000000 0x00000000 0x2000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+
+		key_sleep {
+			label = "SLEEP";
+			linux,code = <KEY_SLEEP>;
+			gpios = <&i2c2_gpio_expander_71 10 GPIO_ACTIVE_LOW>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_leds>;
+
+		led-1 {
+			label = "sys_status_1v8";
+			default-state = "on";
+			gpios = <&gpio5 7 GPIO_ACTIVE_HIGH>;
+		};
+
+	};
+
+	/*
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		pwms = <&tpm5 1 4000000 PWM_POLARITY_INVERTED>;
+		cooling-levels = <64 128 192 255>;
+	};
+*/
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux_cma: linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x3c000000>;
+			alloc-ranges = <0 0x80000000 0 0x7F000000>;
+			linux,cma-default;
+		};
+
+		vpu_boot: vpu_boot@a0000000 {
+			reg = <0 0xa0000000 0 0x100000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@88000000 {
+			reg = <0 0x88000000 0 0x8000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@88008000 {
+			reg = <0 0x88008000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring0: vdev1vring0@88010000 {
+			reg = <0 0x88010000 0 0x8000>;
+			no-map;
+		};
+
+		vdev1vring1: vdev1vring1@88018000 {
+			reg = <0 0x88018000 0 0x8000>;
+			no-map;
+		};
+
+		rsc_table: rsc-table@88220000 {
+			reg = <0 0x88220000 0 0x1000>;
+			no-map;
+		};
+
+		vdevbuffer: vdevbuffer@88020000 {
+			compatible = "shared-dma-pool";
+			reg = <0 0x88020000 0 0x100000>;
+			no-map;
+		};
+	};
+
+	reg_1p8v: regulator-1p8v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <1800000>;
+		regulator-min-microvolt = <1800000>;
+		regulator-name = "+V1.8_SW";
+	};
+
+	reg_3p3v: regulator-3p3v {
+		compatible = "regulator-fixed";
+		regulator-max-microvolt = <3300000>;
+		regulator-min-microvolt = <3300000>;
+		regulator-name = "+V3.3_SW";
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VDD_SD2_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio3 7 GPIO_ACTIVE_HIGH>;
+		off-on-delay-us = <12000>;
+		enable-active-high;
+	};
+
+	reg_usdhc3_en: regulator-usdhc3-en {
+		compatible = "regulator-fixed";
+		regulator-name = "usdhc3-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c3_adl1000 22 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_pcie0: regulator-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "PCIE_WLAN_EN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&i2c2_gpio_expander_71 3 GPIO_ACTIVE_HIGH>; //RC210_EN_3V
+		enable-active-high;
+		regulator-always-on;
+	};
+
+	reg_vref_1v8: regulator-adc-vref {
+		compatible = "regulator-fixed";
+		regulator-name = "vref_1v8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	reg_usb_vbus: regulator-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		/*
+		gpio = <&i2c7_pcal6524 3 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		*/
+	};
+
+	reg_tpm_rst: regulator-tmp {
+		compatible = "regulator-fixed";
+		regulator-name = "TPM_RST";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio =  <&i2c2_gpio_expander_71 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+		startup-delay-us = <5000>;
+	};
+
+	reg_serdes_en: regulator-mac-en {
+		compatible = "regulator-fixed";
+		regulator-name = "mac-en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		//vin-supply = <&reg_serdes_stby>;
+		gpio = <&i2c3_adl1000 6 GPIO_ACTIVE_HIGH>;//ETH_CLK_EN_1V8 
+	};
+
+	cm7: imx95-cm7 {
+		compatible = "fsl,imx95-cm7";
+		mbox-names = "tx", "rx", "rxdb";
+		mboxes = <&mu7 0 1
+			  &mu7 1 1
+			  &mu7 3 1>;
+		memory-region = <&vdevbuffer>, <&vdev0vring0>, <&vdev0vring1>,
+				<&vdev1vring0>, <&vdev1vring1>, <&rsc_table>;
+		fsl,startup-delay-ms = <50>;
+		status = "okay";
+	};
+
+	/* SMARC BB CN1701 */
+	sound-tlv320aic3x {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tlv320aic3x";
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"MIC3L", "Microphone Jack",
+			"MIC3R", "Microphone Jack",
+			"Headphone Jack", "HPLOUT",
+			"Headphone Jack", "HPROUT";
+
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&sound_master>;
+		simple-audio-card,frame-master = <&sound_master>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+		};
+
+		sound_master: simple-audio-card,codec {
+			sound-dai = <&tlv320aic3x07>;
+		};
+	};
+
+};
+
+&adc1 {
+	vref-supply = <&reg_vref_1v8>;
+	status = "okay";
+};
+
+&displaymix_irqsteer {
+	status = "okay";
+};
+
+&dpu {
+	status = "okay";
+};
+
+/*
+&tpm5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm5>;
+	pwm-rst;
+	status = "okay";
+};
+*/
+&tpm6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_tpm6>;
+	pwm-rst;
+	status = "okay";
+};
+
+/* pin conflict with PDM */
+/*&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	status = "okay";
+};*/
+
+&flexcan5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan5>;
+	status = "okay";
+};
+
+&flexspi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_flexspi1>;
+	pinctrl-1 = <&pinctrl_flexspi1>;
+	status = "okay";
+
+	/*U2200 W25Q64JWXGIQ*/
+	flash0: W25Q64JWXGIQ@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <133000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c2>;
+	pinctrl-1 = <&pinctrl_lpi2c2>;
+	status = "okay";
+
+	/*U1000 SX1509BIULTRT_SEMTECH */
+	i2c2_gpio_expander_71: i2c2_gpio_expander_71@71 {
+		/* GPIO Expander  Mapping :
+		 * - 0: ENET1_RST_B_3V			=>			U2001
+		 * - 1: ENET2_RST_B_3V			=>			U2101			
+		 * - 2: USB_HUB_RST#_3V			=>			U1800			
+		 * - 3: RC210_EN_3V			=>			U1300 ,RC21008B001GND
+		 * - 4: LT9611_RSTN_3V			=>			U1500
+		 * - 5: HDMI_INT_3V				<= 			U1500
+		 * - 6: PCIEA_RST#_3V			=>			SMARC P75	
+		 * - 7: PCIEB_RST#_3V			=>			SMARC S76			
+		 * - 8: TPM_RST_N_1V8			=> 			U2400
+		 * - 9: LID#_1V8				<= R1005	SMARC S148
+		 * - 10: SLEEP#_1V8				<= R1010	SMARC S149
+		 * - 11: CHARGING#_1V8			<= R1007	SMARC S151
+		 * - 12: CHARGER_PRSNT#_1V8		<= R1011	SMARC S152
+		 * - 13: BATLOW#_1V8			<= R1014	SMARC S156
+		 * - 14: TEST#_1V8				<= R1015	SMARC S157
+		 * - 15: DSI0_TE_1V8    		<= R1087	SMARC S144
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x71>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+		interrupt-parent = <&gpio4>;
+		interrupts = <15 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_sx1509q>;
+
+		status = "okay";
+	};
+	/* U2400 TPM - ST33HTPH2X32AHD5_ST */
+	st33tphf2xi2c@2e {
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		//compatible = "st,st33htpm-i2c";
+		compatible = "infineon,slb9673";
+		reg = <0x2e>;
+
+		label = "tpm";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c2_tpm>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <27 IRQ_TYPE_LEVEL_LOW>;
+
+		tpm-supply = <&reg_tpm_rst>;
+		status = "okay";
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c3>;
+	pinctrl-1 = <&pinctrl_lpi2c3>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU GPIO */
+	i2c3_adl1000: i2c3_adl1000@20 {
+		compatible = "adlink,adl1000";
+		pinctrl-names = "default";
+		//interrupt pin A3, A4, B0, B1, B2, B5, B6, B10, B11, B12, B13, B14, B15
+		//INT : PC2 , SCL : PB8 , SDA : PB9
+		/* GPIO Expander  Mapping :
+		 * - 0: PA0 		LCD1_VDD_EN_1V8			=>			SMARC S116 LCD1_VDD_EN
+		 * - 1: PA1 		LCD1_BKLT_EN_1V8		=>			SMARC S107 LCD1_BKLT_EN
+		 * - 2: PA3(int)	CN_GPIO13_1V8			=>			SMARC S123 GPIO13
+		 * - 3: PA4(int) 	CN_GPIO12_1V8			=>			SMARC S142 GPIO12
+		 * - 4: PA5 		Detect_SYS_1V8			<=			R1040 VDD_1V8_S
+		 * - 5: PA6 		MCU_PWRBTN_ON_1V8		=>			R2812 U2802(AND gate) PMIC_ON_MCU_1V8
+		 * - 6: PA7 		ETH_CLK_EN_1V8			=>			U1300 RC21008B001GND#BB0_RENESAS GPIO4
+		 * - 7: PA10 		ONOFF_1V8	    		=> 			U600 (IMX95)
+
+		 * - 8: PA11 		LCD0_VDD_EN_1V8	    	=> 			SMARC S133 LCD0_VDD_EN
+		 * - 9: PA12 		LCD0_BKLT_EN_1V8		=>			SMARC S127 LCD0_BKLT_EN
+		 * - 10: PB0(int) 	CN_GPIO0_CAM0_PWR#_1V8			=>	SMARC P108 CAM0_PWR
+		 * - 11: PB1(int) 	CN_GPIO1_CAM1_PWR#_1V8			=> 	SMARC P109 CAM1_PWR
+		 * - 12: PB2(int) 	CN_GPIO2_CAM0_RST#_1V8			=> 	SMARC P110 CAM0_RST
+		 * - 13: PB5(int) 	CN_GPIO3_CAM1_RST#_1V8			=>  SMARC P111 CAM1_RST
+		 * - 14: PB6(int) 	CN_GPIO4_1V8			=> 			SMARC P112 GPIO4
+		 * - 15: PB10(int) 	CN_GPIO11_1V8			=>			SMARC P119 GPIO11
+
+		 * - 16: PB11(int) 	CN_GPIO6_1V8			=>			SMARC P114 GPIO6
+		 * - 17: PB12(int) 	CN_GPIO7_1V8			=>			SMARC P115 GPIO7
+		 * - 18: PB13(int) 	CN_GPIO8_1V8			=> 			SMARC P116 GPIO8
+		 * - 19: PB14(int) 	CN_GPIO9_1V8    		=>			SMARC P117 GPIO9
+		 * - 20: PB15(int) 	CN_GPIO10_1V8			=>			SMARC P118 GPIO10
+		 * - 21: PC3 		HOST_WAKE_BT_IN#_1V8	=>			U1900 AW-CM276NF pull-up
+		 * - 22: PC4 		WL_PWR_DOWN#_1V8		=>			U1900 AW-CM276NF pull-up
+		 * - 23: PC5 		HOST_WAKE_WL_IN_1V8		=>			U1900 AW-CM276NF pull-down
+		 */
+		pinctrl-0 = <&pinctrl_i2c3_adl1000>;
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>; // MCU_INTB1_1V8 , PC2
+
+	};
+	/*U2401 RTC PCF8563BS/4_NXP */
+	pcf8563: rtc@51 {
+		compatible = "nxp,pcf8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_i2c3_rtc>;
+		reg = <0x51>;
+		#clock-cells = <0>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&lpi2c8 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpi2c8>;
+	pinctrl-1 = <&pinctrl_lpi2c8>;
+	status = "okay";
+
+	/*U1001 ADLINK MCU UART */
+	i2c8_adl1001: i2c8_adl1001@48 {
+		compatible = "adlink,adl1001";
+		pinctrl-names = "default";
+		
+		pinctrl-0 = <&pinctrl_i2c8_adl1001>;
+		reg = <0x48>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>; //MCU_INTB2_1V8 , PD2
+	};
+	/* SMARC BB CN1701 */
+    tlv320aic3x07: tlv320aic310x@18 {
+		clock-names = "mclk";
+		clocks = <&scmi_clk IMX95_CLK_SAI3>;
+		compatible = "ti,tlv320aic3x";
+		#sound-dai-cells = <0>;
+		reg = <0x18>;
+		ai3x-micbias-vg = <2>; /* MICBIAS_2_5V */
+		status = "okay";
+        };
+
+	/* SX1509(2) U1001@IPi SMARC Plus */
+	gpio8: i2c2_gpioext0@3e {
+		/* GPIO Expander 2 Mapping :
+		 * - 0: E_GPIO1_0	<=>					IPi SMARC Plus CN101_PIN29: E_GPIO1_0
+		 * - 1: E_GPIO1_1	<=>					IPi SMARC Plus CN101_PIN31: E_GPIO1_1
+		 * - 2: E_GPIO1_2	<=>					IPi SMARC Plus CN101_PIN32: E_GPIO1_2
+		 * - 3: E_GPIO1_3	<=>					IPi SMARC Plus CN101_PIN33: E_GPIO1_3
+		 * - 4: E_GPIO1_4	<=>					IPi SMARC Plus CN101_PIN35: E_GPIO1_4
+		 * - 5: E_GPIO1_5	<=>					IPi SMARC Plus CN101_PIN36: E_GPIO1_5
+		 * - 6: E_GPIO1_6	<=>					IPi SMARC Plus CN101_PIN37: E_GPIO1_6
+		 * - 7: E_GPIO1_7	<=>					IPi SMARC Plus CN101_PIN38: E_GPIO1_7
+		 * - 8: E_GPIO2_8	<=>					IPi SMARC Plus CN101_PIN40: E_GPIO2_8
+		 * - 9: TP1002		<=>					IPi SMARC Plus TP1002 (won't use)
+		 * - 10: TP1003		<=>					IPi SMARC Plus TP1003 (won't use)
+		 * - 11: TP1004		<=>					IPi SMARC Plus TP1004 (won't use)
+		 * - 12: TP1005		<=>					IPi SMARC Plus TP1005 (won't use)
+		 * - 13: TP1006		<=>					IPi SMARC Plus TP1006 (won't use)
+		 * - 14: TP1007		<=>					IPi SMARC Plus TP1007 (won't use)
+		 * - 15: TP1008		<=>					IPi SMARC Plus TP1008 (won't use)
+		 * - 16: OSCIO		<=>					IPi SMARC Plus TP1001 (won't use)
+		 */
+		#gpio-cells = <2>;
+		#interrupt-cells = <2>;
+		compatible = "semtech,sx1509q";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio8_int>;
+
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
+
+		interrupt-parent = <&gpio2>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
+};
+
+&lpuart1 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "okay";
+};
+
+/*&lpuart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};*/
+
+/*U1900 AW-CM276NF*/
+&lpuart5 {
+	/* BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "nxp,88w8997-bt";
+	};
+};
+//SMARC SER0
+&lpuart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart7>;
+	status = "okay";
+};
+//SMARC SPI0
+&lpspi6 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi6>;
+	pinctrl-1 = <&pinctrl_lpspi6>;
+	cs-gpios = <&gpio2 0 GPIO_ACTIVE_LOW>,<&gpio2 24 GPIO_ACTIVE_LOW>;
+	status = "okay";
+        spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+
+};
+//SMARC SPI1
+&lpspi7 {
+	fsl,spi-num-chipselects = <2>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&pinctrl_lpspi7>;
+	pinctrl-1 = <&pinctrl_lpspi7>;
+	cs-gpios = <&gpio2 4 GPIO_ACTIVE_LOW>,<&gpio2 25 GPIO_ACTIVE_LOW>;
+	status = "okay";
+    
+	spidev@0 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <0>;
+        };
+        
+	spidev@1 {
+                compatible = "rohm,dh2228fv";
+                spi-max-frequency = <5000000>;
+                reg = <1>;
+	};
+};
+
+&mu7 {
+	status = "okay";
+};
+//U1200 PTE7AAMI-64GI EMMC
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc1>;
+	bus-width = <8>;
+	non-removable;
+	no-sdio;
+	no-sd;
+	status = "okay";
+};
+//SMARC SDIO
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-3 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	cd-gpios = <&gpio3 00 GPIO_ACTIVE_LOW>;
+	//wp-gpios = <&gpio5 8 GPIO_ACTIVE_HIGH>; //need to remove if want to test on EVK
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/*U1900 AW-CM276NF*/
+&usdhc3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz", "sleep";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	pinctrl-3 = <&pinctrl_usdhc3>;
+	keep-power-in-suspend;
+	wakeup-source;
+
+	vmmc-supply = <&reg_usdhc3_en>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+
+	mwifiex: wifi@1 {
+		compatible = "marvell,sd8997";
+		reg = <1>;
+
+		marvell,caldata_00_txpwrlimit_2g_cfg_set = /bits/ 8 <
+			 0x01 0x00 0x06 0x00 0x08 0x02 0x89 0x01>;
+		marvell,wakeup-pin = <14>;
+	};
+};
+/*U2001 RTL8211FI-CG_REALTEK*/
+&enetc_port0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc0>,<&pinctrl_ethphy0>;
+	phy-handle = <&ethphy0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+/*U2101 RTL8211FI-CG_REALTEK*/
+&enetc_port1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enetc1>,<&pinctrl_ethphy1>;
+	phy-handle = <&ethphy1>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+};
+//SMARC
+&enetc_port2 {
+	phy-handle = <&ethphy2>;
+	phy-mode = "10gbase-r";
+	serdes-supply = <&reg_serdes_en>;
+	managed = "in-band-status";
+	//status = "okay";
+};
+
+&netc_timer {
+	status = "okay";
+};
+
+&netc_prb_ierb {
+	netc-interfaces = <NXP_NETC_RGMII
+			   NXP_NETC_RGMII
+			   NXP_NETC_SERIAL>;
+};
+
+&netc_emdio {	
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_emdio>;
+	status = "okay";
+
+	/*U2001 RTL8211FI-CG_REALTEK*/
+	ethphy0: ethernet-phy@1 {
+		reg = <1>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <16 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+	/*U2101 RTL8211FI-CG_REALTEK*/
+	ethphy1: ethernet-phy@4 {
+		reg = <4>;
+		eee-broken-1000t;
+		
+		reset-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		interrupt-parent = <&gpio5>;
+		interrupts = <17 IRQ_TYPE_EDGE_FALLING>;
+
+		realtek,clkout-disable;
+	};
+//SMARC
+	ethphy2: ethernet-phy@8 {
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <8>;
+	};
+	
+};
+//4c200000 USB2 controller
+&usb2 {
+	dr_mode = "host";
+	vbus-supply = <&reg_usb_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&thermal_zones {
+
+	pf09 {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 2>;
+		trips {
+			pf09_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf09_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+
+	pf53_arm {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 4>;
+		trips {
+			pf5301_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5301_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+
+		cooling-maps {
+			map0 {
+				trip = <&pf5301_alert>;
+				cooling-device =
+					<&A55_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_4 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					<&A55_5 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+			};
+		};
+	};
+
+	pf53_soc {
+		polling-delay-passive = <250>;
+		polling-delay = <2000>;
+		thermal-sensors = <&scmi_sensor 3>;
+		trips {
+			pf5302_alert: trip0 {
+				temperature = <140000>;
+				hysteresis = <2000>;
+				type = "passive";
+			};
+
+			pf5302_crit: trip1 {
+				temperature = <155000>;
+				hysteresis = <2000>;
+				type = "critical";
+			};
+		};
+	};
+};
+//4c010010
+&usb3 {
+	status = "okay";
+};
+//4c1f0040
+&usb3_phy {
+	fsl,phy-tx-vref-tune-percent = <0x73>;
+	status = "okay";
+};
+//4c100000 USB1 controller
+&usb3_dwc3 {
+	dr_mode = "host";//this causes USB can't work , need to check
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	role-switch-default-mode = "none";
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	status = "okay";
+};
+
+&scmi_misc {
+	wakeup-sources = <BRD_SM_CTRL_SD3_WAKE		1
+			  BRD_SM_CTRL_PCIE1_WAKE	1
+			  BRD_SM_CTRL_BT_WAKE		1
+			  BRD_SM_CTRL_PCIE2_WAKE	1
+			  BRD_SM_CTRL_BUTTON		1>;
+};
+
+&scmi_iomuxc {
+
+	pinctrl_gpio8_int: gpio8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO22__GPIO2_IO_BIT22			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_tpm6: tpm6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO19__TPM6_CH2			0x51e
+			IMX95_PAD_GPIO_IO23__TPM6_CH1			0x51e
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			IMX95_PAD_PDM_CLK__AONMIX_TOP_CAN1_TX		0x39e
+			IMX95_PAD_PDM_BIT_STREAM0__AONMIX_TOP_CAN1_RX	0x39e
+		>;
+	};
+
+	pinctrl_flexcan5: flexcan5grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO30__CAN5_TX			0x39e
+			IMX95_PAD_GPIO_IO31__CAN5_RX			0x39e
+		>;
+	};
+
+	pinctrl_lpi2c2: lpi2c2grp {
+		fsl,pins = <
+			IMX95_PAD_I2C2_SCL__AONMIX_TOP_LPI2C2_SCL	0x40000b9e
+			IMX95_PAD_I2C2_SDA__AONMIX_TOP_LPI2C2_SDA	0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c3: lpi2c3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO28__LPI2C3_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO29__LPI2C3_SCL			0x40000b9e
+		>;
+	};
+
+	pinctrl_lpi2c8: lpi2c8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO12__LPI2C8_SDA			0x40000b9e
+			IMX95_PAD_GPIO_IO13__LPI2C8_SCL 		0x40000b9e
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			IMX95_PAD_UART1_RXD__AONMIX_TOP_LPUART1_RX      0x31e
+			IMX95_PAD_UART1_TXD__AONMIX_TOP_LPUART1_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO15__LPUART3_RX      0x31e
+			IMX95_PAD_GPIO_IO14__LPUART3_TX      0x31e
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			IMX95_PAD_DAP_TDO_TRACESWO__LPUART5_TX			0x31e
+			IMX95_PAD_DAP_TDI__LPUART5_RX				0x31e
+			IMX95_PAD_DAP_TMS_SWDIO__LPUART5_RTS_B			0x31e
+			IMX95_PAD_DAP_TCLK_SWCLK__LPUART5_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_uart7: uart7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO08__LPUART7_TX			0x31e
+			IMX95_PAD_GPIO_IO09__LPUART7_RX				0x31e
+			IMX95_PAD_GPIO_IO11__LPUART7_RTS_B			0x31e
+			IMX95_PAD_GPIO_IO10__LPUART7_CTS_B			0x31e
+		>;
+	};
+
+	pinctrl_pcie0: pcie0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO32__HSIOMIX_TOP_PCIE1_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_pcie1: pcie1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO35__HSIOMIX_TOP_PCIE2_CLKREQ_B		0x40000b1e
+		>;
+	};
+
+	pinctrl_lpspi6: lpspi6grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO00__GPIO2_IO_BIT0	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO24__GPIO2_IO_BIT24	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO01__LPSPI6_SIN		0x3fe
+			IMX95_PAD_GPIO_IO02__LPSPI6_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO03__LPSPI6_SCK		0x3fe
+		>;
+	};
+	pinctrl_lpspi7: lpspi7grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO25__GPIO2_IO_BIT25	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO04__GPIO2_IO_BIT4	0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_GPIO_IO05__LPSPI7_SIN		0x3fe
+			IMX95_PAD_GPIO_IO06__LPSPI7_SOUT	0x3fe
+			IMX95_PAD_GPIO_IO07__LPSPI7_SCK		0x3fe
+		>;
+	};
+
+	pinctrl_emdio: emdiogrp{
+		fsl,pins = <
+			IMX95_PAD_ENET1_MDC__NETCMIX_TOP_NETC_MDC		0x57e
+			IMX95_PAD_ENET1_MDIO__NETCMIX_TOP_NETC_MDIO		0x97e
+		>;
+	};
+
+
+	pinctrl_enetc0: enetc0grp {
+		fsl,pins = <
+			IMX95_PAD_ENET1_TD3__NETCMIX_TOP_ETH0_RGMII_TD3		0x57e
+			IMX95_PAD_ENET1_TD2__NETCMIX_TOP_ETH0_RGMII_TD2		0x57e
+			IMX95_PAD_ENET1_TD1__NETCMIX_TOP_ETH0_RGMII_TD1		0x57e
+			IMX95_PAD_ENET1_TD0__NETCMIX_TOP_ETH0_RGMII_TD0		0x57e
+			IMX95_PAD_ENET1_TX_CTL__NETCMIX_TOP_ETH0_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET1_TXC__NETCMIX_TOP_ETH0_RGMII_TX_CLK	0x58e
+			IMX95_PAD_ENET1_RX_CTL__NETCMIX_TOP_ETH0_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET1_RXC__NETCMIX_TOP_ETH0_RGMII_RX_CLK	0x58e
+			IMX95_PAD_ENET1_RD0__NETCMIX_TOP_ETH0_RGMII_RD0		0x57e
+			IMX95_PAD_ENET1_RD1__NETCMIX_TOP_ETH0_RGMII_RD1		0x57e
+			IMX95_PAD_ENET1_RD2__NETCMIX_TOP_ETH0_RGMII_RD2		0x57e
+			IMX95_PAD_ENET1_RD3__NETCMIX_TOP_ETH0_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_enetc1: enetc1grp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_TD3__NETCMIX_TOP_ETH1_RGMII_TD3		0x57e
+			IMX95_PAD_ENET2_TD2__NETCMIX_TOP_ETH1_RGMII_TD2		0x57e
+			IMX95_PAD_ENET2_TD1__NETCMIX_TOP_ETH1_RGMII_TD1		0x57e
+			IMX95_PAD_ENET2_TD0__NETCMIX_TOP_ETH1_RGMII_TD0		0x57e
+			IMX95_PAD_ENET2_TX_CTL__NETCMIX_TOP_ETH1_RGMII_TX_CTL	0x57e
+			IMX95_PAD_ENET2_TXC__NETCMIX_TOP_ETH1_RGMII_TX_CLK	0x5fe
+			IMX95_PAD_ENET2_RX_CTL__NETCMIX_TOP_ETH1_RGMII_RX_CTL	0x57e
+			IMX95_PAD_ENET2_RXC__NETCMIX_TOP_ETH1_RGMII_RX_CLK	0x5fe
+			IMX95_PAD_ENET2_RD0__NETCMIX_TOP_ETH1_RGMII_RD0		0x57e
+			IMX95_PAD_ENET2_RD1__NETCMIX_TOP_ETH1_RGMII_RD1		0x57e
+			IMX95_PAD_ENET2_RD2__NETCMIX_TOP_ETH1_RGMII_RD2		0x57e
+			IMX95_PAD_ENET2_RD3__NETCMIX_TOP_ETH1_RGMII_RD3		0x57e
+		>;
+	};
+
+	pinctrl_flexspi1: flexspi1grp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_SS0_B__FLEXSPI1_A_SS0_B			0x3fe
+			IMX95_PAD_XSPI1_SCLK__FLEXSPI1_A_SCLK			0x3fe
+			IMX95_PAD_XSPI1_DATA0__FLEXSPI1_A_DATA_BIT0		0x3fe
+			IMX95_PAD_XSPI1_DATA1__FLEXSPI1_A_DATA_BIT1		0x3fe
+			IMX95_PAD_XSPI1_DATA2__FLEXSPI1_A_DATA_BIT2		0x3fe
+			IMX95_PAD_XSPI1_DATA3__FLEXSPI1_A_DATA_BIT3		0x3fe
+		>;
+	};
+
+	pinctrl_i2c2_tpm: i2c2tpmgrp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO27__GPIO2_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_rtc: i2c3rtcgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDC__GPIO4_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_SMB_INT_B_1V8: SMB_INT_B_1V8grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO18__GPIO2_IO_BIT18			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_ethphy0: ethphy0grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO36__GPIO5_IO_BIT16			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_ethphy1: ethphy1grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO37__GPIO5_IO_BIT17			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_i2c8_adl1001: i2c8adl1001grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO34__GPIO5_IO_BIT14			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_i2c3_adl1000: i2c8adl1000grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO33__GPIO5_IO_BIT13			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+	pinctrl_mipi_dsi_csi: mipidsigrp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO2__GPIO3_IO_BIT27			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_pcal6416: pcal6416grp {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO3__GPIO4_IO_BIT28			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sx1509q: sx1509qgrp {
+		fsl,pins = <
+			IMX95_PAD_ENET2_MDIO__GPIO4_IO_BIT15			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_sai1: sai1grp {
+		fsl,pins = <
+			IMX95_PAD_SAI1_RXD0__AONMIX_TOP_SAI1_RX_DATA_BIT0    0x31e
+			IMX95_PAD_SAI1_TXC__AONMIX_TOP_SAI1_TX_BCLK      0x31e
+			IMX95_PAD_SAI1_TXFS__AONMIX_TOP_SAI1_TX_SYNC     0x31e
+			IMX95_PAD_SAI1_TXD0__AONMIX_TOP_SAI1_TX_DATA_BIT0    0x31e
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			IMX95_PAD_GPIO_IO17__SAI3_MCLK				0x31e
+			IMX95_PAD_GPIO_IO16__SAI3_TX_BCLK			0x31e
+			IMX95_PAD_GPIO_IO26__SAI3_TX_SYNC			0x31e
+			IMX95_PAD_GPIO_IO20__SAI3_RX_DATA_BIT0			0x31e
+			IMX95_PAD_GPIO_IO21__SAI3_TX_DATA_BIT0			0x31e
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x158e
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x138e
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x138e
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x138e
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x138e
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x138e
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x138e
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x138e
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x138e
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x138e
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x158e
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD1_CLK__USDHC1_CLK				0x15fe
+			IMX95_PAD_SD1_CMD__USDHC1_CMD				0x13fe
+			IMX95_PAD_SD1_DATA0__USDHC1_DATA0			0x13fe
+			IMX95_PAD_SD1_DATA1__USDHC1_DATA1			0x13fe
+			IMX95_PAD_SD1_DATA2__USDHC1_DATA2			0x13fe
+			IMX95_PAD_SD1_DATA3__USDHC1_DATA3			0x13fe
+			IMX95_PAD_SD1_DATA4__USDHC1_DATA4			0x13fe
+			IMX95_PAD_SD1_DATA5__USDHC1_DATA5			0x13fe
+			IMX95_PAD_SD1_DATA6__USDHC1_DATA6			0x13fe
+			IMX95_PAD_SD1_DATA7__USDHC1_DATA7			0x13fe
+			IMX95_PAD_SD1_STROBE__USDHC1_STROBE			0x15fe
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_RESET_B__GPIO3_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_leds: ledsgrp {
+		fsl,pins = <
+			IMX95_PAD_XSPI1_DATA7__GPIO5_IO_BIT7			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CD_B__GPIO3_IO_BIT0			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+			IMX95_PAD_XSPI1_DQS__GPIO5_IO_BIT8			0x1fe	//not pull down,not pull up ,Fast slew rate, drive X6
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x158e
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x138e
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x138e
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x138e
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x138e
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x138e
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD3_CLK__USDHC3_CLK				0x15fe
+			IMX95_PAD_SD3_CMD__USDHC3_CMD				0x13fe
+			IMX95_PAD_SD3_DATA0__USDHC3_DATA0			0x13fe
+			IMX95_PAD_SD3_DATA1__USDHC3_DATA1			0x13fe
+			IMX95_PAD_SD3_DATA2__USDHC3_DATA2			0x13fe
+			IMX95_PAD_SD3_DATA3__USDHC3_DATA3			0x13fe
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x158e
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x138e
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x138e
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x138e
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x138e
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x138e
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			IMX95_PAD_SD2_CLK__USDHC2_CLK				0x15fe
+			IMX95_PAD_SD2_CMD__USDHC2_CMD				0x13fe
+			IMX95_PAD_SD2_DATA0__USDHC2_DATA0			0x13fe
+			IMX95_PAD_SD2_DATA1__USDHC2_DATA1			0x13fe
+			IMX95_PAD_SD2_DATA2__USDHC2_DATA2			0x13fe
+			IMX95_PAD_SD2_DATA3__USDHC2_DATA3			0x13fe
+			IMX95_PAD_SD2_VSELECT__USDHC2_VSELECT			0x51e
+		>;
+	};
+};
+
+&vpuctrl {
+	boot = <&vpu_boot>;
+	sram = <&sram1>;
+};
+
+&wdog3 {
+	status = "okay";
+};
+/* SMARC PCIE_A*/
+&pcie0 {
+	pinctrl-0 = <&pinctrl_pcie0>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 6 GPIO_ACTIVE_LOW>; //PCIEA_RST#_3V
+	vpcie-supply = <&reg_pcie0>;
+	status = "okay";
+};
+/* U1900 AW-CM276NF */
+&pcie1 {
+	pinctrl-0 = <&pinctrl_pcie1>;
+	pinctrl-names = "default";
+	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+	reset-gpio = <&i2c2_gpio_expander_71 7 GPIO_ACTIVE_LOW>; //PCIEB_RST#_3V
+	status = "okay";
+};
+
+&pcie1_ep {
+       pinctrl-0 = <&pinctrl_pcie1>;
+       pinctrl-names = "default";
+       fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_OUTPUT>;
+       //vpcie-supply = <&reg_slot_pwr>;
+       status = "disabled";
+};
+
+
+/* U1500 LT9611_LONTIUM */
+&sai1 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai1>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI1>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+&sai3 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&scmi_clk IMX95_CLK_AUDIOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2_VCO>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL1>,
+			  <&scmi_clk IMX95_CLK_AUDIOPLL2>,
+			  <&scmi_clk IMX95_CLK_SAI3>;
+	assigned-clock-parents = <0>, <0>, <0>, <0>,
+				 <&scmi_clk IMX95_CLK_AUDIOPLL1>;
+	assigned-clock-rates = <3932160000>,
+			       <3612672000>, <393216000>,
+			       <361267200>, <12288000>;
+	fsl,sai-mclk-direction-output;
+	status = "okay";
+};
+
+#include "imx95-android.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/lt9611-basic.dts b/arch/arm64/boot/dts/freescale/lt9611-basic.dts
new file mode 100644
index 000000000000..a35e2e77af08
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lt9611-basic.dts
@@ -0,0 +1,116 @@
+
+
+&{/} {
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&lt9611_out>;
+			};
+		};
+	};
+
+	sound-hdmi {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "sound-hdmi";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&hdmicpu>;
+		simple-audio-card,bitclock-master = <&hdmicpu>;
+
+		hdmicpu:simple-audio-card,cpu {
+			sound-dai = <&sai1>;
+			system-clock-direction-out;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&lt9611_codec 0>;
+		};
+	};
+
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <4008000000>, <445333334>;
+	status = "okay";
+};
+
+&lpi2c3 {
+	clock-frequency = <100000>;
+	status = "okay";
+
+
+	/* U1500 LT9611_LONTIUM */
+	lt9611_codec: hdmi-bridge@3b {
+		#sound-dai-cells = <1>;
+		compatible = "adlink,lt9611";
+		reg = <0x3b>;
+		interrupts-extended = <&i2c2_gpio_expander_71 5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&i2c2_gpio_expander_71 4 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mipi_dsi_csi>;
+
+		clocks = <&scmi_clk IMX95_CLK_DISP1PIX>, <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>, <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+		clock-names = "pix","vco","videopll1";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				lt9611_to_dsi: endpoint {
+					remote-endpoint = <&dsi_to_lt9611>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				lt9611_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_to_lt9611: endpoint {
+				remote-endpoint = <&lt9611_to_dsi>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@0 {
+		reg = <0>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/lt96114k-basic.dts b/arch/arm64/boot/dts/freescale/lt96114k-basic.dts
new file mode 100644
index 000000000000..c0f2b533647b
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/lt96114k-basic.dts
@@ -0,0 +1,117 @@
+
+
+
+&{/} {
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&lt9611_out>;
+			};
+		};
+	};
+
+	sound-hdmi {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "sound-hdmi";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&hdmicpu>;
+		simple-audio-card,bitclock-master = <&hdmicpu>;
+
+		hdmicpu:simple-audio-card,cpu {
+			sound-dai = <&sai1>;
+			system-clock-direction-out;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&lt9611_codec 0>;
+		};
+	};
+
+};
+
+&display_pixel_link {
+	status = "okay";
+};
+
+&dpu {
+	assigned-clocks = <&scmi_clk IMX95_CLK_DISP1PIX>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>,
+			  <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-parents = <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+	assigned-clock-rates = <0>, <2673000000>, <297000000>;
+	status = "okay";
+};
+
+&lpi2c3 {
+	clock-frequency = <400000>;
+	status = "okay";
+
+
+	/* U1500 LT9611_LONTIUM */
+	lt9611_codec: hdmi-bridge@3b {
+		#sound-dai-cells = <1>;
+		compatible = "adlink,lt9611";
+		reg = <0x3b>;
+		interrupts-extended = <&i2c2_gpio_expander_71 5 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&i2c2_gpio_expander_71 4 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mipi_dsi_csi>;
+
+		clocks = <&scmi_clk IMX95_CLK_DISP1PIX>, <&scmi_clk IMX95_CLK_VIDEOPLL1_VCO>, <&scmi_clk IMX95_CLK_VIDEOPLL1>;
+		clock-names = "pix","vco","videopll1";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				lt9611_to_dsi: endpoint {
+					remote-endpoint = <&dsi_to_lt9611>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				lt9611_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+		};
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+
+			dsi_to_lt9611: endpoint {
+				remote-endpoint = <&lt9611_to_dsi>;
+			};
+		};
+	};
+};
+
+&pixel_interleaver {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	channel@1 {
+		reg = <1>;
+		status = "okay";
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/ov13855-basic.dts b/arch/arm64/boot/dts/freescale/ov13855-basic.dts
new file mode 100644
index 000000000000..71249f836481
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/ov13855-basic.dts
@@ -0,0 +1,147 @@
+
+&scmi_iomuxc {
+	pinctrl_csi_mclk: csi_mclk {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO1__CCMSRCGPCMIX_TOP_CLKO_1	0x39e
+		>;
+	};
+};
+
+&lpi2c3 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	/*
+	ov5640_0: ov5640_mipi@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "xclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+		powerdown-gpios = <&i2c3_adl1000 10 GPIO_ACTIVE_HIGH>; 	//CN_GPIO0_CAM0_PWR#_1V8
+		reset-gpios = <&i2c3_adl1000 12 GPIO_ACTIVE_LOW>;	//CN_GPIO2_CAM0_RST#_1V8
+		status = "okay";
+
+		port {
+			ov13855_mipi_0_ep: endpoint {
+				remote-endpoint = <&mipi_csi0_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+	*/
+	
+	ov13855: ov13855_mipi@36 {
+		compatible = "ov13855_mipi";
+		reg = <0x36>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "csi_mclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+
+		//pwn-gpios = <&i2c2_gpio_expander_71 0 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		//rst-gpios = <&i2c2_gpio_expander_71 1 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		pwn-gpios = <&i2c3_adl1000 11 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		rst-gpios = <&i2c3_adl1000 13 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		//pwn-gpios = <&i2c3_adl1000 11 GPIO_ACTIVE_HIGH>; 	//CN_GPIO1_CAM1_PWR#_1V8
+		//rst-gpios = <&i2c3_adl1000 13 GPIO_ACTIVE_LOW>;	//CN_GPIO3_CAM1_RST#_1V8
+		virtual_channel = <0>;
+		mipi_csi;
+
+		port@0 {
+			ov13855_mipi_0_ep: endpoint {
+				remote-endpoint = <&mipi_csi0_ep>;
+				data-lanes = <1 2 3 4>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+	
+
+};
+
+&dphy_rx {
+	status = "okay";
+};
+
+&mipi_csi0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			mipi_csi0_ep: endpoint {
+				remote-endpoint = <&ov13855_mipi_0_ep>;
+				data-lanes = <1 2 3 4>;
+				clock-lanes = <0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+				mipi_csi0_out: endpoint {
+				remote-endpoint = <&formatter_0_in>;
+				//remote-endpoint = <&isi_in_2>;
+			};
+		};
+	};
+};
+
+&csi_pixel_formatter_0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			formatter_0_in: endpoint {
+				remote-endpoint = <&mipi_csi0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			formatter_0_out: endpoint {
+				remote-endpoint = <&isi_in_2>;
+			};
+		};
+	};
+};
+
+&isi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@2 {
+			reg = <2>;
+
+			isi_in_2: endpoint {
+				remote-endpoint = <&formatter_0_out>;
+				//remote-endpoint = <&mipi_csi0_out>;
+			};
+		};
+	};
+};
+
+
diff --git a/arch/arm64/boot/dts/freescale/ov5640-basic.dts b/arch/arm64/boot/dts/freescale/ov5640-basic.dts
new file mode 100644
index 000000000000..49ae3d110087
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/ov5640-basic.dts
@@ -0,0 +1,127 @@
+
+&scmi_iomuxc {
+	pinctrl_csi_mclk: csi_mclk {
+		fsl,pins = <
+			IMX95_PAD_CCM_CLKO1__CCMSRCGPCMIX_TOP_CLKO_1	0x39e
+		>;
+	};
+};
+
+
+&lpi2c2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+
+	ov5640_0: ov5640_mipi@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_csi_mclk>;
+		clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		clock-names = "xclk";
+		assigned-clocks = <&scmi_clk IMX95_CLK_CCMCKO1>;
+		assigned-clock-parents = <&osc_24m>;
+		assigned-clock-rates = <24000000>;
+		powerdown-gpios = <&i2c3_adl1000 10 GPIO_ACTIVE_HIGH>; 	//CN_GPIO0_CAM0_PWR#_1V8
+		reset-gpios = <&i2c3_adl1000 12 GPIO_ACTIVE_LOW>;	//CN_GPIO2_CAM0_RST#_1V8
+		status = "okay";
+
+		port {
+			ov5640_mipi_1_ep: endpoint {
+				remote-endpoint = <&mipi_csi1_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+	};
+};
+
+&display_stream_csr {
+	status = "disabled";
+};
+
+&display_master_csr {
+	status = "disabled";
+};
+
+&mipi_tx_phy_csr {
+	status = "disabled";
+};
+
+&mipi_dsi_intf {
+	status = "okay";
+};
+
+&combo_rx {
+	status = "okay";
+};
+
+&mipi_csi1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			mipi_csi1_ep: endpoint {
+				remote-endpoint = <&ov5640_mipi_1_ep>;
+				data-lanes = <1 2>;
+				clock-lanes = <0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+				mipi_csi1_out: endpoint {
+				remote-endpoint = <&formatter_1_in>;
+			};
+		};
+	};
+};
+
+
+&csi_pixel_formatter_1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			formatter_1_in: endpoint {
+				remote-endpoint = <&mipi_csi1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			formatter_1_out: endpoint {
+				remote-endpoint = <&isi_in_3>;
+			};
+		};
+	};
+};
+
+&isi {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@3 {
+			reg = <3>;
+
+			isi_in_3: endpoint {
+				remote-endpoint = <&formatter_1_out>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/configs/lec_imx95_gki.fragment b/arch/arm64/configs/lec_imx95_gki.fragment
new file mode 100644
index 000000000000..cb806e290a95
--- /dev/null
+++ b/arch/arm64/configs/lec_imx95_gki.fragment
@@ -0,0 +1,194 @@
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_IMX8M_BLK_CTRL is not set
+# CONFIG_MXC_HANTRO is not set
+# CONFIG_MXC_HANTRO_845 is not set
+# CONFIG_MXC_HANTRO_VC8000E is not set
+# CONFIG_DEBUG_INFO_BTF_MODULES is not set
+CONFIG_IMX_GKI_FIX=y
+CONFIG_AQUANTIA_PHY=m
+CONFIG_ARCH_MXC=y
+CONFIG_ARCH_NXP=y
+CONFIG_ARM_IMX_CPUFREQ_DT=m
+CONFIG_ARM_SCMI_POWER_CONTROL=m
+CONFIG_ARM_SCMI_POWER_DOMAIN=m
+CONFIG_ARM_SMMU_V3=m
+CONFIG_BACKLIGHT_LED=m
+CONFIG_BACKLIGHT_PWM=m
+CONFIG_BATTERY_DUMMY=m
+CONFIG_GPIO_ADL1000=y
+CONFIG_CAN_FLEXCAN=m
+CONFIG_CLK_IMX95_BLK_CTL=m
+CONFIG_COMMON_CLK_SCMI=m
+CONFIG_CPUFREQ_DT=m
+CONFIG_DMABUF_HEAPS_CMA=m
+CONFIG_DMABUF_HEAPS_DSP=m
+CONFIG_DMABUF_HEAPS_SYSTEM=m
+CONFIG_DMABUF_IMX=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_IMX95_DPU=m
+CONFIG_DRM_IMX95_LDB=m
+CONFIG_DRM_IMX95_MIPI_DSI=m
+CONFIG_DRM_IMX95_PIXEL_INTERLEAVER=m
+CONFIG_DRM_IMX95_PIXEL_LINK=m
+CONFIG_DRM_IMX_LCDIF=m
+CONFIG_DRM_IMX_RPMSG=m
+CONFIG_DRM_ITE_IT6161=m
+CONFIG_DRM_ITE_IT6263=m
+CONFIG_DRM_LONTIUM_LT8912B=m
+CONFIG_DRM_ADLINK_LT9611=m
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc1"
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_PINCTRL_SX150X=y
+CONFIG_DRM_TI_SN65DSI83=m
+CONFIG_DRM_MAX96752_LVDS=m
+CONFIG_DRM_MAX96789_DSI=m
+CONFIG_DRM_NWL_MIPI_DSI=m
+CONFIG_DRM_PANEL_NXP_RM67162=m
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=m
+CONFIG_DRM_PANEL_RAYDIUM_RM692C9=m
+CONFIG_DRM_PANEL_ROCKTECK_HIMAX8394F=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_PANEL_LVDS=m
+CONFIG_ETHERNET=y
+CONFIG_FSL_EDMA_V3=m
+CONFIG_FSL_ENETC4=m
+CONFIG_FSL_ENETC_CORE=m
+CONFIG_FSL_ENETC_MDIO=m
+CONFIG_FSL_ENETC_QOS=y
+CONFIG_FSL_ENETC_VF=m
+CONFIG_FSL_IMX9_DDR_PMU=m
+CONFIG_FSL_NETC_PRB_IERB=m
+CONFIG_FSL_NTMP=m
+CONFIG_GPIO_ADP5585=m
+CONFIG_GPIO_PCA953X=m
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_VF610=m
+CONFIG_HWMON=m
+CONFIG_SENSORS_ARM_SCMI=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_IMX_LPI2C=m
+CONFIG_I2C_RPBUS=m
+CONFIG_I2C_MUX=m
+CONFIG_IMX7ULP_WDT=m
+CONFIG_IMX93_ADC=m
+CONFIG_IMX_IRQSTEER=m
+CONFIG_IMX_MBOX=m
+CONFIG_IMX_NEUTRON_REMOTEPROC=m
+CONFIG_IMX_REMOTEPROC=m
+CONFIG_IMX_SCMI_BBM_CONTROL=m
+CONFIG_IMX_SCMI_MISC_CONTROL=m
+CONFIG_IMX_SEC_ENCLAVE=m
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_PCA963X=m
+CONFIG_LEDS_PCA995X=m
+CONFIG_MAC80211=m
+CONFIG_CFG80211=m
+CONFIG_MALI_CSF_SUPPORT=y
+CONFIG_MALI_MIDGARD=m
+CONFIG_MALI_TRACE_POWER_GPU_WORK_PERIOD=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MFD_MAX96752=m
+CONFIG_MFD_MAX96752_I2C=m
+CONFIG_MFD_ADP5585=m
+CONFIG_MFD_MAX96789=m
+CONFIG_MFD_MAX96789_I2C=m
+CONFIG_IMX8M_BUSFREQ=m
+CONFIG_MMC_SDHCI_ESDHC_IMX=m
+CONFIG_MUX_MMIO=m
+CONFIG_MXC_VIDEO_WAVE6=m
+CONFIG_NET_ACT_GATE=m
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_SCH_CBS=m
+CONFIG_NET_SCH_ETF=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_TAPRIO=m
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_NEUTRON=m
+CONFIG_NOP_USB_XCEIV=m
+CONFIG_NVMEM_IMX_OCOTP=m
+CONFIG_NVMEM_IMX_OCOTP_FSB_S400=m
+CONFIG_PCI_IMX6=m
+CONFIG_PCS_XPCS=m
+CONFIG_PHY_FSL_IMX8MQ_USB=m
+CONFIG_PHY_FSL_IMX9_DPHY_RX=m
+CONFIG_PHY_FSL_IMX8MP_LVDS=m
+CONFIG_PINCTRL_IMX8ULP=m
+CONFIG_PINCTRL_IMX=m
+CONFIG_PINCTRL_IMX_SCMI=m
+CONFIG_POWER_RESET_IMX=m
+CONFIG_PTP_1588_CLOCK=m
+CONFIG_PTP_1588_CLOCK_NETC=m
+CONFIG_PWM_IMX_TPM=m
+CONFIG_PWRSEQ_SIMPLE=m
+CONFIG_REALTEK_PHY=m
+CONFIG_RESET_GPIO=m
+CONFIG_RPMSG_VIRTIO=m
+CONFIG_SERIAL_IMX_EARLYCON=y
+CONFIG_SERIAL_FSL_LPUART=m
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_SND_IMX_SOC=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_SIMPLE_CARD_UTILS=m
+CONFIG_SND_SOC_AK4458=m
+CONFIG_SND_SOC_AK5558=m
+CONFIG_SND_SOC_BT_SCO=m
+CONFIG_SND_SOC_CS42XX8=m
+CONFIG_SND_SOC_CS42XX8_I2C=m
+CONFIG_SND_SOC_FSL_ASOC_CARD=m
+CONFIG_SND_SOC_FSL_ASRC=m
+CONFIG_SND_SOC_FSL_MICFIL=m
+CONFIG_SND_SOC_FSL_MQS=m
+CONFIG_SND_SOC_FSL_RPMSG=m
+CONFIG_SND_SOC_FSL_SAI=m
+CONFIG_SND_SOC_FSL_SPDIF=m
+CONFIG_SND_SOC_IMX_AUDIO_RPMSG=m
+CONFIG_SND_SOC_IMX_CARD=m
+CONFIG_SND_SOC_IMX_PCM_DMA=m
+CONFIG_SND_SOC_IMX_PCM_RPMSG=m
+CONFIG_SND_SOC_IMX_RPMSG=m
+CONFIG_SND_SOC_IMX_SPDIF=m
+CONFIG_SND_SOC_WM8962=m
+CONFIG_SND_SOC_WM8904=m
+CONFIG_SOC_IMX9=m
+CONFIG_SPI_BITBANG=m
+CONFIG_SPI_FSL_LPSPI=m
+CONFIG_SPI_NXP_FLEXSPI=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_MTD=m
+CONFIG_MTD_SPI_NOR=m
+CONFIG_TIMER_IMX_SYS_CTR=m
+CONFIG_TRUSTY=m
+CONFIG_TRUSTY_CRASH_IS_PANIC=y
+CONFIG_USB_CHIPIDEA=m
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_CHIPIDEA_IMX=m
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_DWC3_IMX8MP=m
+CONFIG_TOUCHSCREEN_FTS=m
+CONFIG_TOUCHSCREEN_ILITEK=m
+CONFIG_TOUCHSCREEN_EXC3000=m
+CONFIG_TYPEC_SWITCH_GPIO=m
+CONFIG_VIDEO_AP130X=m
+CONFIG_VIDEO_DWC_MIPI_CSIS=m
+CONFIG_VIDEO_IMX8_ISI=m
+CONFIG_VIDEO_IMX8_ISI_M2M=y
+CONFIG_VIDEO_IMX8_JPEG=m
+CONFIG_VIDEO_IMX_CSI_FORMATTER=m
+CONFIG_VIDEO_NXP_NEOISP=m
+CONFIG_VIDEO_OX05B1S=m
+CONFIG_ZRAM=m
+CONFIG_ZSMALLOC=m
+CONFIG_PWM_ADP5585=m
+CONFIG_WIDEVINE_L1_SKIP_MEMSET_SECUREHEAP=y
+CONFIG_USER_NS=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_TCG_TIS_I2C=y
+CONFIG_BT_NXPUART=m
+CONFIG_SND_SOC_TLV320AIC3X_I2C=m
+CONFIG_SND_SOC_IMX_TLV320AIC3X=m
+CONFIG_VIDEO_OV13855=m
+CONFIG_VIDEO_OV5640=m
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index f0df2b65b897..75347ae6b949 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -1092,6 +1092,14 @@ config GPIO_MAX732X_IRQ
 	  Say yes here to enable the max732x to be used as an interrupt
 	  controller. It requires the driver to be built in the kernel.
 
+
+config GPIO_ADL1000
+	tristate "ADL1000 I/O ports"
+	select REGMAP_I2C
+	help
+	  Say yes here to provide access to the ADL1000 register-oriented
+	  SMBus I/O expanders
+
 config GPIO_PCA953X
 	tristate "PCA95[357]x, PCA9698, TCA64xx, and MAX7310 I/O ports"
 	select REGMAP_I2C
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index ce50e15974b7..062cd7884486 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_GPIO_OCTEON)		+= gpio-octeon.o
 obj-$(CONFIG_GPIO_OMAP)			+= gpio-omap.o
 obj-$(CONFIG_GPIO_PALMAS)		+= gpio-palmas.o
 obj-$(CONFIG_GPIO_PCA953X)		+= gpio-pca953x.o
+obj-$(CONFIG_GPIO_ADL1000)		+= gpio-adl1000.o
 obj-$(CONFIG_GPIO_PCA9570)		+= gpio-pca9570.o
 obj-$(CONFIG_GPIO_PCF857X)		+= gpio-pcf857x.o
 obj-$(CONFIG_GPIO_PCH)			+= gpio-pch.o
diff --git a/drivers/gpio/gpio-adl1000.c b/drivers/gpio/gpio-adl1000.c
new file mode 100644
index 000000000000..2146b4247a17
--- /dev/null
+++ b/drivers/gpio/gpio-adl1000.c
@@ -0,0 +1,884 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  ADLink 40 bit I/O ports
+ *
+ *
+ *  Derived from drivers/i2c/chips/pca953x.c
+ */
+
+#include <linux/bitmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <asm/unaligned.h>
+
+#include <linux/delay.h>
+#define REGMAP_BUCK 0
+#define REGMAP_BUCK_RETRY_CNT 3
+
+#define ADL1000_INPUT		0x06
+#define ADL1000_OUTPUT		0x0A
+//#define ADL1000_INVERT		0x08
+#define ADL1000_DIRECTION	0x00
+
+//#define ADL1000_IN_LATCH	0x48
+#define ADL1000_PULL_EN		0x20
+#define ADL1000_PULL_SEL	0x26
+#define ADL1000_INT_MASK	0x10
+#define ADL1000_INT_STAT	0x16
+#define ADL1000_INT_VER0	0x2e
+#define ADL1000_INT_VER1	0x2f
+
+#define ADL1000_NPIN		24
+
+
+static const struct i2c_device_id adl1000_id[] = {
+	{ "adl1000", ADL1000_NPIN , },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, adl1000_id);
+
+#define MAX_BANK 6
+#define BANK_SZ 8
+#define MAX_LINE	(MAX_BANK * BANK_SZ)
+
+#define NBANK(chip) DIV_ROUND_UP(chip->gpio_chip.ngpio, BANK_SZ)
+
+
+struct adl1000_platform_data {
+	/* number of the first GPIO */
+	unsigned	gpio_base;
+
+	/* initial polarity inversion setting */
+	u32		invert;
+
+	/* interrupt base */
+	int		irq_base;
+
+	void		*context;	/* param to setup/teardown */
+
+	int		(*setup)(struct i2c_client *client,
+				unsigned gpio, unsigned ngpio,
+				void *context);
+	void		(*teardown)(struct i2c_client *client,
+				unsigned gpio, unsigned ngpio,
+				void *context);
+	const char	*const *names;
+};
+
+struct adl1000_reg_config {
+	int direction;
+	int output;
+	int input;
+	//int invert;
+};
+
+static const struct adl1000_reg_config adl1000_regs = {
+	.direction = ADL1000_DIRECTION,
+	.output = ADL1000_OUTPUT,
+	.input = ADL1000_INPUT ,
+	//.invert = ADL1000_INVERT,
+};
+
+
+
+struct adl1000_chip {
+	unsigned gpio_start;
+	struct mutex i2c_lock;
+	struct regmap *regmap;
+
+
+	struct mutex irq_lock;
+	DECLARE_BITMAP(irq_mask, MAX_LINE);
+	DECLARE_BITMAP(irq_stat, MAX_LINE);
+	DECLARE_BITMAP(irq_trig_raise, MAX_LINE);
+	DECLARE_BITMAP(irq_trig_fall, MAX_LINE);
+
+	atomic_t wakeup_path;
+
+	struct i2c_client *client;
+	struct gpio_chip gpio_chip;
+	const char *const *names;
+	unsigned long driver_data;
+	struct regulator *regulator;
+
+	const struct adl1000_reg_config *regs;
+
+	u8 (*recalc_addr)(struct adl1000_chip *chip, int reg, int off);
+};
+
+static bool adl1000_readable_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_INPUT && reg<(ADL1000_INPUT+ NBANK(chip))) ||
+		(reg>=ADL1000_OUTPUT && reg<(ADL1000_OUTPUT+ NBANK(chip))) ||
+//		(reg>=ADL1000_INVERT && reg<(ADL1000_INVERT+ NBANK(chip))) ||
+		(reg>=ADL1000_DIRECTION && reg<(ADL1000_DIRECTION+ NBANK(chip))) ||
+//		(reg>=ADL1000_IN_LATCH && reg<(ADL1000_IN_LATCH+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_EN && reg<(ADL1000_PULL_EN+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_SEL && reg<(ADL1000_PULL_SEL+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_MASK && reg<(ADL1000_INT_MASK+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_STAT && reg<(ADL1000_INT_STAT+ NBANK(chip)))
+		)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static bool adl1000_writeable_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_OUTPUT && reg<(ADL1000_OUTPUT+ NBANK(chip))) ||
+//		(reg>=ADL1000_INVERT && reg<(ADL1000_INVERT+ NBANK(chip))) ||
+		(reg>=ADL1000_DIRECTION && reg<(ADL1000_DIRECTION+ NBANK(chip))) ||
+//		(reg>=ADL1000_IN_LATCH && reg<(ADL1000_IN_LATCH+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_EN && reg<(ADL1000_PULL_EN+ NBANK(chip))) ||
+		(reg>=ADL1000_PULL_SEL && reg<(ADL1000_PULL_SEL+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_MASK && reg<(ADL1000_INT_MASK+ NBANK(chip)))
+		)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static bool adl1000_volatile_register(struct device *dev, unsigned int reg)
+{
+	struct adl1000_chip *chip = dev_get_drvdata(dev);
+	if(
+		(reg>=ADL1000_INPUT && reg<(ADL1000_INPUT+ NBANK(chip))) ||
+		(reg>=ADL1000_INT_STAT && reg<(ADL1000_INT_STAT+ NBANK(chip)))
+	)
+	{
+		return true;
+	}
+	else 
+	{
+		return false;
+	}
+}
+
+static const struct regmap_config adl1000_i2c_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.use_single_read = true,
+	.use_single_write = true,
+
+	.readable_reg = adl1000_readable_register,
+	.writeable_reg = adl1000_writeable_register,
+	.volatile_reg = adl1000_volatile_register,
+
+	.disable_locking = true,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 0x7f,
+};
+
+
+static u8 adl1000_recalc_addr(struct adl1000_chip *chip, int reg, int off)
+{
+
+	u8 regaddr = reg + (off / BANK_SZ);
+
+	return regaddr;
+}
+
+static int adl1000_write_regs(struct adl1000_chip *chip, int reg, unsigned long *val)
+{
+	u8 regaddr = chip->recalc_addr(chip, reg, 0);
+	u8 value[MAX_BANK];
+	int i, ret;
+
+	for (i = 0; i < NBANK(chip); i++)
+		value[i] = bitmap_get_value8(val, i * BANK_SZ);
+
+#if REGMAP_BUCK
+	ret = regmap_bulk_write(chip->regmap, regaddr, value, NBANK(chip));
+	if (ret < 0) {
+		dev_err(&chip->client->dev, "failed writing register\n");
+		return ret;
+	}
+#else
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		int retry = 0;
+
+		ret=1;
+		while(ret)
+		{
+			ret = regmap_write(chip->regmap, regaddr+i, (unsigned int)value[i]);
+			if(ret)
+			{
+				retry++;
+				dev_err(&chip->client->dev, "jimmy adl1000_write_regs regmap_write failed reg:0x%x ret:0x%x retry:%d\n",regaddr+i,ret,retry);
+				if(retry >= REGMAP_BUCK_RETRY_CNT)
+					break;
+				udelay(300);
+			}
+		}
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "failed writing register\n");
+			return ret;
+		}
+	}
+	
+#endif
+	return 0;
+}
+
+static int adl1000_read_regs(struct adl1000_chip *chip, int reg, unsigned long *val)
+{
+	u8 regaddr = chip->recalc_addr(chip, reg, 0);
+	u8 value[MAX_BANK];
+	int i, ret;
+
+#if REGMAP_BUCK
+	ret = regmap_bulk_read(chip->regmap, regaddr, value, NBANK(chip));
+	printk("jimmy adl1000_read_regs  regaddr:%d ret:0x%x i:%d\n",regaddr,ret,i++);
+	if (ret < 0) {
+		dev_err(&chip->client->dev, "failed reading register\n");
+		return ret;
+	}
+#else
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		int retry = 0;
+
+		ret=1;
+		while(ret)
+		{
+			ret = regmap_read(chip->regmap, regaddr+i, ( unsigned int *)&value[i]);
+			if(ret)
+			{
+				retry++;
+				dev_err(&chip->client->dev, "jimmy adl1000_read_regs regmap_read failed reg:0x%x ret:0x%x retry:%d\n",regaddr+i,ret,retry);
+				if(retry >= REGMAP_BUCK_RETRY_CNT)
+					break;
+				udelay(300);
+			}
+		}
+		if (ret < 0) {
+			dev_err(&chip->client->dev, "failed reading register\n");
+			return ret;
+		}
+	}
+#endif
+	for (i = 0; i < NBANK(chip); i++)
+	{
+		bitmap_set_value8(val, value[i], i * BANK_SZ);
+	}
+
+	return 0;
+}
+
+static int adl1000_gpio_direction_input(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 bit = BIT(off % BANK_SZ);
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+
+	ret = regmap_write_bits(chip->regmap, dirreg, bit, bit);
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_direction_output(struct gpio_chip *gc,
+		unsigned off, int val)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 outreg = chip->recalc_addr(chip, chip->regs->output, off);
+	u8 bit = BIT(off % BANK_SZ);
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	/* set output level */
+	ret = regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);
+	if (ret)
+		goto exit;
+
+	/* then direction */
+	ret = regmap_write_bits(chip->regmap, dirreg, bit, 0);
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_get_value(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 inreg = chip->recalc_addr(chip, chip->regs->input, off);
+	u8 bit = BIT(off % BANK_SZ);
+	u32 reg_val;
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	ret = regmap_read(chip->regmap, inreg, &reg_val);
+
+	mutex_unlock(&chip->i2c_lock);
+	if (ret < 0)
+		return ret;
+
+	return !!(reg_val & bit);
+}
+
+static void adl1000_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 outreg = chip->recalc_addr(chip, chip->regs->output, off);
+	u8 bit = BIT(off % BANK_SZ);
+
+	mutex_lock(&chip->i2c_lock);
+
+	regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);
+	mutex_unlock(&chip->i2c_lock);
+}
+
+static int adl1000_gpio_get_direction(struct gpio_chip *gc, unsigned off)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	u8 dirreg = chip->recalc_addr(chip, chip->regs->direction, off);
+	u8 bit = BIT(off % BANK_SZ);
+	u32 reg_val;
+	int ret;
+
+	mutex_lock(&chip->i2c_lock);
+	ret = regmap_read(chip->regmap, dirreg, &reg_val);
+
+	mutex_unlock(&chip->i2c_lock);
+	if (ret < 0)
+		return ret;
+
+	if (reg_val & bit)
+		return GPIO_LINE_DIRECTION_IN;
+
+	return GPIO_LINE_DIRECTION_OUT;
+}
+
+static int adl1000_gpio_set_pull_up_down(struct adl1000_chip *chip,
+					 unsigned int offset,
+					 unsigned long config)
+{
+	enum pin_config_param param = pinconf_to_config_param(config);
+
+	u8 pull_en_reg = chip->recalc_addr(chip, ADL1000_PULL_EN, offset);
+	u8 pull_sel_reg = chip->recalc_addr(chip, ADL1000_PULL_SEL, offset);
+	u8 bit = BIT(offset % BANK_SZ);
+	int ret;
+
+	/*
+	 * pull-up/pull-down configuration requires PCAL extended
+	 * registers
+	 */
+
+	mutex_lock(&chip->i2c_lock);
+
+	/* Configure pull-up/pull-down */
+	if (param == PIN_CONFIG_BIAS_PULL_UP)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, bit);
+	}
+	else if (param == PIN_CONFIG_BIAS_PULL_DOWN)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_sel_reg, bit, 0);
+	}
+	else
+		ret = 0;
+	if (ret)
+		goto exit;
+
+	/* Disable/Enable pull-up/pull-down */
+	if (param == PIN_CONFIG_BIAS_DISABLE)
+	{
+		ret = regmap_write_bits(chip->regmap, pull_en_reg, bit, 0);
+	}
+	else
+	{
+		ret = regmap_write_bits(chip->regmap, pull_en_reg, bit, bit);
+	}
+
+exit:
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
+static int adl1000_gpio_set_config(struct gpio_chip *gc, unsigned int offset,
+				   unsigned long config)
+{
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	switch (pinconf_to_config_param(config)) {
+	case PIN_CONFIG_BIAS_PULL_UP:
+	case PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+	case PIN_CONFIG_BIAS_DISABLE:
+		return adl1000_gpio_set_pull_up_down(chip, offset, config);
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static void adl1000_setup_gpio(struct adl1000_chip *chip, int gpios)
+{
+	struct gpio_chip *gc;
+
+	gc = &chip->gpio_chip;
+
+	gc->direction_input  = adl1000_gpio_direction_input;
+	gc->direction_output = adl1000_gpio_direction_output;
+	gc->get = adl1000_gpio_get_value;
+	gc->set = adl1000_gpio_set_value;
+	gc->get_direction = adl1000_gpio_get_direction;
+	gc->set_config = adl1000_gpio_set_config;
+	gc->can_sleep = true;
+
+	gc->base = chip->gpio_start;
+	gc->ngpio = gpios;
+	gc->label = dev_name(&chip->client->dev);
+	gc->parent = &chip->client->dev;
+	gc->owner = THIS_MODULE;
+	gc->names = chip->names;
+}
+
+
+static void adl1000_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	clear_bit(hwirq, chip->irq_mask);
+	gpiochip_disable_irq(gc, hwirq);
+}
+
+static void adl1000_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	gpiochip_enable_irq(gc, hwirq);
+	set_bit(hwirq, chip->irq_mask);
+}
+
+static int adl1000_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	if (on)
+		atomic_inc(&chip->wakeup_path);
+	else
+		atomic_dec(&chip->wakeup_path);
+
+	return irq_set_irq_wake(chip->client->irq, on);
+}
+
+static void adl1000_irq_bus_lock(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+
+	mutex_lock(&chip->irq_lock);
+}
+
+static void adl1000_irq_bus_sync_unlock(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	DECLARE_BITMAP(irq_mask, MAX_LINE);
+	DECLARE_BITMAP(reg_direction, MAX_LINE);
+	int level;
+
+	{
+		bitmap_complement(irq_mask, chip->irq_mask, gc->ngpio);
+
+		/* Unmask enabled interrupts */
+		adl1000_write_regs(chip, ADL1000_INT_MASK, irq_mask);
+	}
+
+	/* Switch direction to input if needed */
+	adl1000_read_regs(chip, chip->regs->direction, reg_direction);
+
+	bitmap_or(irq_mask, chip->irq_trig_fall, chip->irq_trig_raise, gc->ngpio);
+	bitmap_complement(reg_direction, reg_direction, gc->ngpio);
+	bitmap_and(irq_mask, irq_mask, reg_direction, gc->ngpio);
+
+	/* Look for any newly setup interrupt */
+	for_each_set_bit(level, irq_mask, gc->ngpio)
+		adl1000_gpio_direction_input(&chip->gpio_chip, level);
+
+	mutex_unlock(&chip->irq_lock);
+}
+
+static int adl1000_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	if (!(type & IRQ_TYPE_EDGE_BOTH)) {
+		dev_err(&chip->client->dev, "irq %d: unsupported type %d\n",
+			d->irq, type);
+		return -EINVAL;
+	}
+
+	assign_bit(hwirq, chip->irq_trig_fall, type & IRQ_TYPE_EDGE_FALLING);
+	assign_bit(hwirq, chip->irq_trig_raise, type & IRQ_TYPE_EDGE_RISING);
+
+	return 0;
+}
+
+static void adl1000_irq_shutdown(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct adl1000_chip *chip = gpiochip_get_data(gc);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	clear_bit(hwirq, chip->irq_trig_raise);
+	clear_bit(hwirq, chip->irq_trig_fall);
+}
+
+static void adl1000_irq_print_chip(struct irq_data *data, struct seq_file *p)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+
+	seq_printf(p, dev_name(gc->parent));
+}
+
+static const struct irq_chip adl1000_irq_chip = {
+	.irq_mask		= adl1000_irq_mask,
+	.irq_unmask		= adl1000_irq_unmask,
+	.irq_set_wake		= adl1000_irq_set_wake,
+	.irq_bus_lock		= adl1000_irq_bus_lock,
+	.irq_bus_sync_unlock	= adl1000_irq_bus_sync_unlock,
+	.irq_set_type		= adl1000_irq_set_type,
+	.irq_shutdown		= adl1000_irq_shutdown,
+	.irq_print_chip		= adl1000_irq_print_chip,
+	.flags			= IRQCHIP_IMMUTABLE,
+	GPIOCHIP_IRQ_RESOURCE_HELPERS,
+};
+
+static bool adl1000_irq_pending(struct adl1000_chip *chip, unsigned long *pending)
+{
+	struct gpio_chip *gc = &chip->gpio_chip;
+	//DECLARE_BITMAP(reg_direction, MAX_LINE);
+	//DECLARE_BITMAP(old_stat, MAX_LINE);
+	DECLARE_BITMAP(cur_stat, MAX_LINE);
+	DECLARE_BITMAP(new_stat, MAX_LINE);
+	DECLARE_BITMAP(trigger, MAX_LINE);
+	int ret;
+
+	/* Read the current interrupt status from the device */
+	ret = adl1000_read_regs(chip, ADL1000_INT_STAT, trigger);
+	if (ret)
+		return false;
+
+	/* Apply filter for rising/falling edge selection */
+	bitmap_replace(new_stat, chip->irq_trig_fall, chip->irq_trig_raise, cur_stat, gc->ngpio);
+	bitmap_and(pending, new_stat, trigger, gc->ngpio);
+
+	return !bitmap_empty(pending, gc->ngpio);
+}
+
+static irqreturn_t adl1000_irq_handler(int irq, void *devid)
+{
+	struct adl1000_chip *chip = devid;
+	struct gpio_chip *gc = &chip->gpio_chip;
+	DECLARE_BITMAP(pending, MAX_LINE);
+	int level;
+	bool ret;
+
+	bitmap_zero(pending, MAX_LINE);
+
+	mutex_lock(&chip->i2c_lock);
+	ret = adl1000_irq_pending(chip, pending);
+
+	mutex_unlock(&chip->i2c_lock);
+
+	if (ret) {
+		ret = 0;
+
+		for_each_set_bit(level, pending, gc->ngpio) {
+			int nested_irq = irq_find_mapping(gc->irq.domain, level);
+
+			if (unlikely(nested_irq <= 0)) {
+				dev_warn_ratelimited(gc->parent, "unmapped interrupt %d\n", level);
+				continue;
+			}
+
+			handle_nested_irq(nested_irq);
+			ret = 1;
+		}
+	}
+	return IRQ_RETVAL(ret);
+}
+
+static int adl1000_irq_setup(struct adl1000_chip *chip, int irq_base)
+{
+	struct i2c_client *client = chip->client;
+	DECLARE_BITMAP(reg_direction, MAX_LINE);
+	DECLARE_BITMAP(irq_stat, MAX_LINE);
+	struct gpio_irq_chip *girq;
+	int ret;
+
+	if (!client->irq)
+		return 0;
+
+	if (irq_base == -1)
+		return 0;
+
+	ret = adl1000_read_regs(chip, chip->regs->input, irq_stat);
+	if (ret)
+		return ret;
+
+	/*
+	 * There is no way to know which GPIO line generated the
+	 * interrupt.  We have to rely on the previous read for
+	 * this purpose.
+	 */
+	adl1000_read_regs(chip, chip->regs->direction, reg_direction);
+	bitmap_and(chip->irq_stat, irq_stat, reg_direction, chip->gpio_chip.ngpio);
+	mutex_init(&chip->irq_lock);
+
+	girq = &chip->gpio_chip.irq;
+	gpio_irq_chip_set_chip(girq, &adl1000_irq_chip);
+	/* This will let us handle the parent IRQ in the driver */
+	girq->parent_handler = NULL;
+	girq->num_parents = 0;
+	girq->parents = NULL;
+	girq->default_type = IRQ_TYPE_NONE;
+	girq->handler = handle_simple_irq;
+	girq->threaded = true;
+	girq->first = irq_base; /* FIXME: get rid of this */
+
+	ret = devm_request_threaded_irq(&client->dev, client->irq,
+					NULL, adl1000_irq_handler,
+					IRQF_ONESHOT | IRQF_SHARED,
+					dev_name(&client->dev), chip);
+	if (ret) {
+		dev_err(&client->dev, "failed to request irq %d\n",
+			client->irq);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+
+static int device_pca95xx_init(struct adl1000_chip *chip, u32 invert)
+{
+	//DECLARE_BITMAP(val, MAX_LINE);
+	u8 regaddr;
+	int ret;
+
+	regaddr = chip->recalc_addr(chip, chip->regs->output, 0);
+	ret = regcache_sync_region(chip->regmap, regaddr,
+				   regaddr + NBANK(chip) - 1);
+	if (ret)
+		goto out;
+
+	regaddr = chip->recalc_addr(chip, chip->regs->direction, 0);
+	ret = regcache_sync_region(chip->regmap, regaddr,
+				   regaddr + NBANK(chip) - 1);
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
+
+
+
+static int adl1000_probe(struct i2c_client *client)
+{
+	struct adl1000_platform_data *pdata;
+	struct adl1000_chip *chip;
+	int irq_base = 0;
+	int ret;
+	u32 invert = 0;
+	struct regulator *reg;
+	const struct regmap_config *regmap_config;
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (chip == NULL)
+		return -ENOMEM;
+
+	pdata = dev_get_platdata(&client->dev);
+	if (pdata) {
+		irq_base = pdata->irq_base;
+		chip->gpio_start = pdata->gpio_base;
+		invert = pdata->invert;
+		chip->names = pdata->names;
+	} else {
+		struct gpio_desc *reset_gpio;
+
+		chip->gpio_start = -1;
+		irq_base = 0;
+
+		reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
+						     GPIOD_OUT_LOW);
+		if (IS_ERR(reset_gpio))
+			return PTR_ERR(reset_gpio);
+	}
+
+	chip->client = client;
+	chip->driver_data = (uintptr_t)i2c_get_match_data(client);
+	if (!chip->driver_data)
+		return -ENODEV;
+
+	reg = devm_regulator_get(&client->dev, "vcc");
+	if (IS_ERR(reg))
+		return dev_err_probe(&client->dev, PTR_ERR(reg), "reg get err\n");
+
+	ret = regulator_enable(reg);
+	if (ret) {
+		dev_err(&client->dev, "reg en err: %d\n", ret);
+		return ret;
+	}
+	chip->regulator = reg;
+
+	i2c_set_clientdata(client, chip);
+	adl1000_setup_gpio(chip, chip->driver_data );
+
+	regmap_config = &adl1000_i2c_regmap;
+	chip->recalc_addr = adl1000_recalc_addr;
+
+	chip->regmap = devm_regmap_init_i2c(client, regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		ret = PTR_ERR(chip->regmap);
+		goto err_exit;
+	}
+
+	regcache_mark_dirty(chip->regmap);
+
+	mutex_init(&chip->i2c_lock);
+	/*
+	 * In case we have an i2c-mux controlled by a GPIO provided by an
+	 * expander using the same driver higher on the device tree, read the
+	 * i2c adapter nesting depth and use the retrieved value as lockdep
+	 * subclass for chip->i2c_lock.
+	 *
+	 * REVISIT: This solution is not complete. It protects us from lockdep
+	 * false positives when the expander controlling the i2c-mux is on
+	 * a different level on the device tree, but not when it's on the same
+	 * level on a different branch (in which case the subclass number
+	 * would be the same).
+	 *
+	 * TODO: Once a correct solution is developed, a similar fix should be
+	 * applied to all other i2c-controlled GPIO expanders (and potentially
+	 * regmap-i2c).
+	 */
+	lockdep_set_subclass(&chip->i2c_lock,
+			     i2c_adapter_depth(client->adapter));
+
+	ret = device_reset(&client->dev);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	/* initialize cached registers from their original values.
+	 * we can't share this chip with another i2c master.
+	 */
+
+	chip->regs = &adl1000_regs;
+	ret = device_pca95xx_init(chip, invert);
+
+	if (ret)
+		goto err_exit;
+
+	ret = adl1000_irq_setup(chip, irq_base);
+	if (ret)
+		goto err_exit;
+
+	ret = devm_gpiochip_add_data(&client->dev, &chip->gpio_chip, chip);
+	if (ret)
+		goto err_exit;
+
+	if (pdata && pdata->setup) {
+		ret = pdata->setup(client, chip->gpio_chip.base,
+				   chip->gpio_chip.ngpio, pdata->context);
+		if (ret < 0)
+			dev_warn(&client->dev, "setup failed, %d\n", ret);
+	}
+
+	return 0;
+
+err_exit:
+	regulator_disable(chip->regulator);
+	return ret;
+}
+
+static void adl1000_remove(struct i2c_client *client)
+{
+	struct adl1000_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct adl1000_chip *chip = i2c_get_clientdata(client);
+
+	if (pdata && pdata->teardown) {
+		pdata->teardown(client, chip->gpio_chip.base,
+				chip->gpio_chip.ngpio, pdata->context);
+	}
+
+	regulator_disable(chip->regulator);
+}
+
+
+static const struct of_device_id adl1000_dt_ids[] = {
+	{ .compatible = "adlink,adl1000", },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, adl1000_dt_ids);
+
+
+static struct i2c_driver adl1000_driver = {
+	.driver = {
+		.name	= "adl1000",
+		.of_match_table = adl1000_dt_ids,
+	},
+	.probe		= adl1000_probe,
+	.remove		= adl1000_remove,
+	.id_table	= adl1000_id,
+};
+
+static int __init adl1000_init(void)
+{
+	return i2c_add_driver(&adl1000_driver);
+}
+/* register after i2c postcore initcall and before
+ * subsys initcalls that may rely on these GPIOs
+ */
+subsys_initcall(adl1000_init);
+
+static void __exit adl1000_exit(void)
+{
+	i2c_del_driver(&adl1000_driver);
+}
+module_exit(adl1000_exit);
+
+MODULE_AUTHOR("Jimmy Yu <jimmy.yu@adlinktech.com>");
+MODULE_DESCRIPTION("GPIO expander driver for PCA953x");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index f46f7dcb8e87..6d2ca6b2bd6a 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -131,6 +131,19 @@ config DRM_LONTIUM_LT9611
 	  HDMI signals
 	  Please say Y if you have such hardware.
 
+config DRM_ADLINK_LT9611
+	tristate "Adlink LT9611 DSI/HDMI bridge"
+	depends on OF
+	select DRM_PANEL_BRIDGE
+	select DRM_KMS_HELPER
+	select DRM_MIPI_DSI
+	select REGMAP_I2C
+	help
+	  Driver for Lontium LT9611 DSI to HDMI bridge
+	  chip driver that converts dual DSI and I2S to
+	  HDMI signals
+	  Please say Y if you have such hardware.
+
 config DRM_LONTIUM_LT9611UXC
 	tristate "Lontium LT9611UXC DSI/HDMI bridge"
 	select SND_SOC_HDMI_CODEC if SND_SOC
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 4d3a9ec08b25..ec920925fcbc 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_DRM_FSL_LDB) += fsl-ldb.o
 obj-$(CONFIG_DRM_ITE_IT6505) += ite-it6505.o
 obj-$(CONFIG_DRM_LONTIUM_LT8912B) += lontium-lt8912b.o
 obj-$(CONFIG_DRM_LONTIUM_LT9211) += lontium-lt9211.o
+obj-$(CONFIG_DRM_ADLINK_LT9611) += adlink-lt9611.o
 obj-$(CONFIG_DRM_LONTIUM_LT9611) += lontium-lt9611.o
 obj-$(CONFIG_DRM_LONTIUM_LT9611UXC) += lontium-lt9611uxc.o
 obj-$(CONFIG_DRM_FSL_IMX_LVDS_BRIDGE) += fsl-imx-ldb.o
diff --git a/drivers/gpu/drm/bridge/adlink-lt9611.c b/drivers/gpu/drm/bridge/adlink-lt9611.c
new file mode 100644
index 000000000000..ef1c1892a613
--- /dev/null
+++ b/drivers/gpu/drm/bridge/adlink-lt9611.c
@@ -0,0 +1,1282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020. Linaro Limited.
+ */
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/hdmi-codec.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include <media/cec.h>
+
+#define EDID_SEG_SIZE	256
+#define EDID_LEN	32
+#define EDID_LOOP	8
+#define KEY_DDC_ACCS_DONE 0x02
+#define DDC_NO_ACK	0x50
+
+#define LT9611_4LANES	0
+
+struct lt9611 {
+	struct device *dev;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+
+	struct regmap *regmap;
+
+	struct device_node *dsi0_node;
+	struct device_node *dsi1_node;
+	struct mipi_dsi_device *dsi0;
+	struct mipi_dsi_device *dsi1;
+	struct platform_device *audio_pdev;
+
+	bool ac_mode;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *enable_gpio;
+
+	bool power_on;
+	bool sleep;
+
+	struct regulator_bulk_data supplies[2];
+
+	struct i2c_client *client;
+
+	enum drm_connector_status status;
+
+	struct cec_adapter *cec_adap;
+
+	u8 edid_buf[EDID_SEG_SIZE];
+	u32 vic;
+};
+
+#define LT9611_PAGE_CONTROL	0xff
+
+static const struct regmap_range_cfg lt9611_ranges[] = {
+	{
+		.name = "register_range",
+		.range_min =  0,
+		.range_max = 0x85ff,
+		.selector_reg = LT9611_PAGE_CONTROL,
+		.selector_mask = 0xff,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 0x100,
+	},
+};
+
+static const struct regmap_config lt9611_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xffff,
+	.ranges = lt9611_ranges,
+	.num_ranges = ARRAY_SIZE(lt9611_ranges),
+};
+
+struct lt9611_mode {
+	u16 hdisplay;
+	u16 vdisplay;
+	u8 vrefresh;
+	u8 lanes;
+	u8 intfs;
+};
+
+static struct lt9611_mode lt9611_modes[] = {
+	{ 3840, 2160, 30, 4, 1 }, /* 3840x2160 24bit 30Hz 4Lane 1port */
+	{ 1920, 1080, 60, 4, 1 }, /* 1080P 24bit 60Hz 4lane 1port */
+	{ 1920, 1080, 30, 3, 1 }, /* 1080P 24bit 30Hz 3lane 1port */
+	{ 1920, 1080, 24, 3, 1 },
+	{ 720, 480, 60, 4, 1 },
+	{ 720, 576, 50, 2, 1 },
+	{ 640, 480, 60, 2, 1 },
+};
+
+static struct lt9611 *bridge_to_lt9611(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct lt9611, bridge);
+}
+
+static struct lt9611 *connector_to_lt9611(struct drm_connector *connector)
+{
+	return container_of(connector, struct lt9611, connector);
+}
+
+static int lt9611_mipi_input_analog(struct lt9611 *lt9611)
+{
+	const struct reg_sequence reg_cfg[] = {
+		{ 0x8106, 0x40 }, /* port A rx current */
+		{ 0x810a, 0xfe }, /* port A ldo voltage set */
+		{ 0x810b, 0xbf }, /* enable port A lprx */
+		{ 0x8111, 0x40 }, /* port B rx current */
+		{ 0x8115, 0xfe }, /* port B ldo voltage set */
+		{ 0x8116, 0xbf }, /* enable port B lprx */
+
+		{ 0x811c, 0x03 }, /* PortA clk lane no-LP mode */
+		{ 0x8120, 0x03 }, /* PortB clk lane with-LP mode */
+	};
+
+	return regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+}
+
+static int lt9611_mipi_input_digital(struct lt9611 *lt9611,
+				     const struct drm_display_mode *mode)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0x8300, LT9611_4LANES },
+		{ 0x830a, 0x00 },
+		{ 0x824f, 0x80 },
+		{ 0x8250, 0x10 },
+		{ 0x8302, 0x0a },
+		{ 0x8306, 0x0a },
+	};
+
+	//if (mode->hdisplay == 3840)
+	//	reg_cfg[1].def = 0x03;
+
+	return regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+}
+
+static void lt9611_mipi_video_setup(struct lt9611 *lt9611,
+				    const struct drm_display_mode *mode)
+{
+	u32 h_total, hactive, hsync_len, hfront_porch, hsync_porch;
+	u32 v_total, vactive, vsync_len, vfront_porch, vsync_porch;
+
+	h_total = mode->htotal;
+	v_total = mode->vtotal;
+
+	hactive = mode->hdisplay;
+	hsync_len = mode->hsync_end - mode->hsync_start;
+	hfront_porch = mode->hsync_start - mode->hdisplay;
+	hsync_porch = hsync_len + mode->htotal - mode->hsync_end;
+
+	vactive = mode->vdisplay;
+	vsync_len = mode->vsync_end - mode->vsync_start;
+	vfront_porch = mode->vsync_start - mode->vdisplay;
+	vsync_porch = vsync_len + mode->vtotal - mode->vsync_end;
+	if(hactive==3840)
+	{
+		vsync_porch=296;
+		printk("jimmy lt9611_mipi_video_setup force vsync_porch as 296\n");
+	}
+
+	printk("\n\njimmy lt9611_mipi_video_setup htotal:%d vtotal:%d hact:%d vact:%d\n",h_total,v_total,hactive,vactive);
+	printk("jimmy lt9611_mipi_video_setup hs:%d hfp:%d hbp:%d\n",hsync_len,hfront_porch,hsync_porch);
+	printk("jimmy lt9611_mipi_video_setup vs:%d vfp:%d vbp:%d\n\n\n",vsync_len,vfront_porch,vsync_porch);
+
+	regmap_write(lt9611->regmap, 0x830d, (u8)(v_total / 256));
+	regmap_write(lt9611->regmap, 0x830e, (u8)(v_total % 256));
+
+	regmap_write(lt9611->regmap, 0x830f, (u8)(vactive / 256));
+	regmap_write(lt9611->regmap, 0x8310, (u8)(vactive % 256));
+
+	regmap_write(lt9611->regmap, 0x8311, (u8)(h_total / 256));
+	regmap_write(lt9611->regmap, 0x8312, (u8)(h_total % 256));
+
+	regmap_write(lt9611->regmap, 0x8313, (u8)(hactive / 256));
+	regmap_write(lt9611->regmap, 0x8314, (u8)(hactive % 256));
+
+	regmap_write(lt9611->regmap, 0x8315, (u8)(vsync_len % 256));
+	regmap_write(lt9611->regmap, 0x8316, (u8)(hsync_len % 256));
+
+	regmap_write(lt9611->regmap, 0x8317, (u8)(vfront_porch % 256));
+
+	regmap_write(lt9611->regmap, 0x8318, (u8)(vsync_porch % 256));
+
+	regmap_write(lt9611->regmap, 0x8319, (u8)(hfront_porch % 256));
+
+	regmap_write(lt9611->regmap, 0x831a, (u8)(hsync_porch / 256));
+	regmap_write(lt9611->regmap, 0x831b, (u8)(hsync_porch % 256));
+}
+
+static void lt9611_pcr_setup(struct lt9611 *lt9611, const struct drm_display_mode *mode)
+{
+	const struct reg_sequence reg_cfg[] = {
+		{ 0x830b, 0x01 },
+		{ 0x830c, 0x10 },
+		{ 0x8348, 0x00 },
+		{ 0x8349, 0x81 },
+
+		/* stage 1 */
+		{ 0x8321, 0x4a },
+		{ 0x8324, 0x71 },
+		{ 0x8325, 0x30 },
+		{ 0x832a, 0x01 },
+
+		/* stage 2 */
+		{ 0x834a, 0x40 },
+		{ 0x831d, 0x10 },
+
+		/* MK limit */
+		{ 0x832d, 0x38 },
+		{ 0x8331, 0x08 },
+	};
+	/*
+	const struct reg_sequence reg_cfg2[] = {
+		{ 0x830b, 0x03 },
+		{ 0x830c, 0xd0 },
+		{ 0x8348, 0x03 },
+		{ 0x8349, 0xe0 },
+		{ 0x8324, 0x72 },
+		{ 0x8325, 0x00 },
+		{ 0x832a, 0x01 },
+		{ 0x834a, 0x10 },
+		{ 0x831d, 0x10 },
+		{ 0x8326, 0x37 },
+	};*/
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	switch (mode->hdisplay) {
+	case 640:
+		regmap_write(lt9611->regmap, 0x8326, 0x14);
+		break;
+	case 1920:
+		regmap_write(lt9611->regmap, 0x8326, 0x37);
+		break;
+	case 3840:
+		//regmap_multi_reg_write(lt9611->regmap, reg_cfg2, ARRAY_SIZE(reg_cfg2));
+		regmap_write(lt9611->regmap, 0x8326, 0x37);
+		break;
+	}
+
+	/* pcr rst */
+	regmap_write(lt9611->regmap, 0x8011, 0x5a);
+	regmap_write(lt9611->regmap, 0x8011, 0xfa);
+}
+
+static int lt9611_pll_setup(struct lt9611 *lt9611, const struct drm_display_mode *mode)
+{
+	unsigned int pclk = mode->clock;
+	const struct reg_sequence reg_cfg[] = {
+		/* txpll init */
+		{ 0x8123, 0x40 },
+		{ 0x8124, 0x64 },
+		{ 0x8125, 0x80 },
+		{ 0x8126, 0x55 },
+		{ 0x812c, 0x37 },
+		{ 0x812f, 0x01 },
+		{ 0x8126, 0x55 },
+		{ 0x8127, 0x66 },
+		{ 0x8128, 0x88 },
+		{ 0x812a, 0x20 },    //for U3
+	};
+	printk("jimmy lt9611_pll_setup pclk:%d\n",pclk);
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+
+	if (pclk > 150000)
+		regmap_write(lt9611->regmap, 0x812d, 0x88);
+	else if (pclk > 70000)
+		regmap_write(lt9611->regmap, 0x812d, 0x99);
+	else
+		regmap_write(lt9611->regmap, 0x812d, 0xaa);
+
+	/*
+	 * first divide pclk by 2 first
+	 *  - write divide by 64k to 19:16 bits which means shift by 17
+	 *  - write divide by 256 to 15:8 bits which means shift by 9
+	 *  - write remainder to 7:0 bits, which means shift by 1
+	 */
+	regmap_write(lt9611->regmap, 0x82e3, pclk >> 17); /* pclk[19:16] */
+	regmap_write(lt9611->regmap, 0x82e4, pclk >> 9);  /* pclk[15:8]  */
+	regmap_write(lt9611->regmap, 0x82e5, pclk >> 1);  /* pclk[7:0]   */
+
+	regmap_write(lt9611->regmap, 0x82de, 0x20);
+	regmap_write(lt9611->regmap, 0x82de, 0xe0);
+
+	regmap_write(lt9611->regmap, 0x8016, 0xf1);
+	regmap_write(lt9611->regmap, 0x8016, 0xf3);
+
+	return 0;
+}
+
+static int lt9611_read_video_check(struct lt9611 *lt9611, unsigned int reg)
+{
+	unsigned int temp, temp2;
+	int ret;
+
+	ret = regmap_read(lt9611->regmap, reg, &temp);
+	if (ret)
+		return ret;
+	temp <<= 8;
+	ret = regmap_read(lt9611->regmap, reg + 1, &temp2);
+	if (ret)
+		return ret;
+
+	return (temp + temp2);
+}
+
+static int lt9611_video_check(struct lt9611 *lt9611)
+{
+	u32 v_total, vactive, hactive_a, hactive_b, h_total_sysclk;
+	int temp;
+
+	/* top module video check */
+
+	/* vactive */
+	temp = lt9611_read_video_check(lt9611, 0x8282);
+	if (temp < 0)
+		goto end;
+	vactive = temp;
+
+	/* v_total */
+	temp = lt9611_read_video_check(lt9611, 0x826c);
+	if (temp < 0)
+		goto end;
+	v_total = temp;
+
+	/* h_total_sysclk */
+	temp = lt9611_read_video_check(lt9611, 0x8286);
+	if (temp < 0)
+		goto end;
+	h_total_sysclk = temp;
+
+	/* hactive_a */
+	temp = lt9611_read_video_check(lt9611, 0x8382);
+	if (temp < 0)
+		goto end;
+	hactive_a = temp / 3;
+
+	/* hactive_b */
+	temp = lt9611_read_video_check(lt9611, 0x8386);
+	if (temp < 0)
+		goto end;
+	hactive_b = temp / 3;
+
+	dev_info(lt9611->dev,
+		 "video check: hactive_a=%d, hactive_b=%d, vactive=%d, v_total=%d, h_total_sysclk=%d\n",
+		 hactive_a, hactive_b, vactive, v_total, h_total_sysclk);
+
+	return 0;
+
+end:
+	dev_err(lt9611->dev, "read video check error\n");
+	return temp;
+}
+
+static void lt9611_hdmi_tx_digital(struct lt9611 *lt9611)
+{
+	regmap_write(lt9611->regmap, 0x8443, 0x46 - lt9611->vic);
+	regmap_write(lt9611->regmap, 0x8447, lt9611->vic);
+	regmap_write(lt9611->regmap, 0x843d, 0x0a); /* UD1 infoframe */
+
+	regmap_write(lt9611->regmap, 0x82d6, 0x8c);
+	regmap_write(lt9611->regmap, 0x82d7, 0x04);
+}
+
+static void lt9611_hdmi_tx_phy(struct lt9611 *lt9611)
+{
+	struct reg_sequence reg_cfg[] = {
+		{ 0x8130, 0x6a },
+		{ 0x8131, 0x44 }, /* HDMI DC mode */
+		{ 0x8132, 0x4a },
+		{ 0x8133, 0x0b },
+		{ 0x8134, 0x00 },
+		{ 0x8135, 0x00 },
+		{ 0x8136, 0x00 },
+		{ 0x8137, 0x44 },
+		{ 0x813f, 0x0f },
+		{ 0x8140, 0xa0 },
+		{ 0x8141, 0xa0 },
+		{ 0x8142, 0xa0 },
+		{ 0x8143, 0xa0 },
+		{ 0x8144, 0x0a },
+	};
+
+	/* HDMI AC mode */
+	if (lt9611->ac_mode)
+		reg_cfg[2].def = 0x73;
+
+	regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));
+}
+
+static irqreturn_t lt9611_irq_thread_handler(int irq, void *dev_id)
+{
+	struct lt9611 *lt9611 = dev_id;
+	unsigned int irq_flag0 = 0;
+	unsigned int irq_flag3 = 0;
+
+	regmap_read(lt9611->regmap, 0x820f, &irq_flag3);
+	regmap_read(lt9611->regmap, 0x820c, &irq_flag0);
+
+	/* hpd changed low */
+	if (irq_flag3 & 0x80) {
+		dev_info(lt9611->dev, "hdmi cable disconnected\n");
+
+		regmap_write(lt9611->regmap, 0x8207, 0xbf);
+		regmap_write(lt9611->regmap, 0x8207, 0x3f);
+	}
+
+	/* hpd changed high */
+	if (irq_flag3 & 0x40) {
+		dev_info(lt9611->dev, "hdmi cable connected\n");
+
+		regmap_write(lt9611->regmap, 0x8207, 0x7f);
+		regmap_write(lt9611->regmap, 0x8207, 0x3f);
+	}
+
+	if (irq_flag3 & 0xc0 && lt9611->bridge.dev)
+		drm_kms_helper_hotplug_event(lt9611->bridge.dev);
+
+	/* video input changed */
+	if (irq_flag0 & 0x01) {
+		dev_info(lt9611->dev, "video input changed\n");
+		regmap_write(lt9611->regmap, 0x829e, 0xff);
+		regmap_write(lt9611->regmap, 0x829e, 0xf7);
+		regmap_write(lt9611->regmap, 0x8204, 0xff);
+		regmap_write(lt9611->regmap, 0x8204, 0xfe);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void lt9611_enable_hpd_interrupts(struct lt9611 *lt9611)
+{
+	unsigned int val;
+
+	regmap_read(lt9611->regmap, 0x8203, &val);
+
+	val &= ~0xc0;
+	regmap_write(lt9611->regmap, 0x8203, val);
+	regmap_write(lt9611->regmap, 0x8207, 0xff); /* clear */
+	regmap_write(lt9611->regmap, 0x8207, 0x3f);
+}
+
+#if 0
+static void lt9611_sleep_setup(struct lt9611 *lt9611)
+{
+	const struct reg_sequence sleep_setup[] = {
+		{ 0x8024, 0x76 },
+		{ 0x8023, 0x01 },
+		{ 0x8157, 0x03 }, /* set addr pin as output */
+		{ 0x8149, 0x0b },
+		{ 0x8151, 0x30 }, /* disable IRQ */
+		{ 0x8102, 0x48 }, /* MIPI Rx power down */
+		{ 0x8123, 0x80 },
+		{ 0x8130, 0x00 },
+		{ 0x8100, 0x01 }, /* bandgap power down */
+		{ 0x8101, 0x00 }, /* system clk power down */
+	};
+
+	regmap_multi_reg_write(lt9611->regmap,
+			       sleep_setup, ARRAY_SIZE(sleep_setup));
+	lt9611->sleep = true;
+}
+#endif
+static int lt9611_power_on(struct lt9611 *lt9611)
+{
+	int ret;
+	const struct reg_sequence seq[] = {
+		/* LT9611_System_Init */
+		{ 0x8101, 0x18 }, /* sel xtal clock */
+
+		/* timer for frequency meter */
+		{ 0x821b, 0x69 }, /* timer 2 */
+		{ 0x821c, 0x78 },
+		{ 0x82cb, 0x69 }, /* timer 1 */
+		{ 0x82cc, 0x78 },
+
+		/* irq init */
+		{ 0x8251, 0x01 },
+		{ 0x8258, 0x0a }, /* hpd irq */
+		{ 0x8259, 0x80 }, /* hpd debounce width */
+		{ 0x829e, 0xf7 }, /* video check irq */
+
+		/* power consumption for work */
+		{ 0x8004, 0xf0 },
+		{ 0x8006, 0xf0 },
+		{ 0x800a, 0x80 },
+		{ 0x800b, 0x40 },
+		{ 0x800d, 0xef },
+		{ 0x8011, 0xfa },
+	};
+
+	if (lt9611->power_on)
+		return 0;
+
+	ret = regmap_multi_reg_write(lt9611->regmap, seq, ARRAY_SIZE(seq));
+	if (!ret)
+		lt9611->power_on = true;
+
+	return ret;
+}
+
+static int lt9611_power_off(struct lt9611 *lt9611)
+{
+	int ret;
+
+	ret = regmap_write(lt9611->regmap, 0x8130, 0x6a);
+	if (!ret)
+		lt9611->power_on = false;
+
+	return ret;
+}
+
+static void lt9611_reset(struct lt9611 *lt9611)
+{
+	/*
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 1);
+	msleep(20);
+
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 0);
+	msleep(20);
+
+	gpiod_set_value_cansleep(lt9611->reset_gpio, 1);
+	msleep(100);
+	*/
+}
+
+/*static void lt9611_assert_5v(struct lt9611 *lt9611)
+{
+	if (!lt9611->enable_gpio)
+		return;
+
+	gpiod_set_value_cansleep(lt9611->enable_gpio, 1);
+	msleep(20);
+}
+
+static int lt9611_regulator_init(struct lt9611 *lt9611)
+{
+	int ret;
+
+	lt9611->supplies[0].supply = "vdd";
+	lt9611->supplies[1].supply = "vcc";
+
+	ret = devm_regulator_bulk_get(lt9611->dev, 2, lt9611->supplies);
+	if (ret < 0)
+		return ret;
+
+	return regulator_set_load(lt9611->supplies[0].consumer, 300000);
+}
+
+static int lt9611_regulator_enable(struct lt9611 *lt9611)
+{
+	int ret;
+
+	ret = regulator_enable(lt9611->supplies[0].consumer);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 10000);
+
+	ret = regulator_enable(lt9611->supplies[1].consumer);
+	if (ret < 0) {
+		regulator_disable(lt9611->supplies[0].consumer);
+		return ret;
+	}
+
+	return 0;
+}*/
+
+static struct lt9611_mode *lt9611_find_mode(const struct drm_display_mode *mode)
+{
+	int i;
+
+	printk("hsiplay: %d vdisplay: %d vrefresh: %d\n", mode->hdisplay, mode->vdisplay, drm_mode_vrefresh(mode));
+	for (i = 0; i < ARRAY_SIZE(lt9611_modes); i++) {
+		if (lt9611_modes[i].hdisplay == mode->hdisplay &&
+		    lt9611_modes[i].vdisplay == mode->vdisplay &&
+		    lt9611_modes[i].vrefresh == drm_mode_vrefresh(mode)) {
+			return &lt9611_modes[i];
+		}
+	}
+
+	return NULL;
+}
+
+/* connector funcs */
+static enum drm_connector_status
+lt9611_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct lt9611 *lt9611 = connector_to_lt9611(connector);
+	unsigned int reg_val = 0;
+	int connected = 0;
+
+	regmap_read(lt9611->regmap, 0x825e, &reg_val);
+	connected  = (reg_val & BIT(2));
+
+	lt9611->status = connected ?  connector_status_connected :
+				connector_status_disconnected;
+
+	return lt9611->status;
+}
+
+static int lt9611_read_edid(struct lt9611 *lt9611)
+{
+	unsigned int temp;
+	int ret = 0;
+	int i, j;
+
+	msleep(500);//wait for clk_disable_unused finish
+
+	/* memset to clear old buffer, if any */
+	memset(lt9611->edid_buf, 0, sizeof(lt9611->edid_buf));
+
+	regmap_write(lt9611->regmap, 0x8503, 0xc9);
+
+	/* 0xA0 is EDID device address */
+	regmap_write(lt9611->regmap, 0x8504, 0xa0);
+	/* 0x00 is EDID offset address */
+	regmap_write(lt9611->regmap, 0x8505, 0x00);
+
+	/* length for read */
+	regmap_write(lt9611->regmap, 0x8506, EDID_LEN);
+	regmap_write(lt9611->regmap, 0x8514, 0x7f);
+
+	for (i = 0; i < EDID_LOOP; i++) {
+		/* offset address */
+		regmap_write(lt9611->regmap, 0x8505, i * EDID_LEN);
+		regmap_write(lt9611->regmap, 0x8507, 0x36);
+		regmap_write(lt9611->regmap, 0x8507, 0x31);
+		regmap_write(lt9611->regmap, 0x8507, 0x37);
+		usleep_range(5000, 10000);
+
+		regmap_read(lt9611->regmap, 0x8540, &temp);
+
+		if (temp & KEY_DDC_ACCS_DONE) {
+			for (j = 0; j < EDID_LEN; j++) {
+				regmap_read(lt9611->regmap, 0x8583, &temp);
+				lt9611->edid_buf[i * EDID_LEN + j] = temp;
+			}
+
+		} else if (temp & DDC_NO_ACK) { /* DDC No Ack or Abitration lost */
+			dev_err(lt9611->dev, "read edid failed: no ack\n");
+			ret = -EIO;
+			goto end;
+
+		} else {
+			dev_err(lt9611->dev, "read edid failed: access not done\n");
+			ret = -EIO;
+			goto end;
+		}
+	}
+
+end:
+	regmap_write(lt9611->regmap, 0x8507, 0x1f);
+
+	return ret;
+}
+
+static int
+lt9611_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)
+{
+	struct lt9611 *lt9611 = data;
+	int ret;
+
+	if (len > 128)
+		return -EINVAL;
+
+	/* supports up to 1 extension block */
+	/* TODO: add support for more extension blocks */
+	if (block > 1)
+		return -EINVAL;
+
+	if (block == 0) {
+		ret = lt9611_read_edid(lt9611);
+		if (ret) {
+			dev_err(lt9611->dev, "edid read failed\n");
+			return ret;
+		}
+	}
+
+	block %= 2;
+	memcpy(buf, lt9611->edid_buf + (block * 128), len);
+
+	return 0;
+}
+
+static int lt9611_connector_get_modes(struct drm_connector *connector)
+{
+	struct lt9611 *lt9611 = connector_to_lt9611(connector);
+	unsigned int count;
+	struct edid *edid;
+
+	lt9611_power_on(lt9611);
+	edid = drm_do_get_edid(connector, lt9611_get_edid_block, lt9611);
+	drm_connector_update_edid_property(connector, edid);
+	count = drm_add_edid_modes(connector, edid);
+	kfree(edid);
+
+	return count;
+}
+
+static enum drm_mode_status
+lt9611_connector_mode_valid(struct drm_connector *connector,
+			    struct drm_display_mode *mode)
+{
+	struct lt9611_mode *lt9611_mode = lt9611_find_mode(mode);
+
+	return lt9611_mode ? MODE_OK : MODE_BAD;
+}
+
+/* bridge funcs */
+static void lt9611_bridge_enable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (lt9611_power_on(lt9611)) {
+		dev_err(lt9611->dev, "power on failed\n");
+		return;
+	}
+
+	lt9611_mipi_input_analog(lt9611);
+	lt9611_hdmi_tx_digital(lt9611);
+	lt9611_hdmi_tx_phy(lt9611);
+
+	msleep(500);
+
+	lt9611_video_check(lt9611);
+
+	/* Enable HDMI output */
+	regmap_write(lt9611->regmap, 0x8130, 0xea);
+}
+
+static void lt9611_bridge_disable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	int ret;
+
+	/* Disable HDMI output */
+	ret = regmap_write(lt9611->regmap, 0x8130, 0x6a);
+	if (ret) {
+		dev_err(lt9611->dev, "video on failed\n");
+		return;
+	}
+
+	if (lt9611_power_off(lt9611)) {
+		dev_err(lt9611->dev, "power on failed\n");
+		return;
+	}
+}
+
+static struct
+drm_connector_helper_funcs lt9611_bridge_connector_helper_funcs = {
+	.get_modes = lt9611_connector_get_modes,
+	.mode_valid = lt9611_connector_mode_valid,
+};
+
+static const struct drm_connector_funcs lt9611_bridge_connector_funcs = {
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = lt9611_connector_detect,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static struct mipi_dsi_device *lt9611_attach_dsi(struct lt9611 *lt9611,
+						 struct device_node *dsi_node)
+{
+	const struct mipi_dsi_device_info info = { "lt9611", 0, NULL };
+	struct mipi_dsi_device *dsi;
+	struct mipi_dsi_host *host;
+	int ret;
+
+	host = of_find_mipi_dsi_host_by_node(dsi_node);
+	if (!host) {
+		dev_err(lt9611->dev, "failed to find dsi host\n");
+		return ERR_PTR(-EPROBE_DEFER);
+	}
+
+	dsi = mipi_dsi_device_register_full(host, &info);
+	if (IS_ERR(dsi)) {
+		dev_err(lt9611->dev, "failed to create dsi device\n");
+		return dsi;
+	}
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_VIDEO_HSE;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(lt9611->dev, "failed to attach dsi to host\n");
+		mipi_dsi_device_unregister(dsi);
+		return ERR_PTR(ret);
+	}
+
+	return dsi;
+}
+
+static void lt9611_bridge_detach(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (lt9611->dsi1) {
+		mipi_dsi_detach(lt9611->dsi1);
+		mipi_dsi_device_unregister(lt9611->dsi1);
+	}
+
+	mipi_dsi_detach(lt9611->dsi0);
+	mipi_dsi_device_unregister(lt9611->dsi0);
+}
+
+static int lt9611_connector_init(struct drm_bridge *bridge, struct lt9611 *lt9611)
+{
+	int ret;
+
+	ret = drm_connector_init(bridge->dev, &lt9611->connector,
+				 &lt9611_bridge_connector_funcs,
+				 DRM_MODE_CONNECTOR_HDMIA);
+	if (ret) {
+		DRM_ERROR("Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(&lt9611->connector,
+				 &lt9611_bridge_connector_helper_funcs);
+	drm_connector_attach_encoder(&lt9611->connector, bridge->encoder);
+
+	if (!bridge->encoder) {
+		DRM_ERROR("Parent encoder object not found");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int lt9611_bridge_attach(struct drm_bridge *bridge,
+				enum drm_bridge_attach_flags flags)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	int ret;
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		ret = lt9611_connector_init(bridge, lt9611);
+		if (ret < 0)
+			return ret;
+	}
+
+	if(lt9611 == NULL) {
+		printk("lt9611 is null\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* Attach primary DSI */
+	lt9611->dsi0 = lt9611_attach_dsi(lt9611, lt9611->dsi0_node);
+	if ((lt9611->dsi0 == NULL) || IS_ERR(lt9611->dsi0))
+		return -EPROBE_DEFER; //PTR_ERR(lt9611->dsi0);
+
+	/* Attach secondary DSI, if specified */
+	if (lt9611->dsi1_node) {
+		lt9611->dsi1 = lt9611_attach_dsi(lt9611, lt9611->dsi1_node);
+		if (IS_ERR(lt9611->dsi1)) {
+			ret = PTR_ERR(lt9611->dsi1);
+			goto err_unregister_dsi0;
+		}
+	}
+
+	return 0;
+
+err_unregister_dsi0:
+	lt9611_bridge_detach(bridge);
+	drm_connector_cleanup(&lt9611->connector);
+	mipi_dsi_device_unregister(lt9611->dsi0);
+
+	return ret;
+}
+
+static enum drm_mode_status lt9611_bridge_mode_valid(struct drm_bridge *bridge,
+						     const struct drm_display_info *info,
+						     const struct drm_display_mode *mode)
+{
+	struct lt9611_mode *lt9611_mode = lt9611_find_mode(mode);
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (!lt9611_mode)
+		return MODE_BAD;
+	else if (lt9611_mode->intfs > 1 && !lt9611->dsi1)
+		return MODE_PANEL;
+	else
+		return MODE_OK;
+}
+
+static void lt9611_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	if (!lt9611->sleep)
+		return;
+
+	lt9611_reset(lt9611);
+	regmap_write(lt9611->regmap, 0x80ee, 0x01);
+
+	lt9611->sleep = false;
+}
+
+/*static void lt9611_bridge_post_disable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	lt9611_sleep_setup(lt9611);
+}*/
+
+static void lt9611_bridge_mode_set(struct drm_bridge *bridge,
+				   const struct drm_display_mode *mode,
+				   const struct drm_display_mode *adj_mode)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	struct hdmi_avi_infoframe avi_frame;
+	int ret;
+
+	lt9611_bridge_pre_enable(bridge);
+
+	lt9611_mipi_input_digital(lt9611, mode);
+	lt9611_pll_setup(lt9611, mode);
+	lt9611_mipi_video_setup(lt9611, mode);
+	lt9611_pcr_setup(lt9611, mode);
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&avi_frame,
+						       &lt9611->connector,
+						       mode);
+	if (!ret)
+		lt9611->vic = avi_frame.video_code;
+}
+
+static enum drm_connector_status lt9611_bridge_detect(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	unsigned int reg_val = 0;
+	int connected;
+
+	regmap_read(lt9611->regmap, 0x825e, &reg_val);
+	connected  = reg_val & BIT(2);
+
+	lt9611->status = connected ?  connector_status_connected :
+				connector_status_disconnected;
+
+	return lt9611->status;
+}
+
+static struct edid *lt9611_bridge_get_edid(struct drm_bridge *bridge,
+					   struct drm_connector *connector)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+	struct edid *edid;
+
+	lt9611_power_on(lt9611);
+	edid = drm_do_get_edid(connector, lt9611_get_edid_block, lt9611);
+
+	cec_s_phys_addr_from_edid(lt9611->cec_adap, edid);
+	
+	return edid;
+}
+
+/*static void lt9611_bridge_hpd_enable(struct drm_bridge *bridge)
+{
+	struct lt9611 *lt9611 = bridge_to_lt9611(bridge);
+
+	lt9611_enable_hpd_interrupts(lt9611);
+}
+
+
+
+static void lt9611_bridge_hpd_notify(struct drm_bridge *bridge,
+				      enum drm_connector_status status)
+{
+	struct lt9611 *adv = bridge_to_lt9611(bridge);
+
+	if (status == connector_status_disconnected)
+	{
+		cec_phys_addr_invalidate(adv->cec_adap);
+	}
+}*/
+
+static const struct drm_bridge_funcs lt9611_bridge_funcs = {
+	.enable = lt9611_bridge_enable,
+	.disable = lt9611_bridge_disable,
+	.mode_set = lt9611_bridge_mode_set,
+	.mode_valid = lt9611_bridge_mode_valid,
+	.attach = lt9611_bridge_attach,
+	.detect = lt9611_bridge_detect,
+	.get_edid = lt9611_bridge_get_edid,
+	.detach = lt9611_bridge_detach,
+	//.hpd_notify = lt9611_bridge_hpd_notify,
+};
+
+static int lt9611_parse_dt(struct device *dev,
+			   struct lt9611 *lt9611)
+{
+	lt9611->dsi0_node = of_graph_get_remote_node(dev->of_node, 0, -1);
+	if (!lt9611->dsi0_node) {
+		dev_err(lt9611->dev, "failed to get remote node for primary dsi\n");
+		return -ENODEV;
+	}
+
+	lt9611->dsi1_node = of_graph_get_remote_node(dev->of_node, 1, -1);
+
+	lt9611->ac_mode = of_property_read_bool(dev->of_node, "lt,ac-mode");
+
+	return 0;
+}
+
+/*static int lt9611_gpio_init(struct lt9611 *lt9611)
+{
+	struct device *dev = lt9611->dev;
+
+	lt9611->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(lt9611->reset_gpio)) {
+		dev_err(dev, "failed to acquire reset gpio\n");
+		return PTR_ERR(lt9611->reset_gpio);
+	}
+
+	lt9611->enable_gpio = devm_gpiod_get_optional(dev, "enable",
+						      GPIOD_OUT_LOW);
+	if (IS_ERR(lt9611->enable_gpio)) {
+		dev_err(dev, "failed to acquire enable gpio\n");
+		return PTR_ERR(lt9611->enable_gpio);
+	}
+
+	return 0;
+}*/
+
+static int lt9611_read_device_rev(struct lt9611 *lt9611)
+{
+	unsigned int rev;
+	int ret;
+
+	regmap_write(lt9611->regmap, 0x80ee, 0x01);
+	ret = regmap_read(lt9611->regmap, 0x8002, &rev);
+	if (ret)
+		dev_err(lt9611->dev, "failed to read revision: %d\n", ret);
+	else
+		dev_info(lt9611->dev, "LT9611 revision: 0x%x\n", rev);
+
+	return ret;
+}
+
+static int lt9611_hdmi_hw_params(struct device *dev, void *data,
+				 struct hdmi_codec_daifmt *fmt,
+				 struct hdmi_codec_params *hparms)
+{
+	struct lt9611 *lt9611 = data;
+
+	if (hparms->sample_rate == 48000)
+		regmap_write(lt9611->regmap, 0x840f, 0x2b);
+	else if (hparms->sample_rate == 96000)
+		regmap_write(lt9611->regmap, 0x840f, 0xab);
+	else
+		return -EINVAL;
+
+	regmap_write(lt9611->regmap, 0x8435, 0x00);
+	regmap_write(lt9611->regmap, 0x8436, 0x18);
+	regmap_write(lt9611->regmap, 0x8437, 0x00);
+
+	return 0;
+}
+
+static int lt9611_audio_startup(struct device *dev, void *data)
+{
+	struct lt9611 *lt9611 = data;
+
+	regmap_write(lt9611->regmap, 0x82d6, 0x8c);
+	regmap_write(lt9611->regmap, 0x82d7, 0x04);
+
+	regmap_write(lt9611->regmap, 0x8406, 0x08);
+	regmap_write(lt9611->regmap, 0x8407, 0x10);
+
+	regmap_write(lt9611->regmap, 0x8434, 0xd5);
+
+	return 0;
+}
+
+static void lt9611_audio_shutdown(struct device *dev, void *data)
+{
+	struct lt9611 *lt9611 = data;
+
+	regmap_write(lt9611->regmap, 0x8406, 0x00);
+	regmap_write(lt9611->regmap, 0x8407, 0x00);
+}
+
+static int lt9611_hdmi_i2s_get_dai_id(struct snd_soc_component *component,
+				      struct device_node *endpoint)
+{
+	struct of_endpoint of_ep;
+	int ret;
+
+	ret = of_graph_parse_endpoint(endpoint, &of_ep);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * HDMI sound should be located as reg = <2>
+	 * Then, it is sound port 0
+	 */
+	if (of_ep.port == 2)
+		return 0;
+
+	return -EINVAL;
+}
+
+static const struct hdmi_codec_ops lt9611_codec_ops = {
+	.hw_params	= lt9611_hdmi_hw_params,
+	.audio_shutdown = lt9611_audio_shutdown,
+	.audio_startup	= lt9611_audio_startup,
+	.get_dai_id	= lt9611_hdmi_i2s_get_dai_id,
+};
+
+static struct hdmi_codec_pdata codec_data = {
+	.ops = &lt9611_codec_ops,
+	.max_i2s_channels = 8,
+	.i2s = 1,
+};
+
+static int lt9611_audio_init(struct device *dev, struct lt9611 *lt9611)
+{
+	codec_data.data = lt9611;
+	lt9611->audio_pdev =
+		platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,
+					      PLATFORM_DEVID_AUTO,
+					      &codec_data, sizeof(codec_data));
+
+	return PTR_ERR_OR_ZERO(lt9611->audio_pdev);
+}
+
+static void lt9611_audio_exit(struct lt9611 *lt9611)
+{
+	if (lt9611->audio_pdev) {
+		platform_device_unregister(lt9611->audio_pdev);
+		lt9611->audio_pdev = NULL;
+	}
+}
+
+static int lt9611_probe(struct i2c_client *client)
+{
+	struct lt9611 *lt9611;
+	struct device *dev = &client->dev;
+	int ret;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "device doesn't support I2C\n");
+		return -ENODEV;
+	}
+
+	lt9611 = devm_kzalloc(dev, sizeof(*lt9611), GFP_KERNEL);
+	if (!lt9611)
+		return -ENOMEM;
+
+	lt9611->dev = &client->dev;
+	lt9611->client = client;
+	lt9611->sleep = false;
+
+	lt9611->regmap = devm_regmap_init_i2c(client, &lt9611_regmap_config);
+	if (IS_ERR(lt9611->regmap)) {
+		dev_err(lt9611->dev, "regmap i2c init failed\n");
+		return PTR_ERR(lt9611->regmap);
+	}
+
+	ret = lt9611_parse_dt(&client->dev, lt9611);
+	if (ret) {
+		dev_err(dev, "adlink failed to parse device tree: %d\n", ret);
+		return ret;
+	}
+/*
+	ret = lt9611_gpio_init(lt9611);
+	if (ret < 0)
+		goto err_of_put;
+
+	ret = lt9611_regulator_init(lt9611);
+	if (ret < 0)
+		goto err_of_put;
+
+	lt9611_assert_5v(lt9611);
+
+	ret = lt9611_regulator_enable(lt9611);
+	if (ret)
+		goto err_of_put;
+*/
+	lt9611_reset(lt9611);
+
+	ret = lt9611_read_device_rev(lt9611);
+	if (ret) {
+		dev_err(dev, "failed to read chip rev\n");
+		goto err_disable_regulators;
+	}
+
+	ret = devm_request_threaded_irq(dev, client->irq, NULL,
+					lt9611_irq_thread_handler,
+					IRQF_ONESHOT, "lt9611_irq", lt9611);
+	if (ret) {
+		dev_err(dev, "failed to request irq\n");
+		//goto err_disable_regulators;
+	}
+
+	i2c_set_clientdata(client, lt9611);
+
+	lt9611->bridge.funcs = &lt9611_bridge_funcs;
+	lt9611->bridge.of_node = client->dev.of_node;
+	lt9611->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID |
+			     DRM_BRIDGE_OP_HPD | DRM_BRIDGE_OP_MODES;
+	lt9611->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+
+	drm_bridge_add(&lt9611->bridge);
+
+	lt9611_enable_hpd_interrupts(lt9611);
+
+	return lt9611_audio_init(dev, lt9611);
+
+err_disable_regulators:
+	regulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);
+
+//err_of_put:
+	of_node_put(lt9611->dsi1_node);
+	of_node_put(lt9611->dsi0_node);
+
+	return ret;
+}
+static void lt9611_remove(struct i2c_client *client)
+{
+	struct lt9611 *lt9611 = i2c_get_clientdata(client);
+
+	disable_irq(client->irq);
+	lt9611_audio_exit(lt9611);
+	drm_bridge_remove(&lt9611->bridge);
+	
+	//cec_unregister_adapter(lt9611->cec_adap);
+	
+	regulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);
+
+	of_node_put(lt9611->dsi1_node);
+	of_node_put(lt9611->dsi0_node);
+}
+
+static struct i2c_device_id lt9611_id[] = {
+	{ "adlink,lt9611", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, lt9611_id);
+
+static const struct of_device_id lt9611_match_table[] = {
+	{ .compatible = "adlink,lt9611" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, lt9611_match_table);
+
+static struct i2c_driver lt9611_driver = {
+	.driver = {
+		.name = "adlink-lt9611",
+		.of_match_table = lt9611_match_table,
+	},
+	.probe = lt9611_probe,
+	.remove = lt9611_remove,
+	.id_table = lt9611_id,
+};
+module_i2c_driver(lt9611_driver);
+
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index fb8a57afe687..d11e812813b0 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -2490,6 +2490,31 @@ static const struct panel_desc innolux_zj070na_01p = {
 	},
 };
 
+static const struct drm_display_mode auo_g156hat026_mode = {
+	.clock = 141000,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 80,
+	.hsync_end = 1920 + 80 + 80,
+	.htotal = 1920 + 80 + 80 + 80,
+
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 8,
+	.vsync_end = 1080 + 8 + 20,
+	.vtotal = 1080 + 8 + 20 + 8,
+};
+
+static const struct panel_desc auo_g156hat026 = {
+	.modes = &auo_g156hat026_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 344,
+		.height = 194,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+	.connector_type = DRM_MODE_CONNECTOR_LVDS,
+};
+
 static const struct display_timing jdi_tx26d202vm0bwa_timing = {
 	.pixelclock = { 151820000, 156720000, 159780000 },
 	.hactive = { 1920, 1920, 1920 },
@@ -4232,6 +4257,9 @@ static const struct of_device_id platform_of_match[] = {
 	}, {
 		.compatible = "auo,g156xtn01",
 		.data = &auo_g156xtn01,
+	}, {
+		.compatible = "auo,g156hat026",
+		.data = &auo_g156hat026,
 	}, {
 		.compatible = "auo,g185han01",
 		.data = &auo_g185han01,
@@ -4682,6 +4710,34 @@ static const struct panel_desc_dsi auo_b080uan01 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode auo_g080uan02_mode = {
+	.clock = 154500,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 1,
+	.hsync_end = 1200 + 139 + 1,
+	.htotal = 1200 + 139 + 1 + 1,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 1,
+	.vsync_end = 1920 + 59 + 1,
+	.vtotal = 1920 + 59 + 1 + 1,
+};
+
+static const struct panel_desc_dsi auo_g080uan02 = {
+	.desc = {
+		.modes = &auo_g080uan02_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 107,
+			.height = 172,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct drm_display_mode boe_tv080wum_nl0_mode = {
 	.clock = 160000,
 	.hdisplay = 1200,
@@ -4860,6 +4916,9 @@ static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
 		.data = &auo_b080uan01
+	}, {
+		.compatible = "auo,g080uan02",
+		.data = &auo_g080uan02
 	}, {
 		.compatible = "boe,tv080wum-nl0",
 		.data = &boe_tv080wum_nl0
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 1e8141876073..0f4c210980d6 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -300,6 +300,16 @@ config VIDEO_OV08X40
 	  To compile this driver as a module, choose M here: the
 	  module will be called ov08x40.
 
+config VIDEO_OV13855
+       tristate "OmniVision OV13855 sensor support"
+       depends on VIDEO_V4L2_I2C && VIDEO_V4L2_SUBDEV_API
+       depends on MEDIA_CAMERA_SUPPORT
+       depends on GPIOLIB
+       select V4L2_FWNODE
+       help
+         This is a Video4Linux2 sensor driver for the OmniVision
+         OV13855 camera.
+
 config VIDEO_OV13858
 	tristate "OmniVision OV13858 sensor support"
 	help
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 04d29000427f..5c2fc8fa6fb3 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -78,6 +78,7 @@ obj-$(CONFIG_VIDEO_OV01A10) += ov01a10.o
 obj-$(CONFIG_VIDEO_OV02A10) += ov02a10.o
 obj-$(CONFIG_VIDEO_OV08D10) += ov08d10.o
 obj-$(CONFIG_VIDEO_OV08X40) += ov08x40.o
+obj-$(CONFIG_VIDEO_OV13855) += ov13855.o
 obj-$(CONFIG_VIDEO_OV13858) += ov13858.o
 obj-$(CONFIG_VIDEO_OV13B10) += ov13b10.o
 obj-$(CONFIG_VIDEO_OV2640) += ov2640.o
diff --git a/drivers/media/i2c/ov13855.c b/drivers/media/i2c/ov13855.c
new file mode 100644
index 000000000000..feb1c7d77b57
--- /dev/null
+++ b/drivers/media/i2c/ov13855.c
@@ -0,0 +1,2066 @@
+/*
+ * ov13855 sensor level driver
+ * This driver used to capture raw BGGR data
+ * 4 lanes, 2112x1568, 4224x3136
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+//#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/i2c.h>
+//#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/kobject.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <media/mipi-csi2.h>
+
+#define OV13855_XVCLK_FREQ		24000000
+
+#define CHIP_ID				0x00d855
+#define OV13855_REG_CHIP_ID		0x300a
+
+#define OV13855_REG_CTRL_MODE		0x0100
+#define OV13855_MODE_SW_STANDBY		0x0
+#define OV13855_MODE_STREAMING		BIT(0)
+
+#define OV13855_REG_EXPOSURE		0x3500
+#define	OV13855_EXPOSURE_MIN		4
+#define	OV13855_EXPOSURE_STEP		1
+#define OV13855_VTS_MAX			0x7fff
+
+#define OV13855_REG_TEST_PATTERN	0x4503
+#define ENABLE_TEST_PATTERN		0
+
+#define REG_NULL			0xFFFF
+
+#define OV13855_REG_VALUE_08BIT		1
+#define OV13855_REG_VALUE_16BIT		2
+#define OV13855_REG_VALUE_24BIT		3
+
+#define OV13855_LANES			4
+#define OV13855_BITS_PER_SAMPLE		10
+
+#define OF_CAMERA_PINCTRL_STATE_DEFAULT	"ov13855_camera_default"
+#define OF_CAMERA_PINCTRL_STATE_SLEEP	"ov13855_camera_sleep"
+
+#define OV13855_NAME			"ov13855"
+#define OV13855_VCHANNEL	0x4813
+
+#define OV13855_RES_HIGH_WIDTH		4096
+#define OV13855_RES_HIGH_HEIGHT		3136
+#define OV13855_RES_LOW_WIDTH		2112
+#define OV13855_RES_LOW_HEIGHT		1568
+
+#define DEFAULT_FPS	15
+
+#define OV13855_SENS_PAD_SOURCE	0
+#define OV13855_SENS_PADS_NUM	1
+
+/* Configurations for supported link frequencies */
+#define OV13858_NUM_OF_LINK_FREQS	2
+#define OV13858_LINK_FREQ_540MHZ	540000000ULL
+#define OV13858_LINK_FREQ_270MHZ	270000000ULL
+#define OV13858_LINK_FREQ_INDEX_0	0
+#define OV13858_LINK_FREQ_INDEX_1	1
+
+#define OV13858_VTS_MAX			0x7fff
+
+/*
+ * pixel_rate = link_freq * data-rate * nr_of_lanes / bits_per_sample
+ * data rate => double data rate; number of lanes => 4; bits per pixel => 10
+ */
+#if 0
+static u64 link_freq_to_pixel_rate(u64 f)
+{
+	f *= 2 * 4;
+	do_div(f, 10);
+
+	return f;
+}
+
+/* Menu items for LINK_FREQ V4L2 control */
+static const s64 link_freq_menu_items[OV13858_NUM_OF_LINK_FREQS] = {
+	OV13858_LINK_FREQ_540MHZ,
+	OV13858_LINK_FREQ_270MHZ
+};
+#endif
+
+static const struct regval *ov13855_regs;
+
+struct regval {
+	u16 addr;
+	u8 val;
+};
+
+struct ov13855_mode {
+	u32 width;
+	u32 height;
+	/* V-timing */
+	u32 vts_def;
+	u32 vts_min;
+	const struct regval *reg_list;
+};
+
+struct os08a20_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *link_freq;
+};
+
+struct ov13855 {
+	struct v4l2_subdev		subdev;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	const struct ov13855_datafmt	*fmt;
+	struct v4l2_captureparm streamcap;
+	bool on;
+
+	u32 mclk;
+	u8 mclk_source;
+	struct clk *sensor_clk;
+	int csi_vc;
+
+
+	struct gpio_desc *rst_gpio;
+	struct gpio_desc *pwn_gpio;
+	struct media_pad pads[OV13855_SENS_PADS_NUM];
+
+	bool streaming;
+	int mode;
+	struct mutex lock; /* sensor lock */
+	struct os08a20_ctrls ctrls;
+
+	/* V4L2 Controls */
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+};
+
+
+struct ov13855_datafmt {
+	u32	code;
+	enum v4l2_colorspace		colorspace;
+};
+
+static const struct ov13855_datafmt ov13855_colour_fmts[] = {
+	{MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_RAW},
+};
+
+
+#if 0
+static struct regval ov13855_1920x1080[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4f},
+	{0x3808, 0x07},//1920
+	{0x3809, 0x80},
+	{0x380a, 0x04},//1080
+	{0x380b, 0x38},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x06},
+	{0x380f, 0x48},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+	{REG_NULL, 0x00},
+};
+#endif
+static const struct regval ov13855_4096x3136[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0303, 0x00},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2A},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},//4096
+	{0x3809, 0x00},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x08},
+	{0x380c, 0x04},
+	{0x380d, 0xc4},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x10},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 3.3MP resolution*/
+static struct regval ov13855_2112x1568[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x40},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x10},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x28},
+	{0x371a, 0x3e},
+	{0x3737, 0x08},
+	{0x3738, 0xcc},
+	{0x3739, 0x20},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x14},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x08},
+	{0x37e4, 0x38},
+	{0x37e5, 0x03},
+	{0x37e6, 0x08},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x4f},
+	{0x3808, 0x08},
+	{0x3809, 0x40},
+	{0x380a, 0x06},
+	{0x380b, 0x20},
+	{0x380c, 0x04},
+	{0x380d, 0x62},
+	{0x380e, 0x06},
+	{0x380f, 0x48},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x03},
+	{0x3815, 0x01},
+	{0x3816, 0x03},
+	{0x3817, 0x01},
+	{0x3820, 0xab},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x04},
+	{0x3827, 0x90},
+	{0x3829, 0x07},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0d},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+	{REG_NULL, 0x00},
+};
+
+/*Init settings for 13MP resolution*/
+static const struct regval ov13855_4224x3136[] = {
+	{0x0103, 0x01},
+	{0x0300, 0x02},
+	{0x0301, 0x00},
+	{0x0302, 0x5a},
+	{0x0303, 0x01},
+	{0x0303, 0x00},
+	{0x0304, 0x00},
+	{0x0305, 0x01},
+	{0x030b, 0x06},
+	{0x030c, 0x02},
+	{0x030d, 0x88},
+	{0x0312, 0x11},
+	{0x3022, 0x41},
+	{0x3012, 0x40},
+	{0x3013, 0x72},
+	{0x3016, 0x72},
+	{0x301b, 0xF0},
+	{0x301f, 0xd0},
+	{0x3106, 0x15},
+	{0x3107, 0x23},
+	{0x3500, 0x00},
+	{0x3501, 0x80},
+	{0x3502, 0x00},
+	{0x3508, 0x02},
+	{0x3509, 0x00},
+	{0x350a, 0x00},
+	{0x350e, 0x00},
+	{0x3510, 0x00},
+	{0x3511, 0x02},
+	{0x3512, 0x00},
+	{0x3600, 0x2b},
+	{0x3601, 0x52},
+	{0x3602, 0x60},
+	{0x3612, 0x05},
+	{0x3613, 0xa4},
+	{0x3620, 0x80},
+	{0x3621, 0x10},
+	{0x3622, 0x30},
+	{0x3624, 0x1c},
+	{0x3640, 0x10},
+	{0x3641, 0x70},
+	{0x3660, 0x04},
+	{0x3661, 0x80},
+	{0x3662, 0x12},
+	{0x3664, 0x73},
+	{0x3665, 0xa7},
+	{0x366e, 0xff},
+	{0x366f, 0xf4},
+	{0x3674, 0x00},
+	{0x3679, 0x0c},
+	{0x367f, 0x01},
+	{0x3680, 0x0c},
+	{0x3681, 0x50},
+	{0x3682, 0x50},
+	{0x3683, 0xa9},
+	{0x3684, 0xa9},
+	{0x3706, 0x40},
+	{0x3709, 0x5f},
+	{0x3714, 0x24},
+	{0x371a, 0x3e},
+	{0x3737, 0x04},
+	{0x3738, 0xcc},
+	{0x3739, 0x12},
+	{0x373d, 0x26},
+	{0x3764, 0x20},
+	{0x3765, 0x20},
+	{0x37a1, 0x36},
+	{0x37a8, 0x3b},
+	{0x37ab, 0x31},
+	{0x37c2, 0x04},
+	{0x37c3, 0xf1},
+	{0x37c5, 0x00},
+	{0x37d8, 0x03},
+	{0x37d9, 0x0c},
+	{0x37da, 0xc2},
+	{0x37dc, 0x02},
+	{0x37e0, 0x00},
+	{0x37e1, 0x0a},
+	{0x37e2, 0x14},
+	{0x37e3, 0x04},
+	{0x37e4, 0x2A},
+	{0x37e5, 0x03},
+	{0x37e6, 0x04},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x08},
+	{0x3804, 0x10},
+	{0x3805, 0x9f},
+	{0x3806, 0x0c},
+	{0x3807, 0x57},
+	{0x3808, 0x10},
+	{0x3809, 0x80},
+	{0x380a, 0x0c},
+	{0x380b, 0x40},
+	{0x380c, 0x08},
+	{0x380c, 0x04},
+	{0x380d, 0xc4},
+	{0x380d, 0x62},
+	{0x380e, 0x0c},
+	{0x380f, 0x8e},
+	{0x3811, 0x10},
+	{0x3813, 0x08},
+	{0x3814, 0x01},
+	{0x3815, 0x01},
+	{0x3816, 0x01},
+	{0x3817, 0x01},
+	{0x3820, 0xa8},
+	{0x3821, 0x00},
+	{0x3822, 0xc2},
+	{0x3823, 0x18},
+	{0x3826, 0x11},
+	{0x3827, 0x1c},
+	{0x3829, 0x03},
+	{0x3832, 0x00},
+	{0x3c80, 0x00},
+	{0x3c87, 0x01},
+	{0x3c8c, 0x19},
+	{0x3c8d, 0x1c},
+	{0x3c90, 0x00},
+	{0x3c91, 0x00},
+	{0x3c92, 0x00},
+	{0x3c93, 0x00},
+	{0x3c94, 0x40},
+	{0x3c95, 0x54},
+	{0x3c96, 0x34},
+	{0x3c97, 0x04},
+	{0x3c98, 0x00},
+	{0x3d8c, 0x73},
+	{0x3d8d, 0xc0},
+	{0x3f00, 0x0b},
+	{0x3f03, 0x00},
+	{0x4001, 0xe0},
+	{0x4008, 0x00},
+	{0x4009, 0x0f},
+	{0x4011, 0xf0},
+	{0x4017, 0x08},
+	{0x4050, 0x04},
+	{0x4051, 0x0b},
+	{0x4052, 0x00},
+	{0x4053, 0x80},
+	{0x4054, 0x00},
+	{0x4055, 0x80},
+	{0x4056, 0x00},
+	{0x4057, 0x80},
+	{0x4058, 0x00},
+	{0x4059, 0x80},
+	{0x405e, 0x00},
+	{0x4500, 0x07},
+	{0x4503, 0x00},
+	{0x450a, 0x04},
+	{0x4800, 0x60},
+	{0x4809, 0x04},
+	{0x480c, 0x12},
+	{0x481f, 0x30},
+	{0x4833, 0x10},
+	{0x4837, 0x1c},
+	{0x4837, 0x0e},
+	{0x4902, 0x01},
+	{0x4d00, 0x03},
+	{0x4d01, 0xc9},
+	{0x4d02, 0xbc},
+	{0x4d03, 0xd7},
+	{0x4d04, 0xf0},
+	{0x4d05, 0xa2},
+	{0x5000, 0xff},
+	{0x5001, 0x07},
+	{0x5040, 0x39},
+	{0x5041, 0x10},
+	{0x5042, 0x10},
+	{0x5043, 0x84},
+	{0x5044, 0x62},
+	{0x5180, 0x00},
+	{0x5181, 0x10},
+	{0x5182, 0x02},
+	{0x5183, 0x0f},
+	{0x5200, 0x1b},
+	{0x520b, 0x07},
+	{0x520c, 0x0f},
+	{0x5300, 0x04},
+	{0x5301, 0x0C},
+	{0x5302, 0x0C},
+	{0x5303, 0x0f},
+	{0x5304, 0x00},
+	{0x5305, 0x70},
+	{0x5306, 0x00},
+	{0x5307, 0x80},
+	{0x5308, 0x00},
+	{0x5309, 0xa5},
+	{0x530a, 0x00},
+	{0x530b, 0xd3},
+	{0x530c, 0x00},
+	{0x530d, 0xf0},
+	{0x530e, 0x01},
+	{0x530f, 0x10},
+	{0x5310, 0x01},
+	{0x5311, 0x20},
+	{0x5312, 0x01},
+	{0x5313, 0x20},
+	{0x5314, 0x01},
+	{0x5315, 0x20},
+	{0x5316, 0x08},
+	{0x5317, 0x08},
+	{0x5318, 0x10},
+	{0x5319, 0x88},
+	{0x531a, 0x88},
+	{0x531b, 0xa9},
+	{0x531c, 0xaa},
+	{0x531d, 0x0a},
+	{0x5405, 0x02},
+	{0x5406, 0x67},
+	{0x5407, 0x01},
+	{0x5408, 0x4a},
+
+	{REG_NULL, 0x00},
+};
+
+static const struct ov13855_mode supported_modes[] = {
+	{
+		.width = 2112,
+		.height = 1568,
+		.reg_list = ov13855_2112x1568,
+	},{
+		.width = 4096,
+		.height = 3136,
+		.reg_list = ov13855_4096x3136,
+	},
+};
+
+#ifdef OV13855_SYS_DEBUG
+
+#define MAXENTRIES 20
+
+struct kobject *kobj_ov13855;
+int sysregaddr = 0, sysregvalue = 0, countreg=0;
+struct regval dumpvalues[MAXENTRIES+2];
+
+static ssize_t  sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+static ssize_t  sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf);
+static ssize_t  sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count);
+
+struct kobj_attribute ov13855_reg_write = __ATTR(sysregaddr, 0660, sysfs_reg_show, sysfs_reg_store);
+struct kobj_attribute ov13855_regvalue_write = __ATTR(sysregvalue, 0660, sysfs_regvalue_show, sysfs_regvalue_store);
+
+static ssize_t sysfs_regvalue_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("ov13855 sysfs read\n");
+	return sprintf(buf, "%x", sysregvalue);
+}
+
+static ssize_t sysfs_regvalue_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	int i=0, flag = 1;
+
+	pr_info("ov13855 sysfs write\n");
+	sscanf(buf,"%x",&sysregvalue);
+
+	if(countreg < MAXENTRIES) {
+		dumpvalues[countreg].addr = sysregaddr;
+		dumpvalues[countreg].val = sysregvalue;
+		countreg++;
+	}
+
+	return count;
+}
+
+
+static ssize_t sysfs_reg_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	pr_info("Sysfs - Read!!!\n");
+	return sprintf(buf, "%x", sysregaddr);
+}
+
+static ssize_t sysfs_reg_store(struct kobject *kobj,
+		struct kobj_attribute *attr,const char *buf, size_t count)
+{
+	pr_info("Sysfs - reg Write!!!\n");
+	sscanf(buf,"%x",&sysregaddr);
+	return count;
+}
+
+#endif
+
+/* Write registers up to 4 at a time */
+static int ov13855_write_reg(struct i2c_client *client, u16 reg,
+			     u32 len, u32 val)
+{
+	u32 buf_i, val_i;
+	u8 buf[6];
+	u8 *val_p;
+	__be32 val_be;
+//printk("jimmy ov13855_write_reg reg:0x%x\n",reg);
+	if (len > 4)
+		return -EINVAL;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	val_be = cpu_to_be32(val);
+	val_p = (u8 *)&val_be;
+	buf_i = 2;
+	val_i = 4 - len;
+
+	while (val_i < 4)
+		buf[buf_i++] = val_p[val_i++];
+
+
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+	{
+		printk("jimmy ov13855_write_reg failed reg:0x%x\n",reg);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int ov13855_write_array(struct i2c_client *client,
+			       const struct regval *regs)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
+		ret = ov13855_write_reg(client, regs[i].addr,
+					OV13855_REG_VALUE_08BIT,
+					regs[i].val);
+
+	return ret;
+}
+
+/* Read registers up to 4 at a time */
+static int ov13855_read_reg(struct i2c_client *client, u16 reg,
+			    unsigned int len, u32 *val)
+{
+	struct i2c_msg msgs[2];
+	u8 *data_be_p;
+	__be32 data_be = 0;
+	__be16 reg_addr_be = cpu_to_be16(reg);
+	int ret;
+printk("jimmy ov13855_read_reg reg:0x%x\n",reg);
+	if (len > 4 || !len)
+		return -EINVAL;
+
+	data_be_p = (u8 *)&data_be;
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (u8 *)&reg_addr_be;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_be_p[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+	{
+		printk("jimmy ov13855_read_reg reg:0x%x failed\n",reg);
+		return -EIO;
+	}
+	*val = be32_to_cpu(data_be);
+
+	return 0;
+}
+
+static struct ov13855 *to_ov13855(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov13855, subdev);
+}
+
+/*@ov13855_enable_test_pattern - This enables the test pattern
+   Valid values for pattern are 1 - 4
+ Return value - 0 on success, negative on failure*/
+static int ov13855_enable_test_pattern(struct i2c_client *client, u32 pattern)
+{
+	u32 val;
+	val = (pattern - 1) | 0x80;
+
+	return ov13855_write_reg(client,
+				 OV13855_REG_TEST_PATTERN,
+				 OV13855_REG_VALUE_08BIT,
+				 val);
+}
+
+/*@ov13855_start_stream - writing mode register settings
+ and streaming register
+ Return value - 0 on success, negative on failure*/
+
+static int ov13855_start_stream(struct i2c_client *client)
+{
+	int ret = 0;
+	struct ov13855 *sensor = to_ov13855(client);
+	//const struct regval *reg_list = supported_modes[sensor->mode].reg_list;
+printk("jimmy ov13855_start_stream +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	if(sensor->streaming)
+	{
+		pr_debug("OV13855: Already streaming \n");
+		return ret;
+	}
+	/*
+msleep(100);
+printk("jimmy ov13855_start_stream OV13855_MODE_STREAMING msleep 100\n");
+*/
+	ret = ov13855_write_reg(client,
+				 OV13855_REG_CTRL_MODE,
+				 OV13855_REG_VALUE_08BIT,
+				 OV13855_MODE_STREAMING);
+	if(!ret)
+	{
+		printk("jimmy ov13855_start_stream a\n");
+		pr_debug("%s: streaming started \n", __func__);
+		sensor->streaming = 1;
+		msleep(100);
+	}
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	printk("jimmy ov13855_start_stream - ret:0x%x\n",ret);
+	return ret;
+}
+
+static int ov13855_stop_stream(struct i2c_client *client)
+{
+	struct ov13855 *sensor = to_ov13855(client);
+	int ret = 0;
+
+	if(!sensor->streaming) {
+		return ret;
+	}
+	/*
+msleep(100);
+printk("jimmy ov13855_stop_stream OV13855_MODE_SW_STANDBY msleep 100\n");
+	ret = ov13855_write_reg(client,
+				 OV13855_REG_CTRL_MODE,
+				 OV13855_REG_VALUE_08BIT,
+				 OV13855_MODE_SW_STANDBY);
+	if(!ret)
+	*/
+	{
+		pr_debug("%s: streaming stopped fake\n", __func__);
+		sensor->streaming = 0;
+	}
+	return ret;
+
+}
+
+/* Calculate the delay in us by clock rate and clock cycles */
+static inline u32 ov13855_cal_delay(u32 cycles)
+{
+        return DIV_ROUND_UP(cycles, OV13855_XVCLK_FREQ / 1000 / 1000);
+}
+
+/*@ov13855_power_on - Control reset and power down lines */
+//static void ov13855_power_on(int rst_gpio, int pwn_gpio)
+static void ov13855_power_on(struct ov13855 *sensor)
+{
+	u32 delay_us;
+printk("jimmy ov13855_power_on \n");
+
+printk("jimmy ov13855_power_on  pwn_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 0);
+
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  rst_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 1);
+
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  pwn_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 1);
+	usleep_range(3000, 5000);
+printk("jimmy ov13855_power_on  rst_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 0);
+	usleep_range(3000, 5000);
+
+	/* 8192 cycles prior to first SCCB transaction */
+        delay_us = ov13855_cal_delay(8192);
+        usleep_range(delay_us, delay_us * 2);
+
+}
+
+//static void ov13855_power_off(int rst_gpio, int pwn_gpio)
+static void ov13855_power_off(struct ov13855 *sensor)
+{
+	printk("jimmy ov13855_power_off\n");
+	
+	msleep(10);
+	printk("jimmy ov13855_power_off  rst_gpio 1\n");
+	gpiod_set_value_cansleep(sensor->rst_gpio, 1);
+	usleep_range(3000, 5000);
+	printk("jimmy ov13855_power_off  pwn_gpio 0\n");
+	gpiod_set_value_cansleep(sensor->pwn_gpio, 0);
+	usleep_range(3000, 5000);
+	
+}
+
+static int ov13855_check_sensor_id(struct i2c_client *client)
+{
+	u32 id = 0;
+	int ret;
+
+	ret = ov13855_read_reg(client, OV13855_REG_CHIP_ID,
+			       OV13855_REG_VALUE_24BIT, &id);
+	printk(KERN_ALERT "OV13855, register 0x300A: 0x%x\n", id);
+	if (id != CHIP_ID) {
+		pr_err("Unexpected sensor id(%06x), ret(%d)\n", id, ret);
+		return -ENODEV;
+	}
+
+	ov13855_regs = ov13855_2112x1568;
+	pr_info("Detected OV13855: %06x sensor\n", CHIP_ID);
+
+	return 0;
+}
+
+
+
+static int ov13855_write_init_settings(struct i2c_client *client,
+					const struct regval *settings)
+{
+	int retval = 0;
+
+	retval = ov13855_write_array(client, settings);
+	if (retval) {
+		pr_err("OV13855 global settings failed !\n");
+		return retval;
+	}
+	msleep(5);
+	return retval;
+}
+
+static int ov13855_enum_framesizes(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state,
+			       struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	printk("jimmy ov13855_enum_framesizes : %d \n", fse->index);
+	if (fse->index > 1)
+                return -EINVAL;
+	fse->max_width = supported_modes[fse->index].width;
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_height = supported_modes[fse->index].height;
+	fse->min_height = supported_modes[fse->index].height;
+	return 0;
+}
+
+static int ov13855_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+printk("jimmy ov13855_get_fmt +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	memset(mf, 0, sizeof(struct v4l2_mbus_framefmt));
+printk("jimmy ov13855_get_fmt org code:0x%x colorspace:0x%x\n",mf->code,mf->colorspace);
+	mf->code = ov13855_colour_fmts[0].code;
+	mf->colorspace = ov13855_colour_fmts[0].colorspace;
+	printk("jimmy ov13855_get_fmt new code:0x%x colorspace:0x%x\n",mf->code,mf->colorspace);
+printk("jimmy ov13855_get_fmt pixelformat:0x%x\n",sensor->pix.pixelformat);
+	 
+	mf->width = sensor->pix.width;
+	mf->height = sensor->pix.height;
+	mf->field = V4L2_FIELD_NONE;
+printk("jimmy ov13855_get_fmt -\n");
+	return 0;
+}
+
+static int ov13855_sensor_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+ printk("jimmy ov13855_sensor_suspend ov13855_power_off\n");
+	clk_disable_unprepare(sensor->sensor_clk);
+	ov13855_power_off(sensor);
+	return 0;
+}
+
+static int  ov13855_sensor_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+ printk("jimmy ov13855_sensor_resume ov13855_power_on\n");
+ 	clk_prepare_enable(sensor->sensor_clk);
+	ov13855_power_on(sensor);
+
+	return 0;
+ }
+/*
+static int ov13855_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+
+	pr_debug("%s: %d\n", __func__, on);
+	if (on) {
+		clk_prepare_enable(sensor->sensor_clk);
+		ov13855_power_on(sensor->rst_gpio, sensor->pwn_gpio);
+	} else if (!on) {
+		clk_disable_unprepare(sensor->sensor_clk);
+		ov13855_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+	}
+
+	return 0;
+}
+*/
+
+static int ov13855_enum_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	printk("jimmy ov13855_enum_code +\n");
+	if (code->pad || code->index >= ARRAY_SIZE(ov13855_colour_fmts))
+		return -EINVAL;
+
+	code->code = ov13855_colour_fmts[code->index].code;
+	return 0;
+}
+
+static int ov13855_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_subdev_state *sd_state,
+		struct v4l2_subdev_frame_interval_enum *fival)
+{
+	printk("jimmy ov13855_enum_frameintervals +\n");
+	if(fival->index > 2)
+		return -EINVAL;
+	fival->interval.numerator = 1;
+	fival->interval.denominator = DEFAULT_FPS;
+
+	return 0;
+}
+
+#if 0
+static int ov13855_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+	int ret = 0;
+printk("jimmy ov13855_g_parm +\n");
+	pr_debug("%s: %d\n", __func__, __LINE__);
+	switch (a->type) {
+	/*Need to verify below settings further*/
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		memset(a, 0, sizeof(*a));
+		a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cparm->capability = sensor->streamcap.capability;
+		cparm->timeperframe = sensor->streamcap.timeperframe;
+		cparm->capturemode = sensor->streamcap.capturemode;
+		ret = 0;
+		break;
+	/*These cases not applicable now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		printk("jimmy ov13855_g_parm type is unknown\n");
+		ret = -EINVAL;
+		break;
+	}
+printk("jimmy ov13855_g_parm -\n");
+	return ret;
+}
+
+static int ov13855_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+printk("jimmy ov13855_s_parm +\n");
+	switch (a->type) {
+	/* This is the only case currently handled. */
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	/*Need to set fps as per request */
+		pr_debug("%s: %d\n", __func__, __LINE__);
+		sensor->streamcap.timeperframe = *timeperframe;
+		sensor->streamcap.capturemode =
+				(u32)a->parm.capture.capturemode;
+		break;
+	/* These cases not applicable for now*/
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		pr_debug("   type is not " \
+			"V4L2_BUF_TYPE_VIDEO_CAPTURE but %d\n",
+			a->type);
+			printk("jimmy ov13855_s_parm a\n");
+		ret = -EINVAL;
+		break;
+
+	default:
+		pr_debug("   type is unknown - %d\n", a->type);
+		printk("jimmy ov13855_s_parm b\n");
+		ret = -EINVAL;
+		break;
+	}
+printk("jimmy ov13855_s_parm -\n");
+	return ret;
+}
+#endif
+
+static int os08a20_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops os08a20_ctrl_ops = {
+	.s_ctrl = os08a20_s_ctrl,
+};
+
+/*
+ * MIPI CSI-2 link frequencies.
+ * link_freq = (pixel_rate * bpp) / (2 * data_lanes)
+ */
+static const s64 os08a20_csi2_link_freqs[] = {
+	//540000000, //for 4k
+	270000000,
+};
+
+/* Link freq for default mode: 1080p RAW10, 4 data lanes 800 Mbps/lane. */
+#define OS08A20_DEFAULT_LINK_FREQ	0
+
+static int os08a20_init_controls(struct ov13855 *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &os08a20_ctrl_ops;
+	struct os08a20_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+#if 0	
+	s64 vblank_def;
+	s64 vblank_min;
+	s64 hblank;
+	s64 pixel_rate_min;
+	s64 pixel_rate_max;
+	const struct ov13855_mode *mode;
+#endif
+	v4l2_ctrl_handler_init(hdl, 5);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops,
+					V4L2_CID_LINK_FREQ,
+					ARRAY_SIZE(os08a20_csi2_link_freqs) - 1,
+					OS08A20_DEFAULT_LINK_FREQ,
+					os08a20_csi2_link_freqs);
+#if 0
+	pixel_rate_max = link_freq_to_pixel_rate(link_freq_menu_items[0]);
+	pixel_rate_min = link_freq_to_pixel_rate(link_freq_menu_items[1]);
+	/* By default, PIXEL_RATE is read only */
+	sensor->pixel_rate = v4l2_ctrl_new_std(hdl, &os08a20_ctrl_ops,
+						V4L2_CID_PIXEL_RATE,
+						pixel_rate_min, pixel_rate_max,
+						1, pixel_rate_max);
+
+	mode = &supported_modes[0]; //sensor->mode;
+	vblank_def = mode->vts_def - mode->height;
+	vblank_min = mode->vts_min - mode->height;
+	sensor->vblank = v4l2_ctrl_new_std(
+				hdl, &os08a20_ctrl_ops, V4L2_CID_VBLANK,
+				vblank_min, OV13858_VTS_MAX - mode->height, 1,
+				vblank_def);
+
+	hblank =  20; //link_freq_configs[mode->link_freq_index].pixels_per_line - mode->width;
+	sensor->hblank = v4l2_ctrl_new_std(
+				hdl, &os08a20_ctrl_ops, V4L2_CID_HBLANK,
+				hblank, hblank, 1, hblank);
+#endif
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	sensor->subdev.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+#if 0
+static int ov13855_s_stream_(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	//struct ov13855 *sensor = to_ov13855(client);
+	int retval;
+printk("jimmy ov13855_s_stream_ %d \n",enable);
+
+	if (enable) {
+		
+		retval = pm_runtime_resume_and_get(&client->dev);
+		if (retval < 0)
+			return retval;
+/*
+		retval = ov13855_start_stream(client);
+		if (retval) {
+			pr_err("OV13855 start stream failed !\n");
+			return retval;
+		}
+		*/
+
+	}
+	else {
+		/*
+		retval = ov13855_stop_stream(client);
+		if (retval) {
+			pr_err("OV13855 stop stream failed !\n");
+			return retval;
+		}
+		*/
+	}
+
+	return 0;
+}
+#endif
+
+static int ov13855_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	int retval;
+printk("jimmy ov13855_s_stream  + enable:%d \n",enable);
+	pr_info("s_stream: %d\n", enable);
+	if (enable) {
+		retval = pm_runtime_resume_and_get(&client->dev);
+		if (retval < 0)
+			return retval;
+	/*if valid pattern value then enable test pattern, else go for
+	 * normal streaming. Change ENABLE_TEST_PATTERN with value 1
+	 * to 4 to enable test pattern */
+		if(ENABLE_TEST_PATTERN > 0 && ENABLE_TEST_PATTERN <= 4)
+			ov13855_enable_test_pattern(client,
+						ENABLE_TEST_PATTERN);
+		retval = ov13855_start_stream(client);
+		if (retval) {
+			pr_err("OV13855 start stream failed !\n");
+			return retval;
+		}
+		retval = ov13855_write_reg(client, OV13855_VCHANNEL,
+					OV13855_REG_VALUE_08BIT, sensor->csi_vc);
+		if(retval) {
+			pr_err("%s: set virtual channel failed\n", __func__);
+			return retval;
+		}
+
+	}
+	else {
+		retval = ov13855_stop_stream(client);
+		if (retval) {
+			pr_err("OV13855 stop stream failed !\n");
+			return retval;
+		}
+	}
+printk("jimmy ov13855_s_stream  -\n");
+	return 0;
+}
+
+static int ov13855_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *format)
+{
+	int retval = 0; //, ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+	//int i = 0;
+printk("jimmy ov13855_set_fmt +\n");
+	if(format->format.width == OV13855_RES_HIGH_WIDTH &&
+		format->format.height == OV13855_RES_HIGH_HEIGHT)
+	{
+		printk("jimmy ov13855_set_fmt ov13855_4096x3136\n");
+		sensor->mode = 1;
+		ov13855_regs = ov13855_4096x3136;
+		sensor->pix.width = OV13855_RES_HIGH_WIDTH;
+		sensor->pix.height = OV13855_RES_HIGH_HEIGHT;
+	}
+	else if(format->format.width == OV13855_RES_LOW_WIDTH &&
+		format->format.height == OV13855_RES_LOW_HEIGHT)
+	{
+		printk("jimmy ov13855_set_fmt ov13855_2112x1568\n");
+		sensor->mode = 0;
+		ov13855_regs = ov13855_2112x1568;
+		sensor->pix.width = OV13855_RES_LOW_WIDTH;
+		sensor->pix.height = OV13855_RES_LOW_HEIGHT;
+	}
+	else
+	{
+		printk("jimmy ov13855_set_fmt Unsupported\n");
+		printk(KERN_INFO "OV13855: Unsupported resolution passed\n");
+		return -1;
+	}
+	clk_prepare_enable(sensor->sensor_clk);
+	ov13855_power_on(sensor);
+	//pm_runtime_get_noresume(&sensor->i2c_client->dev);
+	pm_runtime_resume_and_get(&sensor->i2c_client->dev);
+//	ov13855_s_stream_(sd,1);
+
+	retval = ov13855_write_init_settings(client, ov13855_regs);
+
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
+#ifdef OV13855_SYS_DEBUG
+	printk(KERN_INFO "OV13855 sysfs reg dump\n");
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+
+	printk(KERN_INFO "countreg size: 0x%x\n", countreg);
+	for(; dumpvalues[i].addr != REG_NULL; i++)
+	{
+		printk(KERN_INFO "addr: 0x%x, val: 0x%x\n", dumpvalues[i].addr,
+				dumpvalues[i].val);
+	}
+
+	ret = ov13855_write_array(client, dumpvalues);
+        if(ret)
+        {
+		printk(KERN_INFO "failed to write sysfs reg\n");
+        }
+#endif
+printk("jimmy ov13855_set_fmt - %d\n",retval);
+	return retval;
+}
+
+
+static int ov13855_link_setup(struct media_entity *entity,
+                           const struct media_pad *local,
+                           const struct media_pad *remote, u32 flags)
+{
+        return 0;
+}
+
+static struct v4l2_subdev_video_ops ov13855_subdev_video_ops = {
+	//.g_parm = ov13855_g_parm,
+	//.s_parm = ov13855_s_parm,
+	.s_stream = ov13855_s_stream,
+};
+
+
+static int ov13855_get_frame_desc(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_mbus_frame_desc *fd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov13855 *sensor = to_ov13855(client);
+
+	fd->type = V4L2_MBUS_FRAME_DESC_TYPE_CSI2;
+	fd->num_entries = 1;
+
+	/* get sensor current code*/
+	mutex_lock(&sensor->lock);
+	fd->entry[0].pixelcode = MEDIA_BUS_FMT_SBGGR8_1X8;
+	mutex_unlock(&sensor->lock);
+
+	fd->entry[0].bus.csi2.vc = 0;
+	fd->entry[0].bus.csi2.dt = MIPI_CSI2_DT_RAW8;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ov13855_subdev_pad_ops = {
+	.enum_frame_size       = ov13855_enum_framesizes,
+	.enum_frame_interval   = ov13855_enum_frameintervals,
+	.enum_mbus_code        = ov13855_enum_code,
+	.set_fmt               = ov13855_set_fmt,
+	.get_fmt               = ov13855_get_fmt,
+	.get_frame_desc			= ov13855_get_frame_desc,
+};
+
+static struct v4l2_subdev_core_ops ov13855_subdev_core_ops = {
+//	.s_power	= ov13855_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static struct v4l2_subdev_ops ov13855_subdev_ops = {
+	.core	= &ov13855_subdev_core_ops,
+	.video	= &ov13855_subdev_video_ops,
+	.pad	= &ov13855_subdev_pad_ops,
+};
+
+static const struct media_entity_operations ov13855_sd_media_ops = {
+	.link_setup = ov13855_link_setup,
+};
+
+static int ov13855_probe(struct i2c_client *client)
+{
+	struct pinctrl *pinctrl;
+	struct device *dev = &client->dev;
+	struct v4l2_subdev *sd;
+	int ret ;
+	//int rst_gpio, pwn_gpio;
+	struct ov13855 *sensor;
+printk("jimmy ov13855_probe + \n");
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+
+	pr_info("OV13855: ov13855_probe called\n");
+
+	pinctrl = devm_pinctrl_get_select_default(dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(dev, "No pin available\n");
+
+	sensor->mode = 0;
+	sensor->streaming = 0;
+
+
+	/* request optional power down pin */
+	sensor->pwn_gpio = devm_gpiod_get_optional(dev, "pwn",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwn_gpio))
+		return PTR_ERR(sensor->pwn_gpio);
+
+	/* request optional reset pin */
+	sensor->rst_gpio = devm_gpiod_get_optional(dev, "rst",
+						     GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->rst_gpio))
+		return PTR_ERR(sensor->rst_gpio);
+
+/*
+	rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+	if (!gpio_is_valid(rst_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, rst_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13855_reset");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->rst_gpio = rst_gpio;
+
+	pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+	if (!gpio_is_valid(pwn_gpio)) {
+		dev_err(dev, "no sensor reset pin available");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, pwn_gpio, GPIOF_OUT_INIT_LOW,
+					"ov13855_pwdn");
+	if (ret < 0) {
+		dev_err(dev, "failed to acquire sensor reset pin");
+		return ret;
+	}
+	sensor->pwn_gpio = pwn_gpio;
+*/
+	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
+	if (IS_ERR(sensor->sensor_clk)) {
+                sensor->sensor_clk = NULL;
+                dev_err(dev, "clock-frequency missing or invalid\n");
+                return PTR_ERR(sensor->sensor_clk);
+        }
+
+	ret = of_property_read_u32(dev->of_node, "mclk",
+					&(sensor->mclk));
+	if (ret) {
+		dev_err(dev, "mclk missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "mclk_source",
+					(u32 *) &(sensor->mclk_source));
+	if (ret) {
+		dev_err(dev, "mclk_source missing or invalid\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "virtual_channel",
+					&(sensor->csi_vc));
+	if (ret) {
+		dev_err(dev, "csi id missing or invalid\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sensor->sensor_clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	sensor->i2c_client = client;
+
+	/*Only can handle 8bit mode for now*/
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	sensor->pix.width = OV13855_RES_LOW_WIDTH;
+        sensor->pix.height = OV13855_RES_LOW_HEIGHT;
+	sensor->streamcap.capability = V4L2_MODE_HIGHQUALITY |
+                                           V4L2_CAP_TIMEPERFRAME;
+        sensor->streamcap.capturemode = 0;
+        sensor->streamcap.timeperframe.denominator = DEFAULT_FPS;
+        sensor->streamcap.timeperframe.numerator = 1;
+		//printk("jimmy ov13855_probe usleep 3000000\n");
+//usleep_range(3000000, 5000000);
+printk("jimmy ov13855_probe ov13855_power_on\n");
+	mutex_init(&sensor->lock);
+
+	if (os08a20_init_controls(sensor))
+	{
+		clk_disable_unprepare(sensor->sensor_clk);
+		goto err_free_handler;
+	}
+	ov13855_power_on(sensor);
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+
+	ret = ov13855_check_sensor_id(client);
+	if (ret)
+	{
+		dev_err(dev, "ov13855 mipi not found\n");
+		clk_disable_unprepare(sensor->sensor_clk);
+		goto err_free_handler;
+	}
+
+	sd = &sensor->subdev;
+	v4l2_i2c_subdev_init(sd, client, &ov13855_subdev_ops);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pads[OV13855_SENS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, OV13855_SENS_PADS_NUM,
+							sensor->pads);
+	sd->entity.ops = &ov13855_sd_media_ops;
+	if (ret < 0)
+		return ret;
+
+	//ret = v4l2_async_register_subdev(sd);
+	ret = v4l2_async_register_subdev_sensor(sd);
+	if (ret < 0) {
+		dev_err(&client->dev,
+				"%s--Async register failed, ret=%d\n", __func__, ret);
+		media_entity_cleanup(&sd->entity);
+
+		goto err_pm_runtime;
+	}
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_put_autosuspend(dev);
+
+    //clk_disable_unprepare(sensor->sensor_clk);
+	//ov13855_power_off(sensor->rst_gpio, sensor->pwn_gpio);
+
+#ifdef OV13855_SYS_DEBUG
+	kobj_ov13855 = kobject_create_and_add("ov13855_debug", kernel_kobj);
+
+	/*Creating sysfs file for ov13855 register write*/
+	if(sysfs_create_file(kobj_ov13855, &ov13855_reg_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ov13855);
+		sysfs_remove_file(kernel_kobj, &ov13855_reg_write.attr);
+	}
+
+	if(sysfs_create_file(kobj_ov13855, &ov13855_regvalue_write.attr)) {
+		pr_err("Cannot create sysfs file......\n");
+		kobject_put(kobj_ov13855);
+		sysfs_remove_file(kernel_kobj, &ov13855_regvalue_write.attr);
+	}
+	dumpvalues[countreg].addr = REG_NULL;
+	dumpvalues[countreg].val = 0;
+#endif
+
+	pr_info("OV13855: ov13855_probe successful\n");
+
+	return 0;
+
+err_pm_runtime:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+
+
+err_free_handler:
+
+	return ret;
+}
+
+static void ov13855_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13855 *sensor = to_ov13855(client);
+	struct device *dev = &client->dev;
+
+	pm_runtime_disable(dev);
+	if (!pm_runtime_status_suspended(dev))
+		ov13855_sensor_suspend(dev);
+	pm_runtime_set_suspended(dev);
+
+
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+
+	ov13855_power_off(sensor);
+	v4l2_async_unregister_subdev(sd);
+
+	clk_disable_unprepare(sensor->sensor_clk);
+	mutex_destroy(&sensor->lock);
+}
+
+static const struct dev_pm_ops ov13855_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov13855_sensor_suspend, ov13855_sensor_resume, NULL)
+};
+
+static const struct i2c_device_id ov13855_match_id[] = {
+        { "ov13855_mipi", 0 },
+        { },
+};
+
+static struct i2c_driver ov13855_i2c_driver = {
+        .driver = {
+                .name = OV13855_NAME,
+                //.of_match_table = of_match_ptr(ov13855_of_match),
+				.pm = &ov13855_pm_ops,
+        },
+        .probe          = ov13855_probe,
+        .remove         = ov13855_remove,
+        .id_table       = ov13855_match_id,
+};
+
+module_i2c_driver(ov13855_i2c_driver);
+
+MODULE_DESCRIPTION("ov13855 sensor driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 21e3415ce367..74b11360ebfd 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -15,7 +15,7 @@
 #include <linux/init.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
-#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/types.h>
@@ -449,8 +449,6 @@ struct ov5640_dev {
 	/* lock to protect all members below */
 	struct mutex lock;
 
-	int power_count;
-
 	struct v4l2_mbus_framefmt fmt;
 	bool pending_fmt_change;
 
@@ -2734,38 +2732,24 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 	return ret;
 }
 
-/* --------------- Subdev Operations --------------- */
-
-static int ov5640_s_power(struct v4l2_subdev *sd, int on)
+static int ov5640_sensor_suspend(struct device *dev)
 {
-	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	int ret = 0;
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
 
-	mutex_lock(&sensor->lock);
-
-	/*
-	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
-	 * update the power state.
-	 */
-	if (sensor->power_count == !on) {
-		ret = ov5640_set_power(sensor, !!on);
-		if (ret)
-			goto out;
-	}
-
-	/* Update the power count. */
-	sensor->power_count += on ? 1 : -1;
-	WARN_ON(sensor->power_count < 0);
-out:
-	mutex_unlock(&sensor->lock);
+	return ov5640_set_power(ov5640, false);
+}
 
-	if (on && !ret && sensor->power_count == 1) {
-		/* restore controls */
-		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
-	}
+static int ov5640_sensor_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
+ 
 
-	return ret;
-}
+	return ov5640_set_power(ov5640, true);
+ }
+ 
+/* --------------- Subdev Operations --------------- */
 
 static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 				     struct v4l2_fract *fi,
@@ -3349,6 +3333,9 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 	/* v4l2_ctrl_lock() locks our own mutex */
 
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
 	switch (ctrl->id) {
 	case V4L2_CID_AUTOGAIN:
 		val = ov5640_get_gain(sensor);
@@ -3364,6 +3351,9 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
 	return 0;
 }
 
@@ -3393,9 +3383,9 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 	/*
 	 * If the device is not powered up by the host driver do
 	 * not apply any controls to H/W at this time. Instead
-	 * the controls will be restored right after power-up.
+	 * the controls will be restored at start streaming time.
 	 */
-	if (sensor->power_count == 0)
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
 		return 0;
 
 	switch (ctrl->id) {
@@ -3438,6 +3428,9 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 
+	pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+
 	return ret;
 }
 
@@ -3716,6 +3709,18 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 	int delay;
 	int ret = 0;
 
+	if (enable) {
+		ret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);
+		if (ret < 0)
+			return ret;
+
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+		if (ret) {
+			pm_runtime_put(&sensor->i2c_client->dev);
+			return ret;
+		}
+	}
+
 	mutex_lock(&sensor->lock);
 
 	if (sensor->streaming == !enable) {
@@ -3744,8 +3749,15 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 		delay = (enable) ? 100 : 0;
 		msleep(delay);
 	}
+
 out:
 	mutex_unlock(&sensor->lock);
+
+	if (!enable || ret) {
+		pm_runtime_mark_last_busy(&sensor->i2c_client->dev);
+		pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
+	}
+
 	return ret;
 }
 
@@ -3769,7 +3781,6 @@ static int ov5640_init_cfg(struct v4l2_subdev *sd,
 }
 
 static const struct v4l2_subdev_core_ops ov5640_core_ops = {
-	.s_power = ov5640_s_power,
 	.log_status = v4l2_ctrl_subdev_log_status,
 	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
 	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
@@ -3826,26 +3837,20 @@ static int ov5640_check_chip_id(struct ov5640_dev *sensor)
 	int ret = 0;
 	u16 chip_id;
 
-	ret = ov5640_set_power_on(sensor);
-	if (ret)
-		return ret;
-
 	ret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to read chip identifier\n",
 			__func__);
-		goto power_off;
+		return ret;
 	}
 
 	if (chip_id != 0x5640) {
 		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x5640, got 0x%x\n",
 			__func__, chip_id);
-		ret = -ENXIO;
+		return -ENXIO;
 	}
 
-power_off:
-	ov5640_set_power_off(sensor);
-	return ret;
+	return 0;
 }
 
 static int ov5640_probe(struct i2c_client *client)
@@ -3940,26 +3945,44 @@ static int ov5640_probe(struct i2c_client *client)
 
 	ret = ov5640_get_regulators(sensor);
 	if (ret)
-		return ret;
+		goto entity_cleanup;
 
 	mutex_init(&sensor->lock);
 
-	ret = ov5640_check_chip_id(sensor);
+	ret = ov5640_init_controls(sensor);
 	if (ret)
 		goto entity_cleanup;
 
-	ret = ov5640_init_controls(sensor);
+	ret = ov5640_sensor_resume(dev);
+	if (ret) {
+		dev_err(dev, "failed to power on\n");
+ 		goto entity_cleanup;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+	ret = ov5640_check_chip_id(sensor);
 	if (ret)
-		goto entity_cleanup;
+		goto err_pm_runtime;
 
 	ret = v4l2_async_register_subdev_sensor(&sensor->sd);
 	if (ret)
-		goto free_ctrls;
+		goto err_pm_runtime;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
 
 	return 0;
 
-free_ctrls:
-	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+err_pm_runtime:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+ 	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	ov5640_sensor_suspend(dev);
 entity_cleanup:
 	media_entity_cleanup(&sensor->sd.entity);
 	mutex_destroy(&sensor->lock);
@@ -3970,6 +3993,12 @@ static void ov5640_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	struct device *dev = &client->dev;
+
+	pm_runtime_disable(dev);
+	if (!pm_runtime_status_suspended(dev))
+		ov5640_sensor_suspend(dev);
+	pm_runtime_set_suspended(dev);
 
 	v4l2_async_unregister_subdev(&sensor->sd);
 	media_entity_cleanup(&sensor->sd.entity);
@@ -3977,6 +4006,10 @@ static void ov5640_remove(struct i2c_client *client)
 	mutex_destroy(&sensor->lock);
 }
 
+static const struct dev_pm_ops ov5640_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov5640_sensor_suspend, ov5640_sensor_resume, NULL)
+};
+
 static const struct i2c_device_id ov5640_id[] = {
 	{"ov5640", 0},
 	{},
@@ -3993,6 +4026,7 @@ static struct i2c_driver ov5640_i2c_driver = {
 	.driver = {
 		.name  = "ov5640",
 		.of_match_table	= ov5640_dt_ids,
+		.pm = &ov5640_pm_ops,
 	},
 	.id_table = ov5640_id,
 	.probe    = ov5640_probe,
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 79f2cecf8e2a..2844fb80d244 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -436,6 +436,8 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 		return ret;
 	}
 
+	phy_modify_paged_changed(phydev, 0xd04, 0x10, 0x4f20,0x205b);
+
 	return genphy_soft_reset(phydev);
 }
 
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index f6a563f7dc59..e9084b477764 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -326,6 +326,14 @@ config SERIAL_MAX310X
 
 	  Say Y here if you want to support this ICs.
 
+config SERIAL_ADL1001
+	tristate "ADL1001 support"
+	depends on I2C
+	select SERIAL_CORE
+	select REGMAP_I2C if I2C
+	help
+	  ADL1001 chip support
+
 config SERIAL_DZ
 	bool "DECstation DZ serial driver"
 	depends on MACH_DECSTATION && 32BIT
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 31d8bf4f6e08..1ccce6c7b78f 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_SERIAL_BCM63XX) += bcm63xx_uart.o
 obj-$(CONFIG_SERIAL_SAMSUNG) += samsung_tty.o
 obj-$(CONFIG_SERIAL_MAX3100) += max3100.o
 obj-$(CONFIG_SERIAL_MAX310X) += max310x.o
+obj-$(CONFIG_SERIAL_ADL1001) += adl1001.o
 obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
 obj-$(CONFIG_SERIAL_MUX) += mux.o
 obj-$(CONFIG_SERIAL_MCF) += mcf.o
diff --git a/drivers/tty/serial/adl1001.c b/drivers/tty/serial/adl1001.c
new file mode 100644
index 000000000000..5a7221f3c29c
--- /dev/null
+++ b/drivers/tty/serial/adl1001.c
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *  ADL1001 serial driver
+ *
+ *
+ *  Based on max310x.c, by Jimmy Yu <jimmy.yu@adlinktech.com>
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/uaccess.h>
+
+#define CIRC_EMPTY_SLEEP	10
+#define TX_BUSY_SLEEP		10
+#define ADL1001_BAUD_MIN	4800
+#define ADL1001_BAUD_MAX	115200
+#define ADL1001_NAME			"adl1001"
+#define ADL1001_UART_NRMAX		1
+
+/* ADL1001 register definitions */
+#define ADL1001_BAUD			(0x1)
+#define ADL1001_RXFIFOLVL_REG	(0x2) /* RX FIFO level */
+#define ADL1001_RHR_REG			(0x03) /* RX FIFO */
+#define ADL1001_THR_REG			(0x04) /* TX FIFO */
+#define ADL1001_TX_BUSY			(0x05) /* TX BUSY */
+#define ADL1001_WORD_LENGTH		(0x06) 
+#define ADL1001_STOP_BITS		(0x07) 
+#define ADL1001_PARITY			(0x08) 
+#define ADL1001_HWCONTROL			(0x09) 
+
+#define ADL1001_HWCONTROL_RTS_CTS	(0x08)
+#define ADL1001_HWCONTROL_NONE		(0x01)
+
+#define ADL1001_BAUD_4800			(0x01)
+#define ADL1001_BAUD_9600			(0x02)
+#define ADL1001_BAUD_19200			(0x04)
+#define ADL1001_BAUD_38400			(0x08)
+#define ADL1001_BAUD_57600			(0x10)
+#define ADL1001_BAUD_115200			(0x20)
+
+#define ADL1001_WORD_LENGTH_7B		(0x01) 
+#define ADL1001_WORD_LENGTH_8B		(0x02) 
+
+#define ADL1001_STOP_BITS_1		(0x02)
+#define ADL1001_STOP_BITS_2		(0x08)
+
+#define ADL1001_PARITY_NONE			(0x01) 
+#define ADL1001_PARITY_EVEN			(0x02) 
+#define ADL1001_PARITY_ODD			(0x04)
+#define ADL1001_REG_1F			(0x1f)
+
+/* Global commands */
+
+/* Misc definitions */
+#define ADL1001_FIFO_SIZE		(128)
+
+struct adl1001_devtype {
+	char	name[9];
+	int	nr;
+	void	(*power)(struct uart_port *, int);
+};
+
+struct adl1001_one {
+	struct uart_port	port;
+	struct work_struct	tx_work;
+	struct regmap		*regmap;
+
+	u8 rx_buf[ADL1001_FIFO_SIZE];
+};
+#define to_adl1001_port(_port) \
+	container_of(_port, struct adl1001_one, port)
+
+struct adl1001_port {
+	const struct adl1001_devtype *devtype;
+	struct regmap		*regmap;
+	struct clk		*clk;
+	struct adl1001_one	p[];
+};
+
+static struct uart_driver adl1001_uart = {
+	.owner		= THIS_MODULE,
+	.driver_name	= ADL1001_NAME,
+	.dev_name	= "ttyADL",
+	.nr		= ADL1001_UART_NRMAX,
+};
+
+static DECLARE_BITMAP(adl1001_lines, ADL1001_UART_NRMAX);
+
+static u8 adl1001_port_read(struct uart_port *port, u8 reg)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+	unsigned int val = 0;
+
+	regmap_read(one->regmap, reg, &val);
+
+	return val;
+}
+
+static void adl1001_port_write(struct uart_port *port, u8 reg, u8 val)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	regmap_write(one->regmap, reg, val);
+}
+
+static void adl1001_power(struct uart_port *port, int on)
+{
+
+}
+
+static const struct adl1001_devtype adl1001_devtype = {
+	.name	= "ADL1001",
+	.nr	= 1,
+	.power	= adl1001_power,
+};
+
+static bool adl1001_reg_writeable(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RXFIFOLVL_REG:
+	case ADL1001_TX_BUSY:
+		return false;
+	default:
+		break;
+	}
+
+	return true;
+
+}
+
+static bool adl1001_reg_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+	case ADL1001_THR_REG:
+	case ADL1001_RXFIFOLVL_REG:
+	case ADL1001_TX_BUSY:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool adl1001_reg_precious(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool adl1001_reg_noinc(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case ADL1001_RHR_REG:
+	case ADL1001_THR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static int adl1001_set_baud(struct uart_port *port, int baud)
+{
+	u8 val;
+	switch (baud) {
+	case 115200:
+		val = ADL1001_BAUD_115200;
+		break;
+	case 57600:
+		val = ADL1001_BAUD_57600;
+		break;
+	case 38400:
+		val = ADL1001_BAUD_38400;
+		break;
+	case 19200:
+		val = ADL1001_BAUD_19200;
+		break;
+	case 9600:
+		val = ADL1001_BAUD_9600;
+		break;
+	case 4800:
+		val = ADL1001_BAUD_4800;
+		break;
+	default:
+		val = ADL1001_BAUD_115200;
+		baud = 115200;
+		break;
+	}
+	adl1001_port_write(port, ADL1001_BAUD, val);
+	/* Return the actual baud rate we just programmed */
+	return baud;
+}
+
+static void adl1001_batch_write(struct uart_port *port, u8 *txbuf, unsigned int len)
+{
+	u8 buf[ADL1001_FIFO_SIZE+1];
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	buf[0]=len;
+	memcpy(buf+1,txbuf,len);
+
+	while (adl1001_port_read(port, ADL1001_TX_BUSY))
+	{
+		dev_dbg(port->dev, "TX Busy !!! sleep %dms\n",TX_BUSY_SLEEP);
+		msleep(TX_BUSY_SLEEP);
+	}
+
+	regmap_noinc_write(one->regmap, ADL1001_THR_REG, buf, len+1);
+}
+
+static void adl1001_batch_read(struct uart_port *port, u8 *rxbuf, unsigned int len)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	regmap_noinc_read(one->regmap, ADL1001_RHR_REG, rxbuf, len);
+}
+
+static void adl1001_handle_rx(struct uart_port *port, unsigned int rxlen)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+	unsigned int sts, i;
+	u8 flag;
+
+	{
+		adl1001_batch_read(port, one->rx_buf, rxlen);
+
+		port->icount.rx += rxlen;
+		flag = TTY_NORMAL;
+
+		for (i = 0; i < rxlen; ++i)
+			uart_insert_char(port, sts, 0, one->rx_buf[i], flag);
+
+	} 
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
+static void adl1001_handle_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int txlen, to_send, until_end;
+
+	while(1)
+	{
+		if (unlikely(port->x_char)) {
+			dev_dbg(port->dev, "send x_char\n");
+			adl1001_batch_write(port, &(port->x_char), 1);
+			port->icount.tx++;
+			port->x_char = 0;
+			continue;
+		}
+		
+		if (uart_tx_stopped(port))
+		{
+			dev_dbg(port->dev, "tx stop\n");
+			break;
+		}
+	
+		while (uart_circ_empty(xmit))
+		{
+			dev_dbg(port->dev, "TX CIRC EMPTY !!! sleep %dms\n",TX_BUSY_SLEEP);
+			msleep(CIRC_EMPTY_SLEEP);
+		}
+		/* Get length of data pending in circular buffer */
+		to_send = uart_circ_chars_pending(xmit);
+		until_end = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+		
+		if (likely(to_send)) {
+			/* Limit to size of TX FIFO */
+			txlen = 0;
+			txlen = port->fifosize - txlen;
+			to_send = (to_send > txlen) ? txlen : to_send;
+
+			if (until_end < to_send) {
+				/* It's a circ buffer -- wrap around.
+			 	* We could do that in one SPI transaction, but meh. */
+				adl1001_batch_write(port, xmit->buf + xmit->tail, until_end);
+				adl1001_batch_write(port, xmit->buf, to_send - until_end);
+			} else {
+				adl1001_batch_write(port, xmit->buf + xmit->tail, to_send);
+			}
+			uart_xmit_advance(port, to_send);
+		}
+
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(port);
+	}
+}
+
+static void adl1001_start_tx(struct uart_port *port)
+{
+	struct adl1001_one *one = to_adl1001_port(port);
+
+	schedule_work(&one->tx_work);
+}
+
+static irqreturn_t adl1001_port_irq(struct adl1001_port *s, int portno)
+{
+	struct uart_port *port = &s->p[portno].port;
+	irqreturn_t res = IRQ_NONE;
+
+	{
+		unsigned int rxlen;
+
+		/* Read IRQ status & RX FIFO level */
+		rxlen = adl1001_port_read(port, ADL1001_RXFIFOLVL_REG);
+
+		res = IRQ_HANDLED;
+
+		if (rxlen)
+			adl1001_handle_rx(port, rxlen);
+	} 
+	return res;
+}
+
+static irqreturn_t adl1001_ist(int irq, void *dev_id)
+{
+	struct adl1001_port *s = (struct adl1001_port *)dev_id;
+	bool handled = false;
+#if 0
+	if (s->devtype->nr > 1) {
+		do {
+			unsigned int val = ~0;
+
+			//WARN_ON_ONCE(regmap_read(s->regmap,
+			//			 ADL1001_GLOBALIRQ_REG, &val));
+			val = ((1 << s->devtype->nr) - 1) & ~val;
+			if (!val)
+				break;
+			if (adl1001_port_irq(s, fls(val) - 1) == IRQ_HANDLED)
+				handled = true;
+		} while (1);
+	} else 
+#endif
+	{
+		if (adl1001_port_irq(s, 0) == IRQ_HANDLED)
+			handled = true;
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+static void adl1001_tx_proc(struct work_struct *ws)
+{
+	struct adl1001_one *one = container_of(ws, struct adl1001_one, tx_work);
+	
+	adl1001_handle_tx(&one->port);
+}
+
+static unsigned int adl1001_tx_empty(struct uart_port *port)
+{
+	u8 lvl = adl1001_port_read(port, ADL1001_TX_BUSY);
+
+	return lvl ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int adl1001_get_mctrl(struct uart_port *port)
+{
+	/* DCD and DSR are not wired and CTS/RTS is handled automatically
+	 * so just indicate DSR and CAR asserted
+	 */
+	return TIOCM_DSR | TIOCM_CAR;
+}
+
+static void adl1001_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+
+}
+
+static void adl1001_break_ctl(struct uart_port *port, int break_state)
+{
+
+}
+
+static void adl1001_set_termios(struct uart_port *port,
+				struct ktermios *termios,
+				const struct ktermios *old)
+{
+	int baud;
+
+	/* Mask termios capabilities we don't support */
+	termios->c_cflag &= ~CMSPAR;
+	termios->c_cflag &= ~(CMSPAR);
+
+	{
+		u8 val;
+		if (termios->c_cflag & CRTSCTS) {
+			/* Enable AUTORTS and AUTOCTS */
+			port->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
+			val = ADL1001_HWCONTROL_RTS_CTS;
+		}
+		else
+			val = ADL1001_HWCONTROL_NONE;
+		adl1001_port_write(port, ADL1001_HWCONTROL , val);
+	}
+
+	//only support CS7,CS8
+	if (((termios->c_cflag & CSIZE) == CS5 )||((termios->c_cflag & CSIZE) == CS6 ))
+	{
+		termios->c_cflag &= ~(CSIZE);
+		termios->c_cflag |= (CS8);
+	}
+
+	{
+		u8 val;
+		switch (termios->c_cflag & CSIZE) {
+		case CS7:
+			val = ADL1001_WORD_LENGTH_7B;
+			break;
+		case CS8:
+		default:
+			val = ADL1001_WORD_LENGTH_8B;
+			break;
+		}
+		adl1001_port_write(port, ADL1001_WORD_LENGTH, val);
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		adl1001_port_write(port, ADL1001_STOP_BITS, ADL1001_STOP_BITS_2); //2 stop bit
+	else
+		adl1001_port_write(port, ADL1001_STOP_BITS, ADL1001_STOP_BITS_1); //1 stop bit
+
+
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+			adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_ODD);
+		else
+			adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_EVEN);
+	}
+	else
+		adl1001_port_write(port, ADL1001_PARITY, ADL1001_PARITY_NONE);
+
+	/* Set status ignore mask */
+	port->ignore_status_mask = 0;
+
+	baud = uart_get_baud_rate(port, termios, old,ADL1001_BAUD_MIN,ADL1001_BAUD_MAX);
+
+	/* Setup baudrate generator */
+	baud = adl1001_set_baud(port, baud);
+
+	/* Update timeout according to new baud rate */
+	uart_update_timeout(port, termios->c_cflag, baud);
+}
+
+static int adl1001_startup(struct uart_port *port)
+{
+	return 0;
+}
+
+static void adl1001_shutdown(struct uart_port *port)
+{
+
+}
+
+static const char *adl1001_type(struct uart_port *port)
+{
+	struct adl1001_port *s = dev_get_drvdata(port->dev);
+
+	return (port->type == 124) ? s->devtype->name : NULL;
+}
+
+static int adl1001_request_port(struct uart_port *port)
+{
+	/* Do nothing */
+	return 0;
+}
+
+static void adl1001_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = 124;
+}
+
+static int adl1001_verify_port(struct uart_port *port, struct serial_struct *s)
+{
+	if ((s->type != PORT_UNKNOWN) && (s->type != 124))
+		return -EINVAL;
+	if (s->irq != port->irq)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void adl1001_null_void(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+static const struct uart_ops adl1001_ops = {
+	.tx_empty	= adl1001_tx_empty,
+	.set_mctrl	= adl1001_set_mctrl,
+	.get_mctrl	= adl1001_get_mctrl,
+	.stop_tx	= adl1001_null_void,
+	.start_tx	= adl1001_start_tx,
+	.stop_rx	= adl1001_null_void,
+	.break_ctl	= adl1001_break_ctl,
+	.startup	= adl1001_startup,
+	.shutdown	= adl1001_shutdown,
+	.set_termios	= adl1001_set_termios,
+	.type		= adl1001_type,
+	.request_port	= adl1001_request_port,
+	.release_port	= adl1001_null_void,
+	.config_port	= adl1001_config_port,
+	.verify_port	= adl1001_verify_port,
+};
+
+static int __maybe_unused adl1001_suspend(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		uart_suspend_port(&adl1001_uart, &s->p[i].port);
+		s->devtype->power(&s->p[i].port, 0);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused adl1001_resume(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		s->devtype->power(&s->p[i].port, 1);
+		uart_resume_port(&adl1001_uart, &s->p[i].port);
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(adl1001_pm_ops, adl1001_suspend, adl1001_resume);
+
+static int adl1001_probe(struct device *dev, const struct adl1001_devtype *devtype,
+//			 const struct adl1001_if_cfg *if_cfg,
+			 struct regmap *regmaps[], int irq)
+{
+	int i, ret;
+	struct adl1001_port *s;
+	u32 uartclk = 0;
+
+	for (i = 0; i < devtype->nr; i++)
+		if (IS_ERR(regmaps[i]))
+			return PTR_ERR(regmaps[i]);
+
+	/* Alloc port structure */
+	s = devm_kzalloc(dev, struct_size(s, p, devtype->nr), GFP_KERNEL);
+	if (!s) {
+		dev_err(dev, "Error allocating port structure\n");
+		return -ENOMEM;
+	}
+
+	s->regmap = regmaps[0];
+	s->devtype = devtype;
+	//s->if_cfg = if_cfg;
+	dev_set_drvdata(dev, s);
+
+	/* Check device to ensure we are talking to what we expect */
+
+	for (i = 0; i < devtype->nr; i++) {
+		unsigned int line;
+
+		line = find_first_zero_bit(adl1001_lines, ADL1001_UART_NRMAX);
+		if (line == ADL1001_UART_NRMAX) {
+			ret = -ERANGE;
+			goto out_uart;
+		}
+
+		/* Initialize port data */
+		s->p[i].port.line	= line;
+		s->p[i].port.dev	= dev;
+		s->p[i].port.irq	= irq;
+		s->p[i].port.type	= 124;
+		s->p[i].port.fifosize	= ADL1001_FIFO_SIZE;
+		s->p[i].port.flags	= UPF_FIXED_TYPE | UPF_LOW_LATENCY;
+		s->p[i].port.iotype	= UPIO_PORT;
+		s->p[i].port.iobase	= i;
+		/*
+		 * Use all ones as membase to make sure uart_configure_port() in
+		 * serial_core.c does not abort for SPI/I2C devices where the
+		 * membase address is not applicable.
+		 */
+		s->p[i].port.membase	= (void __iomem *)~0;
+		s->p[i].port.uartclk	= uartclk;
+		s->p[i].port.ops	= &adl1001_ops;
+		s->p[i].regmap		= regmaps[i];
+
+		INIT_WORK(&s->p[i].tx_work, adl1001_tx_proc);
+
+		/* Register port */
+		ret = uart_add_one_port(&adl1001_uart, &s->p[i].port);
+		if (ret) {
+			s->p[i].port.dev = NULL;
+			goto out_uart;
+		}
+		set_bit(line, adl1001_lines);
+
+		/* Go to suspend mode */
+		devtype->power(&s->p[i].port, 0);
+	}
+
+	/* Setup interrupt */
+	ret = devm_request_threaded_irq(dev, irq, NULL, adl1001_ist,
+					IRQF_ONESHOT | IRQF_SHARED, dev_name(dev), s);
+	if (!ret)
+	{
+		return 0;
+	}
+	dev_err(dev, "Unable to reguest IRQ %i\n", irq);
+
+out_uart:
+	for (i = 0; i < devtype->nr; i++) {
+		if (s->p[i].port.dev) {
+			uart_remove_one_port(&adl1001_uart, &s->p[i].port);
+			clear_bit(s->p[i].port.line, adl1001_lines);
+		}
+	}
+
+	clk_disable_unprepare(s->clk);
+
+	return ret;
+}
+
+static void adl1001_remove(struct device *dev)
+{
+	struct adl1001_port *s = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < s->devtype->nr; i++) {
+		cancel_work_sync(&s->p[i].tx_work);
+		uart_remove_one_port(&adl1001_uart, &s->p[i].port);
+		clear_bit(s->p[i].port.line, adl1001_lines);
+		s->devtype->power(&s->p[i].port, 0);
+	}
+
+	clk_disable_unprepare(s->clk);
+}
+
+static const struct of_device_id __maybe_unused adl1001_dt_ids[] = {
+	{ .compatible = "adlink,adl1001",	.data = &adl1001_devtype, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, adl1001_dt_ids);
+
+#ifdef CONFIG_I2C
+
+static struct regmap_config regcfg_i2c = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.writeable_reg = adl1001_reg_writeable,
+	.volatile_reg = adl1001_reg_volatile,
+	.precious_reg = adl1001_reg_precious,
+	.max_register = ADL1001_REG_1F,
+	.writeable_noinc_reg = adl1001_reg_noinc,
+	.readable_noinc_reg = adl1001_reg_noinc,
+	.max_raw_read = ADL1001_FIFO_SIZE,
+	.max_raw_write = ADL1001_FIFO_SIZE,
+};
+
+static int adl1001_i2c_probe(struct i2c_client *client)
+{
+	const struct adl1001_devtype *devtype =
+			device_get_match_data(&client->dev);
+	struct i2c_client *port_client;
+	struct regmap *regmaps[4];
+	unsigned int i;
+	u8 port_addr;
+
+	dev_info(&client->dev, "adl1001_i2c_probe client->addr:0x%x\n",client->addr);
+
+	regmaps[0] = devm_regmap_init_i2c(client, &regcfg_i2c);
+
+	return adl1001_probe(&client->dev, devtype,
+			     regmaps, client->irq);
+}
+
+static void adl1001_i2c_remove(struct i2c_client *client)
+{
+	adl1001_remove(&client->dev);
+}
+
+static struct i2c_driver adl1001_i2c_driver = {
+	.driver = {
+		.name		= ADL1001_NAME,
+		.of_match_table	= adl1001_dt_ids,
+		.pm		= &adl1001_pm_ops,
+	},
+	.probe		= adl1001_i2c_probe,
+	.remove		= adl1001_i2c_remove,
+};
+#endif
+
+static int __init adl1001_uart_init(void)
+{
+	int ret;
+
+	bitmap_zero(adl1001_lines, ADL1001_UART_NRMAX);
+
+	ret = uart_register_driver(&adl1001_uart);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_I2C
+	ret = i2c_add_driver(&adl1001_i2c_driver);
+	if (ret)
+		goto err_i2c_register;
+#endif
+
+	return 0;
+#ifdef CONFIG_I2C
+err_i2c_register:
+	uart_unregister_driver(&adl1001_uart);
+
+	return ret;
+#endif
+}
+module_init(adl1001_uart_init);
+
+static void __exit adl1001_uart_exit(void)
+{
+#ifdef CONFIG_I2C
+	i2c_del_driver(&adl1001_i2c_driver);
+#endif
+
+	uart_unregister_driver(&adl1001_uart);
+}
+module_exit(adl1001_uart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jimmy Yu <jimmy.yu@adlinktech.com>");
+MODULE_DESCRIPTION("ADL1001 serial driver");
diff --git a/sound/soc/codecs/tlv320aic3x.c b/sound/soc/codecs/tlv320aic3x.c
index 56e795a00e22..caea7e503076 100644
--- a/sound/soc/codecs/tlv320aic3x.c
+++ b/sound/soc/codecs/tlv320aic3x.c
@@ -45,6 +45,7 @@
 #include <sound/soc.h>
 #include <sound/initval.h>
 #include <sound/tlv.h>
+#include <linux/clk.h>
 
 #include "tlv320aic3x.h"
 
@@ -88,37 +89,38 @@ struct aic3x_priv {
 	enum aic3x_micbias_voltage micbias_vg;
 	/* Output Common-Mode Voltage */
 	u8 ocmv;
+	struct clk *mclk;
 };
 
 static const struct reg_default aic3x_reg[] = {
-	{   0, 0x00 }, {   1, 0x00 }, {   2, 0x00 }, {   3, 0x10 },
-	{   4, 0x04 }, {   5, 0x00 }, {   6, 0x00 }, {   7, 0x00 },
-	{   8, 0x00 }, {   9, 0x00 }, {  10, 0x00 }, {  11, 0x01 },
-	{  12, 0x00 }, {  13, 0x00 }, {  14, 0x00 }, {  15, 0x80 },
-	{  16, 0x80 }, {  17, 0xff }, {  18, 0xff }, {  19, 0x78 },
-	{  20, 0x78 }, {  21, 0x78 }, {  22, 0x78 }, {  23, 0x78 },
-	{  24, 0x78 }, {  25, 0x00 }, {  26, 0x00 }, {  27, 0xfe },
-	{  28, 0x00 }, {  29, 0x00 }, {  30, 0xfe }, {  31, 0x00 },
-	{  32, 0x18 }, {  33, 0x18 }, {  34, 0x00 }, {  35, 0x00 },
-	{  36, 0x00 }, {  37, 0x00 }, {  38, 0x00 }, {  39, 0x00 },
-	{  40, 0x00 }, {  41, 0x00 }, {  42, 0x00 }, {  43, 0x80 },
-	{  44, 0x80 }, {  45, 0x00 }, {  46, 0x00 }, {  47, 0x00 },
-	{  48, 0x00 }, {  49, 0x00 }, {  50, 0x00 }, {  51, 0x04 },
-	{  52, 0x00 }, {  53, 0x00 }, {  54, 0x00 }, {  55, 0x00 },
-	{  56, 0x00 }, {  57, 0x00 }, {  58, 0x04 }, {  59, 0x00 },
-	{  60, 0x00 }, {  61, 0x00 }, {  62, 0x00 }, {  63, 0x00 },
-	{  64, 0x00 }, {  65, 0x04 }, {  66, 0x00 }, {  67, 0x00 },
-	{  68, 0x00 }, {  69, 0x00 }, {  70, 0x00 }, {  71, 0x00 },
-	{  72, 0x04 }, {  73, 0x00 }, {  74, 0x00 }, {  75, 0x00 },
-	{  76, 0x00 }, {  77, 0x00 }, {  78, 0x00 }, {  79, 0x00 },
-	{  80, 0x00 }, {  81, 0x00 }, {  82, 0x00 }, {  83, 0x00 },
-	{  84, 0x00 }, {  85, 0x00 }, {  86, 0x00 }, {  87, 0x00 },
-	{  88, 0x00 }, {  89, 0x00 }, {  90, 0x00 }, {  91, 0x00 },
-	{  92, 0x00 }, {  93, 0x00 }, {  94, 0x00 }, {  95, 0x00 },
-	{  96, 0x00 }, {  97, 0x00 }, {  98, 0x00 }, {  99, 0x00 },
-	{ 100, 0x00 }, { 101, 0x00 }, { 102, 0x02 }, { 103, 0x00 },
-	{ 104, 0x00 }, { 105, 0x00 }, { 106, 0x00 }, { 107, 0x00 },
-	{ 108, 0x00 }, { 109, 0x00 },
+    {   0, 0x00 }, {   1, 0x00 }, {   2, 0x00 }, {   3, 0x00 },
+    {   4, 0x03 }, {   5, 0x09 }, {   6, 0x08 }, {   7, 0x00 },
+    {   8, 0x00 }, {   9, 0x00 }, {  10, 0x00 }, {  11, 0x08 },
+    {  12, 0x02 }, {  13, 0x00 }, {  14, 0x80 }, {  15, 0x80 },
+    {  16, 0x80 }, {  17, 0xff }, {  18, 0x08 }, {  19, 0x02 },
+    {  20, 0x80 }, {  21, 0x78 }, {  22, 0x78 }, {  23, 0x78 },
+    {  24, 0x78 }, {  25, 0x00 }, {  26, 0x00 }, {  27, 0xfe },
+    {  28, 0x00 }, {  29, 0x00 }, {  30, 0xfe }, {  31, 0x00 },
+    {  32, 0x18 }, {  33, 0x18 }, {  34, 0x00 }, {  35, 0x00 },
+    {  36, 0x00 }, {  37, 0x00 }, {  38, 0x00 }, {  39, 0x00 },
+    {  40, 0x00 }, {  41, 0x00 }, {  42, 0x00 }, {  43, 0x80 },
+    {  44, 0x80 }, {  45, 0x00 }, {  46, 0x00 }, {  47, 0x00 },
+    {  48, 0x00 }, {  49, 0x00 }, {  50, 0x00 }, {  51, 0x04 },
+    {  52, 0x00 }, {  53, 0x00 }, {  54, 0x00 }, {  55, 0x00 },
+    {  56, 0x00 }, {  57, 0x00 }, {  58, 0x04 }, {  59, 0x00 },
+    {  60, 0x00 }, {  61, 0x00 }, {  62, 0x00 }, {  63, 0x00 },
+    {  64, 0x00 }, {  65, 0x04 }, {  66, 0x00 }, {  67, 0x00 },
+    {  68, 0x00 }, {  69, 0x00 }, {  70, 0x00 }, {  71, 0x00 },
+    {  72, 0x04 }, {  73, 0x00 }, {  74, 0x00 }, {  75, 0x00 },
+    {  76, 0x00 }, {  77, 0x00 }, {  78, 0x00 }, {  79, 0x00 },
+    {  80, 0x00 }, {  81, 0x00 }, {  82, 0x00 }, {  83, 0x00 },
+    {  84, 0x00 }, {  85, 0x00 }, {  86, 0x00 }, {  87, 0x00 },
+    {  88, 0x00 }, {  89, 0x00 }, {  90, 0x00 }, {  91, 0x00 },
+    {  92, 0x00 }, {  93, 0x00 }, {  94, 0x00 }, {  95, 0x00 },
+    {  96, 0x00 }, {  97, 0x00 }, {  98, 0x00 }, {  99, 0x00 },
+    { 100, 0x00 }, { 101, 0x00 }, { 102, 0x02 }, { 103, 0x00 },
+    { 104, 0x00 }, { 105, 0x00 }, { 106, 0x00 }, { 107, 0x00 },
+    { 108, 0x00 }, { 109, 0x00 },
 };
 
 static bool aic3x_volatile_reg(struct device *dev, unsigned int reg)
@@ -1832,9 +1834,25 @@ int aic3x_probe(struct device *dev, struct regmap *regmap, kernel_ulong_t driver
 			dev_err(dev, "Failed to init class D: %d\n", ret);
 	}
 
+	aic3x->mclk = devm_clk_get(dev, "mclk");
+	if (IS_ERR(aic3x->mclk)) {
+            aic3x->mclk = NULL;
+            dev_err(dev, "mclk missing or invalid\n");
+    }
+	else
+	{
+		ret = clk_prepare_enable(aic3x->mclk);
+		if (ret < 0) {
+			dev_err(dev, "Failed to enable mclk\n");
+		}
+	}
 	ret = devm_snd_soc_register_component(dev, &soc_component_dev_aic3x, &aic3x_dai, 1);
 	if (ret)
+	{
+		if(aic3x->mclk)
+			clk_disable_unprepare(aic3x->mclk);
 		return ret;
+	}
 
 	return 0;
 }
@@ -1844,6 +1862,8 @@ void aic3x_remove(struct device *dev)
 {
 	struct aic3x_priv *aic3x = dev_get_drvdata(dev);
 
+	if(aic3x->mclk)
+		clk_disable_unprepare(aic3x->mclk);
 	/* Leave the codec in reset state */
 	if (aic3x->gpio_reset && !aic3x->shared_reset)
 		gpiod_set_value(aic3x->gpio_reset, 1);
diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 25443f3cbe1b..9df9e29540f6 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -324,6 +324,19 @@ config SND_SOC_IMX_SPDIF
 	  Say Y if you want to add support for SoC audio on an i.MX board with
 	  a S/DPDIF.
 
+config SND_SOC_IMX_TLV320AIC3X
+        tristate "SoC Audio support for i.MX6 boards with tlv320aic3x audio codec"
+        depends on OF && I2C
+        select SND_SOC_IMX_PCM_DMA
+        select SND_SOC_IMX_AUDMUX
+        select SND_SOC_FSL_SAI
+        select SND_SOC_FSL_UTILS
+        select SND_KCTL_JACK
+    help
+          SoC audio for i.MX8M boards with codec TLV320AIC3x attached over
+          SSI interface.
+          Say Y if you want to add support for SoC audio on LEC-iMX8MP boards.
+
 config SND_SOC_FSL_ASOC_CARD
 	tristate "Generic ASoC Sound Card with ASRC support"
 	depends on OF && I2C
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index d2f6c75c1fde..dd57d35ec6c9 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -20,6 +20,7 @@ snd-soc-fsl-ssi-y := fsl_ssi.o
 snd-soc-fsl-ssi-$(CONFIG_DEBUG_FS) += fsl_ssi_dbg.o
 snd-soc-fsl-spdif-objs := fsl_spdif.o
 snd-soc-fsl-esai-objs := fsl_esai.o
+snd-soc-imx-tlv320aic3x-objs := imx-tlv320aic3x.o
 snd-soc-fsl-micfil-objs := fsl_micfil.o
 snd-soc-fsl-utils-objs := fsl_utils.o
 snd-soc-fsl-dma-objs := fsl_dma.o
@@ -30,6 +31,7 @@ snd-soc-fsl-aud2htx-objs := fsl_aud2htx.o
 snd-soc-fsl-rpmsg-objs := fsl_rpmsg.o
 snd-soc-fsl-qmc-audio-objs := fsl_qmc_audio.o
 
+obj-${CONFIG_SND_SOC_IMX_TLV320AIC3X} += snd-soc-imx-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_FSL_AUDMIX) += snd-soc-fsl-audmix.o
 obj-$(CONFIG_SND_SOC_FSL_ASOC_CARD) += snd-soc-fsl-asoc-card.o
 snd-soc-fsl-hdmi-objs := fsl_hdmi.o
diff --git a/sound/soc/fsl/imx-tlv320aic3x.c b/sound/soc/fsl/imx-tlv320aic3x.c
new file mode 100644
index 000000000000..0d9d4eef1d3f
--- /dev/null
+++ b/sound/soc/fsl/imx-tlv320aic3x.c
@@ -0,0 +1,249 @@
+/*
+ * 2014 Variscite, Ltd. All Rights Reserved.
+ *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * 2012 Variscite, Ltd. All Rights Reserved.
+ * Based on imx-wm8962.c
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <sound/soc.h>
+
+#include "../codecs/tlv320aic3x.h"
+#include "imx-audmux.h"
+
+#define DAI_NAME_SIZE	32
+
+struct imx_tlv320aic3x_data {
+	struct snd_soc_dai_link dai;
+	struct snd_soc_card card;
+	char codec_dai_name[DAI_NAME_SIZE];
+	char platform_name[DAI_NAME_SIZE];
+	struct clk *codec_clk;
+	unsigned int clk_frequency;
+};
+static int imx_tlv320aic3x_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct imx_tlv320aic3x_data *data = container_of(rtd->card,
+					struct imx_tlv320aic3x_data, card);
+	//struct snd_soc_dai *codec_dai = asoc_rtd_to_cpu(rtd, 0);				
+	struct device *dev = rtd->card->dev;
+	int ret;
+
+	ret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0), 0,
+				     data->clk_frequency, SND_SOC_CLOCK_IN);
+	if (ret) {
+		dev_err(dev, "could not set codec driver clock params\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget imx_tlv320aic3x_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Line Out Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+static int imx_tlv320aic3x_audmux_config(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int int_port, ext_port;
+	int ret;
+
+	ret = of_property_read_u32(np, "mux-int-port", &int_port);
+	if (ret) {
+		dev_err(&pdev->dev, "mux-int-port missing or invalid\n");
+		return ret;
+	}
+	ret = of_property_read_u32(np, "mux-ext-port", &ext_port);
+	if (ret) {
+		dev_err(&pdev->dev, "mux-ext-port missing or invalid\n");
+		return ret;
+	}
+
+	/*
+	 * The port numbering in the hardware manual starts at 1, while
+	 * the audmux API expects it starts at 0.
+	 */
+	int_port--;
+	ext_port--;
+	ret = imx_audmux_v2_configure_port(int_port,
+			IMX_AUDMUX_V2_PTCR_SYN |
+			IMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TFSDIR |
+			IMX_AUDMUX_V2_PTCR_TCLKDIR,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));
+	if (ret) {
+		dev_err(&pdev->dev, "audmux internal port setup failed\n");
+		return ret;
+	}
+	ret = imx_audmux_v2_configure_port(ext_port,
+			IMX_AUDMUX_V2_PTCR_SYN,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
+	if (ret) {
+		dev_err(&pdev->dev, "audmux external port setup failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int imx_tlv320aic3x_probe(struct platform_device *pdev)
+{
+	struct device_node *cpu_np, *codec_np;
+	struct platform_device *cpu_pdev;
+	struct i2c_client *codec_dev;
+	struct imx_tlv320aic3x_data *data;
+	struct snd_soc_dai_link_component *comp;
+	int ret;
+
+	cpu_np = of_parse_phandle(pdev->dev.of_node, "cpu-dai", 0);
+	codec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);
+	if (!cpu_np || !codec_np) {
+		dev_err(&pdev->dev, "phandle missing or invalid\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	if (strstr(cpu_np->name, "ssi")) {
+		ret = imx_tlv320aic3x_audmux_config(pdev);
+		if (ret)
+			goto fail;
+	}
+
+	cpu_pdev = of_find_device_by_node(cpu_np);
+	if (!cpu_pdev) {
+		dev_err(&pdev->dev, "failed to find SSI platform device\n");
+		ret = -EINVAL;
+		goto fail;
+	}
+	codec_dev = of_find_i2c_device_by_node(codec_np);
+	if (!codec_dev) {
+		dev_err(&pdev->dev, "failed to find codec platform device\n");
+		return -EINVAL;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	comp = devm_kzalloc(&pdev->dev, 3 * sizeof(*comp), GFP_KERNEL);
+	if (!data || !comp) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	data->codec_clk = clk_get(&codec_dev->dev, NULL);
+	if (IS_ERR(data->codec_clk)) {
+		/* assuming clock enabled by default */
+		data->codec_clk = NULL;
+		ret = of_property_read_u32(codec_np, "clock-frequency",
+					&data->clk_frequency);
+		if (ret) {
+			dev_err(&codec_dev->dev,
+				"clock-frequency missing or invalid\n");
+			goto fail;
+		}
+	} else {
+		data->clk_frequency = clk_get_rate(data->codec_clk);
+		clk_prepare_enable(data->codec_clk);
+	}
+
+	data->dai.cpus		= &comp[0];
+	data->dai.codecs	= &comp[1];
+	data->dai.platforms	= &comp[2];
+	data->dai.num_cpus	= 1;
+	data->dai.num_codecs	= 1;
+	data->dai.num_platforms	= 1;
+	data->dai.name = "HiFi";
+	data->dai.stream_name = "HiFi";
+	data->dai.codecs->dai_name = "tlv320aic3x-hifi";
+	data->dai.codecs->of_node = codec_np;
+	data->dai.cpus->of_node = cpu_np;
+	data->dai.platforms->of_node = cpu_np;
+	data->dai.init = &imx_tlv320aic3x_dai_init;
+	data->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			    SND_SOC_DAIFMT_CBM_CFM;
+
+	data->card.dev = &pdev->dev;
+	ret = snd_soc_of_parse_card_name(&data->card, "model");
+	if (ret)
+		goto clk_fail;
+	ret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");
+	if (ret)
+		goto clk_fail;
+
+	data->card.num_links = 1;
+	data->card.owner = THIS_MODULE;
+	data->card.dai_link = &data->dai;
+	data->card.dapm_widgets = imx_tlv320aic3x_dapm_widgets;
+	data->card.num_dapm_widgets = ARRAY_SIZE(imx_tlv320aic3x_dapm_widgets);
+
+	ret = snd_soc_register_card(&data->card);
+	if (ret) {
+		dev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);
+		goto clk_fail;
+	}
+
+	platform_set_drvdata(pdev, data);
+clk_fail:
+	clk_put(data->codec_clk);
+fail:
+	if (cpu_np)
+		of_node_put(cpu_np);
+	if (codec_np)
+		of_node_put(codec_np);
+
+	return ret;
+}
+
+static int imx_tlv320aic3x_remove(struct platform_device *pdev)
+{
+	struct imx_tlv320aic3x_data *data = platform_get_drvdata(pdev);
+
+	if (data->codec_clk) {
+		clk_disable_unprepare(data->codec_clk);
+		clk_put(data->codec_clk);
+	}
+	snd_soc_unregister_card(&data->card);
+
+	return 0;
+}
+
+static const struct of_device_id imx_tlv320aic3x_dt_ids[] = {
+	{ .compatible = "fsl,imx-audio-tlv320aic3x", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_tlv320aic3x_dt_ids);
+
+static struct platform_driver imx_tlv320aic3x_driver = {
+	.driver = {
+		.name = "imx-tlv320aic3x",
+		.owner = THIS_MODULE,
+		.of_match_table = imx_tlv320aic3x_dt_ids,
+	},
+	.probe = imx_tlv320aic3x_probe,
+	.remove = imx_tlv320aic3x_remove,
+};
+module_platform_driver(imx_tlv320aic3x_driver);
+
+MODULE_AUTHOR("ron.d@variscite.com. Variscite Ltd.");
+MODULE_DESCRIPTION("Variscite i.MX TLV320aic3x ASoC machine driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:imx-tlv320aic3x");
-- 
2.34.1

