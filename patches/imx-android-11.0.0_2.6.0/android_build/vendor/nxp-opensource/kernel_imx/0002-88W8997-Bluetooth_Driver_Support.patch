diff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig
index 4e73a531b377..8f85ff3d79fd 100644
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@ -425,4 +425,14 @@ config BT_HCIRSI
 	  Say Y here to compile support for HCI over Redpine into the
 	  kernel or say M to compile as a module.
 
+config MBTEX_8997
+        tristate "NXP 8997 BT Driver"
+        depends on BT_HCIUART
+        help
+          NXP 8997 BT driver.
+          This driver handles NXP 88W8997 Bluetooth functionality
+
+          Say Y here to compile support for HCI over NXP 88W8997 into the
+          kernel or say M to compile as a module.
+
 endmenu
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index 1a58a3ae142c..cba31490a343 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -46,3 +46,5 @@ hci_uart-$(CONFIG_BT_HCIUART_QCA)	+= hci_qca.o
 hci_uart-$(CONFIG_BT_HCIUART_AG6XX)	+= hci_ag6xx.o
 hci_uart-$(CONFIG_BT_HCIUART_MRVL)	+= hci_mrvl.o
 hci_uart-objs				:= $(hci_uart-y)
+
+obj-$(CONFIG_MBTEX_8997)        += mbtex_8997/
diff --git a/drivers/bluetooth/mbtex_8997/Makefile b/drivers/bluetooth/mbtex_8997/Makefile
new file mode 100755
index 000000000000..daf600019a77
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/Makefile
@@ -0,0 +1,188 @@
+# File: Makefile
+# Copyright 2014-2020 NXP
+#
+
+COMPATDIR=/lib/modules/$(KERNELVERSION_X86)/build/compat-wireless-3.2-rc1-1/include
+ifeq ($(CC),)
+CC=		$(CROSS_COMPILE)gcc -I$(COMPATDIR)
+endif
+ifeq ($(LD),)
+LD=		$(CROSS_COMPILE)ld
+endif
+BACKUP=		/root/backup
+YMD=		`date +%Y%m%d%H%M`
+
+#############################################################################
+# Configuration Options
+#############################################################################
+
+# Debug Option
+# DEBUG LEVEL n/1/2:
+# n: NO DEBUG
+# 1: PRINTM(MSG,...), PRINTM(FATAL,...), PRINTM(WARN,...) and PRINTM(INFO,...)
+# 2: All PRINTM()
+CONFIG_DEBUG=1
+
+
+# SDIO suspend/resume
+CONFIG_SDIO_SUSPEND_RESUME=y
+
+
+
+
+#############################################################################
+# Select Platform Tools
+#############################################################################
+
+MODEXT = ko
+
+ifeq ($(CONFIG_64BIT), y)
+	EXTRA_CFLAGS += -DMBT_64BIT
+endif
+
+ifeq ($(CONFIG_T50), y)
+        EXTRA_CFLAGS += -DT50
+        EXTRA_CFLAGS += -DT40
+        EXTRA_CFLAGS += -DT3T
+endif
+
+ifeq ($(CONFIG_BLE_WAKEUP), y)
+        EXTRA_CFLAGS += -DBLE_WAKEUP
+endif
+
+
+
+
+
+
+
+
+KERNELVERSION_X86 := 	$(shell uname -r)
+KERNELDIR?=/lib/modules/$(KERNELVERSION_X86)/build
+
+EXTRA_CFLAGS += -I$(KERNELDIR)/include
+
+EXTRA_CFLAGS += -I$(M)/bt
+LD += -S
+
+#ifdef SD8xxx
+BINDIR = ../bin_sd8xxx_bt
+#endif
+BINDIR = ../bin_sd8997_bt
+
+
+#############################################################################
+# Compiler Flags
+#############################################################################
+	EXTRA_CFLAGS += -DFPNUM='"26"'
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+ifeq ($(CONFIG_DEBUG),2)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+	DBG=	-dbg
+endif
+
+ifeq ($(CONFIG_SDIO_SUSPEND_RESUME),y)
+	EXTRA_CFLAGS += -DSDIO_SUSPEND_RESUME
+endif
+
+#############################################################################
+# Make Targets
+#############################################################################
+
+ifneq ($(KERNELRELEASE),)
+
+BTOBJS = bt/bt_main.o bt/bt_sdiommc.o bt/bt_proc.o bt/mbt_char.o
+
+
+BTOBJS += bt/bt_init.o
+
+ifeq ($(CONFIG_CONCURRENT_DRIVER), y)
+obj-m := bt8xxx_sdio.o
+bt8xxx_sdio-objs := $(BTOBJS)
+else
+obj-m := bt8xxx.o
+bt8xxx-objs := $(BTOBJS)
+endif
+
+
+# Otherwise we were called directly from the command line; invoke the kernel build system.
+else
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+endif
+
+###############################################################
+
+export		CC LD EXTRA_CFLAGS KERNELDIR
+
+.PHONY: app/fm_app clean distclean
+
+app/fm_app:
+	$(MAKE) -C  $@
+
+echo:
+
+build:		echo default
+
+	@if [ ! -d $(BINDIR) ]; then \
+		mkdir $(BINDIR); \
+	fi
+
+ifeq ($(CONFIG_CONCURRENT_DRIVER), y)
+	cp -f bt8xxx_sdio.$(MODEXT) $(BINDIR)/bt8997_sdio$(DBG).$(MODEXT)
+else
+	cp -f bt8xxx.$(MODEXT) $(BINDIR)/bt8997$(DBG).$(MODEXT)
+endif
+	cp -r config $(BINDIR)
+
+
+
+
+	cp -f script/sdio_mmc/* $(BINDIR)/
+
+	cp -f README $(BINDIR)
+
+	$(MAKE) -C app/fm_app $@ INSTALLDIR=$(BINDIR);
+	cp -f app/fm_app/fmapp $(BINDIR);
+
+clean:
+	-find . -name "*.o" -exec rm {} \;
+	-find . -name "*.ko" -exec rm {} \;
+	-find . -name ".*.cmd" -exec rm {} \;
+	-find . -name "*.mod.c" -exec rm {} \;
+	-find . -name "*.symvers" -exec rm {} \;
+	-find . -name "modules.order" -exec rm {} \;
+	-find . -name ".*.dwo" -exec rm {} \;
+	-find . -name "*dwo" -exec rm {} \;
+	-rm -rf .tmp_versions
+	$(MAKE) -C app/fm_app $@
+
+install: default
+
+modules_install:
+	@echo "kernel module install"
+	$(MAKE) INSTALL_MOD_STRIP=1 INSTALL_MOD_PATH=$(MODLIB) INSTALL_MOD_DIR=extra -C $(KERNELDIR) M=$(PWD) modules_install
+
+distclean:
+	-find . -name "*.o" -exec rm {} \;
+	-find . -name "*.orig" -exec rm {} \;
+	-find . -name "*.swp" -exec rm {} \;
+	-find . -name "*.*~" -exec rm {} \;
+	-find . -name "*~" -exec rm {} \;
+	-find . -name "*.d" -exec rm {} \;
+	-find . -name "*.a" -exec rm {} \;
+	-find . -name "tags" -exec rm {} \;
+	-find . -name ".*" -exec rm -rf 2> /dev/null \;
+	-find . -name "*.ko" -exec rm {} \;
+	-find . -name ".*.cmd" -exec rm {} \;
+	-find . -name "*.mod.c" -exec rm {} \;
+	-find . -name ".*.dwo" -exec rm {} \;
+	-find . -name "*dwo" -exec rm {} \;
+	-rm -rf .tmp_versions
+	$(MAKE) -C app/fm_app $@
+# End of file;
diff --git a/drivers/bluetooth/mbtex_8997/README b/drivers/bluetooth/mbtex_8997/README
new file mode 100755
index 000000000000..1b73c3506fa0
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/README
@@ -0,0 +1,236 @@
+===============================================================================
+			U S E R  M A N U A L
+
+ Copyright 2014-2020 NXP
+
+ This software file (the File) is distributed by NXP
+ under the terms of the GNU General Public License Version 2, June 1991
+ (the License).  You may use, redistribute and/or modify the File in
+ accordance with the terms and conditions of the License, a copy of which
+ is available by writing to the Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+
+ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ this warranty disclaimer.
+
+
+===============================================================================
+
+1) FOR DRIVER BUILD
+
+	Goto source code directory mbt_src/.
+		make [clean] build
+	The driver binary can be found in ../bin_xxxx_bt directory.
+	The driver code supports Linux kernel from 2.6.32 to 5.5.2.
+
+2) FOR DRIVER INSTALL
+
+	a) Copy sd8787.bin | ... to /lib/firmware/nxp/ directory,
+	   create the directory if it doesn't exist.
+	b) Install bluetooth driver,
+		insmod bt8787.ko | mbt8787.ko | ... [fw_name=nxp/sd8xxx.bin]
+	c) Uninstall bluetooth driver,
+		hciconfig hciX down
+		rmmod bt8xxx | mbt8xxx
+
+	There are some other parameters for debugging purpose etc. Use modinfo to check details.
+	  The bit settings of drv_mode are,
+		Bit 0: BT/AMP/BLE
+	  mbt_drvdbg=<bit mask of driver debug message control>
+	  psmode=1|0 <enable PS mode (default) | disable PS mode>
+	  dts_enable=1|0 <Disable DTS | Enable DTS (default)>
+	  bt_name=<BT interface name>
+	  mbt_pm_keep_power=1|0 <PM keep power in suspend (default) | PM no power in suspend>
+	  fw=0|other <Skip firmware download | Download firmware (default)>
+	  bt_req_fw_nowait=0|1 <use request_firmware API (default) | use request_firmware_nowait API>
+	  init_cfg=<init config (MAC addresses, registers etc.) file name>
+		e.g. copy bt_init_cfg.conf to firmware directory, init_cfg=nxp/bt_init_cfg.conf
+      bt_mac=xx:xx:xx:xx:xx:xx <override the MAC address (in hex)>
+      cal_cfg=<BT CAL data config file name>
+		e.g. copy bt_cal_data.conf to firmware directory, cal_cfg=nxp/bt_cal_data.conf
+      cal_cfg_ext=<CAL data config file name>
+		e.g. copy cal_data.conf to firmware directory, cal_cfg_ext=nxp/cal_data.conf
+      init_cmds=<init commands config file name>
+		e.g. copy bt_init_cmds.conf to firmware directory, init_cmds=nxp/bt_init_cmds.conf
+
+	  bt_fw_serial=0|1 <Support parallel download FW | Support serial download FW (default)>
+
+	btindrst = Independent reset configuration; high byte:GPIOpin;low byte:MODE
+
+	<MODE> :
+		0x00 : disable independent reset
+		0x01 : enable out-band gpio independent reset.
+		0x02 : enable in-band independent reset
+	<GPIOpin> :
+		0xFF : default GPIO pins will be used. Currently for BT it is GPIO[15].
+		0xXX : specified GPIO pin number will be used for out-band reset.
+
+	Example:
+		btindrst=0x0e01        : outband-reset, gpio pin 14
+		btindrst=0xff01        : outband-reset, use firmware default GPIO pin
+
+	Note: On some platforms (e.g. PXA910/920) double quotation marks ("") need to used
+	for module parameters.
+		insmod bt8xxx.ko "<para1> <para2> ..."
+
+3) cat /proc/mbt/hcix/status
+	This command is used to get driver status.
+
+4) cat /proc/mbt/hcix/config
+	This command is used to get the current driver settings.
+
+5) proc commands to config bluetooth parameters
+
+mbt_drvdbg=[n]
+	This command is used to set the bit mask of driver debug message control.
+
+	bit 0:  MSG  		PRINTM(MSG,...)
+	bit 1:  FATAL		PRINTM(FATAL,...)
+	bit 2:  ERROR		PRINTM(ERROR,...)
+	bit 3:  DATA 		PRINTM(DATA,...)
+	bit 4:  CMD  		PRINTM(CMD,...)
+	bit 5:  EVENT		PRINTM(EVENT,...)
+	bit 6:  INTR		PRINTM(INTR,...)
+	...
+	bit 16: DAT_D		PRINTM(DAT_D,...), DBG_HEXDUMP(DAT_D,...)
+	bit 17: CMD_D		PRINTM(CMD_D,...), DBG_HEXDUMP(CMD_D,...)
+	...
+	bit 28: ENTRY		PRINTM(ENTRY,...), ENTER(), LEAVE()
+	bit 29: WARN 		PRINTM(WARN,...)
+	bit 30: INFO 		PRINTM(INFO,...)
+
+	Usage:
+		echo "drvdbg=0x7" > /proc/mbt/hcix/config		#enable MSG,FATAL,ERROR messages
+
+gpio_gap=[n]
+	This command is used to configure the host sleep parameters.
+
+	bit 8:0  -- Gap
+	bit 16:8 -- GPIO
+	where GPIO is the pin number of GPIO used to wakeup the host. It could be any valid
+		GPIO pin# (e.g. 0-7) or 0xff (Interface, e.g. SDIO will be used instead).
+	where Gap is the gap in milliseconds between wakeup signal and wakeup event
+		or 0xff for special setting when GPIO is used to wakeup host.
+
+	Usage:
+		echo "gpio_gap=0xff80" > /proc/mbt/hcix/config   	# use Interface (e.g. SDIO)
+		echo "hscfgcmd=1" > /proc/mbt/hcix/config		# gap = 0x80
+
+		echo "gpio_gap=0x03ff" > /proc/mbt/hcix/config   	# use gpio 3
+		echo "hscfgcmd=1" > /proc/mbt/hcix/config		# and special host sleep mode
+
+psmode=[n]
+	This command is used to enable/disable auto sleep mode
+
+	where the option is:
+			1 	-- Enable auto sleep mode
+			0 	-- Disable auto sleep mode
+
+	Usage:
+		echo "psmode=1" > /proc/mbt/hcix/config			#enable power save mode
+		echo "idle_timeout=0x0100" > /proc/mbt/hcix/config		#configure idle, timeout value in ms
+		echo "pscmd=1" > /proc/mbt/hcix/config
+
+		echo "psmode=0" > /proc/mbt/hcix/config			#disable power save mode
+		echo "pscmd=1" > /proc/mbt/hcix/config
+
+sdio_pull_cfg=[n]
+	This command is used to configure the delay values for pull up and pull down the SDIO lines.
+
+   	where value is:
+	        bit 15:0  -- Pull up delay in microsecond
+	        bit 31:16 -- Pull down delay in microsecond
+	        0xffff disables PullUp and PullDown in BT controller
+
+	Usage:
+		echo "sdio_pull_cfg=0x00020002" > /proc/mbt/hcix/config   	# Enable sdio pull control
+		echo "sdio_pull_ctrl=1" > /proc/mbt/hcix/config             # configure sdio pull up delay to 2 microseconds
+                                                                    # configure sdio pull down delay to 2 microseconds
+
+		echo "sdio_pull_cfg=0xffffffff" > /proc/mbt/hcix/config   	# Disable sdio pull control
+		echo "sdio_pull_ctrl=1" > /proc/mbt/hcix/config
+
+6) Use hcitool to issue raw hci command, refer to hcitool manual
+
+	Usage: Hcitool cmd <ogf> <ocf> [Parameters]
+
+	1.Interface Control Command
+	  hcitool cmd 0x3f 0x5b 0xf5 0x01 0x00    --Enable All interface
+	  hcitool cmd 0x3f 0x5b 0xf5 0x01 0x01    --Enable Wlan interface
+	  hcitool cmd 0x3f 0x5b 0xf5 0x01 0x02    --Enable BT interface
+	  hcitool cmd 0x3f 0x5b 0xf5 0x00 0x00    --Disable All interface
+	  hcitool cmd 0x3f 0x5b 0xf5 0x00 0x01    --Disable Wlan interface
+	  hcitool cmd 0x3f 0x5b 0xf5 0x00 0x02    --Disable BT interface
+
+7) cat /proc/mbt/hcix/debug
+	This command is used to get driver debug parameters.
+
+8) proc command to config debug parameters
+
+sdcmd52rw=<func> <reg> [data]
+	This command is used to read/write a controller register in
+	Secure Digital I/O Interfaces.
+
+	func: The function number to use (0-7)
+	reg:  The address of the register
+	data: The value to write, read if the value is absent
+
+	For SDIO MMC driver, only function 0 and BT function (2/3) access is allowed.
+	And there is a limitation for function 0 write, only vendor specific CCCR
+	registers (0xf0 -0xff) are permiited.
+
+	Usage:
+		echo "sdcmd52rw= 2 3 0xf" > /proc/mbt/hcix/debug	# write 0xf to func 2 address 3
+		echo "sdcmd52rw= 0 4" > /proc/mbt/hcix/debug    	# read func 0 address 4
+
+Issue debug_dump command through proc.
+	Usage:
+		echo "debug_dump" > /proc/mbt/hcix/debug		# dump driver internal debug status.
+	Use dmesg or cat /var/log/debug to check driver debug messages.
+
+proc command to enable BT test mode
+    Usage:
+        echo "test_mode=1" > /proc/mbt/hcix/config       #enable BT test mode
+
+FOR FW RELOAD
+    a) Enable parallel firmware download in driver parameter
+       insmod bt8xxx.ko fw_serail=0
+
+    b) default fw name for parallel firmware download
+       sd8887_bt_a2.bin
+
+    c) Trigger FW reload
+	echo "fw_reload=1" > /proc/mbt/mbtcharx/debug		    # start inband reset and fw reload
+	echo "fw_reload=2" > /proc/mbt/mbtcharx/debug		    # start fw reload
+
+    (Note: This feature should works on SD8977/SD8978/SD8997 board,
+           For CAC-A2 board, only works on the board which supports parallel fw download)
+
+
+==============================================================================
+			U S E R  M A N U A L  F O R  F M A P P
+
+1) FOR TOOL BUILD
+
+	a) Enter directory
+	b) make
+	c) After building, the executable binary "fmapp" is in the directory
+
+2) FOR TOOL RUN
+
+	a) chmod 777 fmapp (optional)
+	b) Run fmapp utility based on usage below
+		Usage: fmapp <Options> devicename ogf ocf [command content]
+		devicename example: mfmchar0 /mnfccahr0
+		FM ogf/ocf example: 0x3f 0x280
+		NFC ogf/ocf example: 0x3f 0x281
+	Options:
+		-h: Display help
+		-v: Verbose
+
+3) TEST EXAMPLES
+    ./fmapp mfmchar0 0x3f 0x280 0x01 0x01
+    ./fmapp mnfcchar0 0x3f 0x281 0x20 0x00 0x01 0x01
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_drv.h b/drivers/bluetooth/mbtex_8997/bt/bt_drv.h
new file mode 100755
index 000000000000..fa53cc3306be
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_drv.h
@@ -0,0 +1,972 @@
+/** @file bt_drv.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_DRV_H_
+#define _BT_DRV_H_
+
+#include <linux/version.h>
+#include <linux/kthread.h>
+#include <linux/skbuff.h>
+#include <linux/vmalloc.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+#include <linux/ktime.h>
+#endif
+
+#include "hci_wrapper.h"
+
+/** MAX adapter BT driver supported */
+#define MAX_BT_ADAPTER    3
+
+#ifndef BIT
+/** BIT definition */
+#define BIT(x) (1UL << (x))
+#endif
+
+#ifdef MBT_64BIT
+typedef u64 t_ptr;
+#else
+typedef u32 t_ptr;
+#endif
+
+/** max number of adapter supported */
+#define MAX_BT_ADAPTER      3
+/** Define drv_mode bit */
+#define DRV_MODE_BT         BIT(0)
+
+/** Define devFeature bit */
+#define DEV_FEATURE_BT     BIT(0)
+#define DEV_FEATURE_BTAMP     BIT(1)
+#define DEV_FEATURE_BLE     BIT(2)
+
+/** Define maximum number of radio func supported */
+#define MAX_RADIO_FUNC     3
+
+/** MAC address print format */
+#ifndef MACSTR
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+
+/** MAC address print arguments */
+#ifndef MAC2STR
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#endif
+
+/** Debug level : Message */
+#define	DBG_MSG			BIT(0)
+/** Debug level : Fatal */
+#define DBG_FATAL		BIT(1)
+/** Debug level : Error */
+#define DBG_ERROR		BIT(2)
+/** Debug level : Data */
+#define DBG_DATA		BIT(3)
+/** Debug level : Command */
+#define DBG_CMD			BIT(4)
+/** Debug level : Event */
+#define DBG_EVENT		BIT(5)
+/** Debug level : Interrupt */
+#define DBG_INTR		BIT(6)
+
+/** Debug entry : Data dump */
+#define DBG_DAT_D		BIT(16)
+/** Debug entry : Data dump */
+#define DBG_CMD_D		BIT(17)
+
+/** Debug level : Entry */
+#define DBG_ENTRY		BIT(28)
+/** Debug level : Warning */
+#define DBG_WARN		BIT(29)
+/** Debug level : Informative */
+#define DBG_INFO		BIT(30)
+
+#ifdef	DEBUG_LEVEL1
+extern u32 mbt_drvdbg;
+
+#ifdef	DEBUG_LEVEL2
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  \
+	do {if (mbt_drvdbg & DBG_INFO)  \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print warning message */
+#define	PRINTM_WARN(msg...) \
+	do {if (mbt_drvdbg & DBG_WARN)  \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) \
+	do {if (mbt_drvdbg & DBG_ENTRY) \
+		printk(KERN_DEBUG msg); } while (0)
+#else
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  do {} while (0)
+/** Print warning message */
+#define	PRINTM_WARN(msg...)  do {} while (0)
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) do {} while (0)
+#endif /* DEBUG_LEVEL2 */
+
+/** Print interrupt message */
+#define	PRINTM_INTR(msg...)  \
+	do {if (mbt_drvdbg & DBG_INTR)  \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print event message */
+#define	PRINTM_EVENT(msg...) \
+	do {if (mbt_drvdbg & DBG_EVENT) \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print command message */
+#define	PRINTM_CMD(msg...)   \
+	do {if (mbt_drvdbg & DBG_CMD)   \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print data message */
+#define	PRINTM_DATA(msg...)  \
+	do {if (mbt_drvdbg & DBG_DATA)  \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print error message */
+#define	PRINTM_ERROR(msg...) \
+	do {if (mbt_drvdbg & DBG_ERROR) \
+		printk(KERN_ERR msg); } while (0)
+/** Print fatal message */
+#define	PRINTM_FATAL(msg...) \
+	do {if (mbt_drvdbg & DBG_FATAL) \
+		printk(KERN_ERR msg); } while (0)
+/** Print message */
+#define	PRINTM_MSG(msg...)   \
+	do {if (mbt_drvdbg & DBG_MSG)   \
+		printk(KERN_ALERT msg); } while (0)
+
+/** Print data dump message */
+#define	PRINTM_DAT_D(msg...)  \
+	do {if (mbt_drvdbg & DBG_DAT_D)  \
+		printk(KERN_DEBUG msg); } while (0)
+/** Print data dump message */
+#define	PRINTM_CMD_D(msg...)  \
+	do {if (mbt_drvdbg & DBG_CMD_D)  \
+		printk(KERN_DEBUG msg); } while (0)
+
+/** Print message with required level */
+#define	PRINTM(level, msg...) PRINTM_##level(msg)
+
+/** Debug dump buffer length */
+#define DBG_DUMP_BUF_LEN	64
+/** Maximum number of dump per line */
+#define MAX_DUMP_PER_LINE	16
+/** Maximum data dump length */
+#define MAX_DATA_DUMP_LEN	48
+
+/**
+ * @brief Prints buffer data upto provided length
+ *
+ * @param prompt          Char pointer
+ * @param buf			  Buffer
+ * @param len    		  Length
+ *
+ * @return                N/A
+ */
+static inline void
+hexdump(char *prompt, u8 *buf, int len)
+{
+	int i;
+	char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+	char *ptr = dbgdumpbuf;
+
+	printk(KERN_DEBUG "%s: len=%d\n", prompt, len);
+	for (i = 1; i <= len; i++) {
+		ptr += snprintf(ptr, 4, "%02x ", *buf);
+		buf++;
+		if (i % MAX_DUMP_PER_LINE == 0) {
+			*ptr = 0;
+			printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+			ptr = dbgdumpbuf;
+		}
+	}
+	if (len % MAX_DUMP_PER_LINE) {
+		*ptr = 0;
+		printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+	}
+}
+
+/** Debug hexdump of debug data */
+#define DBG_HEXDUMP_DAT_D(x, y, z) \
+	do {if (mbt_drvdbg & DBG_DAT_D) \
+		hexdump(x, y, z); } while (0)
+/** Debug hexdump of debug command */
+#define DBG_HEXDUMP_CMD_D(x, y, z) \
+	do {if (mbt_drvdbg & DBG_CMD_D) \
+		hexdump(x, y, z); } while (0)
+
+/** Debug hexdump */
+#define	DBG_HEXDUMP(level, x, y, z)    DBG_HEXDUMP_##level(x, y, z)
+
+/** Mark entry point */
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __func__, \
+							__FILE__, __LINE__)
+/** Mark exit point */
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __func__, \
+							__FILE__, __LINE__)
+#else
+/** Do nothing */
+#define	PRINTM(level, msg...) do {} while (0)
+/** Do nothing */
+#define DBG_HEXDUMP(level, x, y, z)    do {} while (0)
+/** Do nothing */
+#define	ENTER()  do {} while (0)
+/** Do nothing */
+#define	LEAVE()  do {} while (0)
+#endif /* DEBUG_LEVEL1 */
+
+/** Bluetooth upload size */
+#define	BT_UPLD_SIZE				2312
+/** Bluetooth status success */
+#define BT_STATUS_SUCCESS			(0)
+/** Bluetooth status pending */
+#define BT_STATUS_PENDING           (1)
+/** Bluetooth status failure */
+#define BT_STATUS_FAILURE			(-1)
+
+#ifndef	TRUE
+/** True value */
+#define TRUE			1
+#endif
+#ifndef	FALSE
+/** False value */
+#define	FALSE			0
+#endif
+
+/** Set thread state */
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+/** Time to wait until Host Sleep state change in millisecond */
+#define WAIT_UNTIL_HS_STATE_CHANGED 2000
+/** Time to wait cmd resp in millisecond */
+#define WAIT_UNTIL_CMD_RESP	    5000
+
+/** Sleep until a condition gets true or a timeout elapses */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	interruptible_sleep_on_timeout(&waitq, ((timeout) * HZ / 1000))
+#else
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, ((timeout) * HZ / 1000))
+#endif
+
+#define os_wait_timeout(waitq, cond, timeout) \
+         wait_event_timeout(waitq, cond, ((timeout) * HZ / 1000))
+
+/** bt thread structure */
+typedef struct {
+	/** Task */
+	struct task_struct *task;
+	/** Queue */
+	wait_queue_head_t waitQ;
+	/** PID */
+	pid_t pid;
+	/** Private structure */
+	void *priv;
+} bt_thread;
+
+/**
+ * @brief Activates bt thread
+ *
+ * @param thr			  A pointer to bt_thread structure
+ *
+ * @return                N/A
+ */
+static inline void
+bt_activate_thread(bt_thread *thr)
+{
+	/** Initialize the wait queue */
+	init_waitqueue_head(&thr->waitQ);
+
+	/** Record the thread pid */
+	thr->pid = current->pid;
+}
+
+/**
+ * @brief De-activates bt thread
+ *
+ * @param thr			  A pointer to bt_thread structure
+ *
+ * @return                N/A
+ */
+static inline void
+bt_deactivate_thread(bt_thread *thr)
+{
+	thr->pid = 0;
+	return;
+}
+
+/**
+ * @brief Creates bt thread
+ *
+ * @param btfunc          Function pointer
+ * @param thr			  A pointer to bt_thread structure
+ * @param name    		  Char pointer
+ *
+ * @return                N/A
+ */
+static inline void
+bt_create_thread(int (*btfunc) (void *), bt_thread *thr, char *name)
+{
+	thr->task = kthread_run(btfunc, thr, "%s", name);
+}
+
+/**
+ * @brief Delete bt thread
+ *
+ * @param thr			  A pointer to bt_thread structure
+ *
+ * @return                N/A
+ */
+static inline int
+bt_terminate_thread(bt_thread *thr)
+{
+	/* Check if the thread is active or not */
+	if (!thr->pid)
+		return -1;
+
+	kthread_stop(thr->task);
+	return 0;
+}
+
+/**
+ * @brief  Set scheduled timeout
+ *
+ * @param millisec		 Time unit in ms
+ *
+ * @return                N/A
+ */
+static inline void
+os_sched_timeout(u32 millisec)
+{
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	schedule_timeout((millisec * HZ) / 1000);
+}
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__((packed))
+#endif
+
+/** BT histogram command */
+#define BT_CMD_HISTOGRAM            0xEA
+/** max antenna num */
+#define MAX_ANTENNA_NUM             2
+/** BDR 1M */
+#define BDR_RATE_1M					1
+/** EDR 2/3 M */
+#define EDR_RATE_2_3M			    2
+/** BLE 1M */
+#define BLE_RATE_1M                 5
+/** max bt link number */
+#define MAX_BT_LINK                 10
+/** max ble link number */
+#define MAX_BLE_LINK                16
+
+/** BT link state structure */
+typedef struct _bt_link_stat {
+    /** txrx rate 1: BDR_1M, 2:EDR 2/3 M, 3:BLE 1M */
+	u8 txrxrate;
+    /** power: -30 = N = 20 dbm*/
+	s8 txpower;
+    /** rssi: -127 to +20 (For BT), -128 to +127 (For BLE) */
+	s8 rssi;
+} __ATTRIB_PACK__ bt_link_stat;
+
+/** BT histogram data structure */
+typedef struct _bt_histogram_data {
+	/** Antenna */
+	u8 antenna;
+	/** Powerclass */
+	u8 powerclass;
+	/** bt link state structure */
+	bt_link_stat link[MAX_BT_LINK + MAX_BLE_LINK];
+} __ATTRIB_PACK__ bt_histogram_data;
+
+/** BT histogram proc data structure */
+typedef struct _bt_hist_proc_data {
+    /** antenna */
+	u8 antenna;
+	/** Private structure */
+	struct _bt_private *pbt;
+} bt_hist_proc_data;
+
+/** Data structure for the NXP Bluetooth device */
+typedef struct _bt_dev {
+	/** device name */
+	char name[DEV_NAME_LEN];
+	/** card pointer */
+	void *card;
+	/** IO port */
+	u32 ioport;
+	/** m_dev structure */
+	struct m_dev m_dev[MAX_RADIO_FUNC];
+
+	/** Tx download ready flag */
+	u8 tx_dnld_rdy;
+	/** Function */
+	u8 fn;
+	/** Rx unit */
+	u8 rx_unit;
+	/** Power Save mode : Timeout configuration */
+	u16 idle_timeout;
+	/** Power Save mode */
+	u8 psmode;
+	/** Power Save command */
+	u8 pscmd;
+	/** Host Sleep mode */
+	u8 hsmode;
+	/** Host Sleep command */
+	u8 hscmd;
+	/** Low byte is gap, high byte is GPIO */
+	u16 gpio_gap;
+	/** Host Sleep configuration command */
+	u8 hscfgcmd;
+	/** Host Send Cmd Flag		 */
+	u8 sendcmdflag;
+	/** opcode for Send Cmd */
+	u16 send_cmd_opcode;
+	/** Device Type			*/
+	u8 devType;
+	/** Device Features    */
+	u8 devFeature;
+	/** cmd52 function */
+	u8 cmd52_func;
+	/** cmd52 register */
+	u8 cmd52_reg;
+	/** cmd52 value */
+	u8 cmd52_val;
+	/** SDIO pull control command */
+	u8 sdio_pull_ctrl;
+	/** Low 2 bytes is pullUp, high 2 bytes for pull-down */
+	u32 sdio_pull_cfg;
+	/** Test mode command */
+	u8 test_mode;
+} bt_dev_t, *pbt_dev_t;
+
+/** NXP bt adapter structure */
+typedef struct _bt_adapter {
+	/** Chip revision ID */
+	u8 chip_rev;
+    /** magic val */
+	u8 magic_val;
+	/** Surprise removed flag */
+	u8 SurpriseRemoved;
+	/** IRQ number */
+	int irq;
+	/** Interrupt counter */
+	u32 IntCounter;
+	/** Tx packet queue */
+	struct sk_buff_head tx_queue;
+
+	/** Pointer of fw dump file name */
+	char *fwdump_fname;
+	/** Pending Tx packet queue */
+	struct sk_buff_head pending_queue;
+	/** tx lock flag */
+	u8 tx_lock;
+	/** Power Save mode */
+	u8 psmode;
+	/** Power Save state */
+	u8 ps_state;
+	/** Host Sleep state */
+	u8 hs_state;
+	/** hs skip count */
+	u32 hs_skip;
+	/** suspend_fail flag */
+	u8 suspend_fail;
+	/** suspended flag */
+	u8 is_suspended;
+	/** Number of wakeup tries */
+	u8 WakeupTries;
+	/** Host Sleep wait queue */
+	wait_queue_head_t cmd_wait_q __ATTRIB_ALIGN__;
+	/** Host Cmd complet state */
+	u8 cmd_complete;
+	/** indicate using wait event timeout */
+	u8 wait_event_timeout;
+	/** last irq recv */
+	u8 irq_recv;
+	/** last irq processed */
+	u8 irq_done;
+	/** sdio int status */
+	u8 sd_ireg;
+     /** buf allocated for transmit */
+	u8 *tx_buffer;
+    /** buf for transmit */
+	u8 *tx_buf;
+    /** buf allocated for read interrupt status */
+	u8 *hw_regs_buf;
+    /** buf for read interrupt status */
+	u8 *hw_regs;
+	/** tx pending */
+	u32 skb_pending;
+/** Version string buffer length */
+#define MAX_VER_STR_LEN         128
+	/** Driver version */
+	u8 drv_ver[MAX_VER_STR_LEN];
+	/** Number of command timeout */
+	u32 num_cmd_timeout;
+} bt_adapter, *pbt_adapter;
+
+/** Length of prov name */
+#define PROC_NAME_LEN				32
+
+/** Item data structure */
+struct item_data {
+	/** Name */
+	char name[PROC_NAME_LEN];
+	/** Size */
+	u32 size;
+	/** Address */
+	t_ptr addr;
+	/** Offset */
+	u32 offset;
+	/** Flag */
+	u32 flag;
+};
+
+/** Proc private data structure */
+struct proc_private_data {
+	/** Name */
+	char name[PROC_NAME_LEN];
+	/** File flag */
+	u32 fileflag;
+	/** Buffer size */
+	u32 bufsize;
+	/** Number of items */
+	u32 num_items;
+	/** Item data */
+	struct item_data *pdata;
+	/** Private structure */
+	struct _bt_private *pbt;
+	/** File operations */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	const struct proc_ops *fops;
+#else
+	const struct file_operations *fops;
+#endif
+};
+
+/** Device proc structure */
+struct device_proc {
+	/** Proc directory entry */
+	struct proc_dir_entry *proc_entry;
+    /** proc entry for hist */
+	struct proc_dir_entry *hist_entry;
+	/** num of proc files */
+	u8 num_proc_files;
+	/** pointer to proc_private_data */
+	struct proc_private_data *pfiles;
+};
+
+/** Private structure for the MV device */
+typedef struct _bt_private {
+	/** Bluetooth device */
+	bt_dev_t bt_dev;
+	/** Adapter */
+	bt_adapter *adapter;
+	/** Firmware helper */
+	const struct firmware *fw_helper;
+	/** Firmware */
+	const struct firmware *firmware;
+	/** Init user configure file */
+	const struct firmware *init_user_cfg;
+	/** Init user configure wait queue token */
+	u16 init_user_conf_wait_flag;
+	/** Init user configure file wait queue */
+	wait_queue_head_t init_user_conf_wait_q __ATTRIB_ALIGN__;
+	/** Firmware request start time */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	struct __kernel_old_timeval req_fw_time;
+#else
+	struct timeval req_fw_time;
+#endif
+	/** Hotplug device */
+	struct device *hotplug_device;
+	/** thread to service interrupts */
+	bt_thread MainThread;
+	 /** proc data */
+	struct device_proc dev_proc[MAX_RADIO_FUNC];
+	/** Driver lock */
+	spinlock_t driver_lock;
+	/** Driver lock flags */
+	ulong driver_flags;
+	/** Driver reference flags */
+	struct kobject kobj;
+	u8 fw_reload;
+	/* hist_data_len */
+	u8 hist_data_len;
+    /** hist data */
+	bt_histogram_data hist_data[MAX_ANTENNA_NUM];
+    /** hist proc data */
+	bt_hist_proc_data hist_proc[MAX_ANTENNA_NUM];
+    /** fw dump state */
+	u8 fw_dump;
+} bt_private, *pbt_private;
+
+int bt_get_histogram(bt_private *priv);
+
+/** Disable interrupt */
+#define OS_INT_DISABLE	spin_lock_irqsave(&priv->driver_lock, \
+						priv->driver_flags)
+/** Enable interrupt */
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&priv->driver_lock, \
+						priv->driver_flags)
+
+#ifndef HCI_BT_AMP
+/** BT_AMP flag for device type */
+#define  HCI_BT_AMP		0x80
+#endif
+
+/** Device type of BT */
+#define DEV_TYPE_BT		0x00
+/** Device type of AMP */
+#define DEV_TYPE_AMP		0x01
+
+/** NXP vendor packet */
+#define MRVL_VENDOR_PKT			0xFE
+
+/** Bluetooth command : Get FW Version */
+#define BT_CMD_GET_FW_VERSION       0x0F
+/** Bluetooth command : Sleep mode */
+#define BT_CMD_AUTO_SLEEP_MODE		0x23
+/** Bluetooth command : Host Sleep configuration */
+#define BT_CMD_HOST_SLEEP_CONFIG	0x59
+/** Bluetooth command : Host Sleep enable */
+#define BT_CMD_HOST_SLEEP_ENABLE	0x5A
+/** Bluetooth command : Module Configuration request */
+#define BT_CMD_MODULE_CFG_REQ		0x5B
+/** Bluetooth command : PMIC Configure */
+#define BT_CMD_PMIC_CONFIGURE           0x7D
+
+/** Bluetooth command : SDIO pull up down configuration request */
+#define BT_CMD_SDIO_PULL_CFG_REQ	0x69
+/** Bluetooth command : Set Evt Filter Command */
+#define BT_CMD_SET_EVT_FILTER		0x05
+/** Bluetooth command : Enable Write Scan Command */
+#define BT_CMD_ENABLE_WRITE_SCAN	0x1A
+/** Bluetooth command : Enable Device under test mode */
+#define BT_CMD_ENABLE_DEVICE_TESTMODE	0x03
+/** Sub Command: Module Bring Up Request */
+#define MODULE_BRINGUP_REQ		0xF1
+/** Sub Command: Module Shut Down Request */
+#define MODULE_SHUTDOWN_REQ		0xF2
+/** Module already up */
+#define MODULE_CFG_RESP_ALREADY_UP      0x0c
+/** Sub Command: Host Interface Control Request */
+#define MODULE_INTERFACE_CTRL_REQ	0xF5
+
+/** Bluetooth event : Power State */
+#define BT_EVENT_POWER_STATE		0x20
+
+/** Bluetooth Power State : Enable */
+#define BT_PS_ENABLE			0x02
+/** Bluetooth Power State : Disable */
+#define BT_PS_DISABLE			0x03
+/** Bluetooth Power State : Sleep */
+#define BT_PS_SLEEP			0x01
+/** Bluetooth Power State : Awake */
+#define BT_PS_AWAKE			0x02
+
+/** Vendor OGF */
+#define VENDOR_OGF				0x3F
+/** OGF for reset */
+#define RESET_OGF		0x03
+/** Bluetooth command : Reset */
+#define BT_CMD_RESET	0x03
+
+/** Host Sleep activated */
+#define HS_ACTIVATED			0x01
+/** Host Sleep deactivated */
+#define HS_DEACTIVATED			0x00
+
+/** Power Save sleep */
+#define PS_SLEEP			0x01
+/** Power Save awake */
+#define PS_AWAKE			0x00
+
+/** bt header length */
+#define BT_HEADER_LEN			4
+
+#ifndef MAX
+/** Return maximum of two */
+#define MAX(a, b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** This is for firmware specific length */
+#define EXTRA_LEN	36
+
+/** Command buffer size for NXP driver */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+
+/** Bluetooth Rx packet buffer size for NXP driver */
+#define MRVDRV_BT_RX_PACKET_BUFFER_SIZE \
+	(HCI_MAX_FRAME_SIZE + EXTRA_LEN)
+
+/** Buffer size to allocate */
+#define ALLOC_BUF_SIZE	(((MAX(MRVDRV_BT_RX_PACKET_BUFFER_SIZE, \
+			MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+			+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/** Request FW timeout in second */
+#define REQUEST_FW_TIMEOUT		30
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/** The number of times to try when waiting for downloaded firmware to
+    become active when multiple interface is present */
+#define MAX_MULTI_INTERFACE_POLL_TRIES  150
+
+/** The number of times to try when waiting for downloaded firmware to
+     become active. (polling the scratch register). */
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+/** default idle time */
+#define DEFAULT_IDLE_TIME           1000
+
+#define BT_CMD_HEADER_SIZE    3
+
+#define BT_CMD_DATA_LEN    128
+#define BT_EVT_DATA_LEN    8
+
+/** BT command structure */
+typedef struct _BT_CMD {
+	/** OCF OGF */
+	u16 ocf_ogf;
+	/** Length */
+	u8 length;
+	/** Data */
+	u8 data[BT_CMD_DATA_LEN];
+} __ATTRIB_PACK__ BT_CMD;
+
+/** BT event structure */
+typedef struct _BT_EVENT {
+	/** Event Counter */
+	u8 EC;
+	/** Length */
+	u8 length;
+	/** Data */
+	u8 data[BT_EVT_DATA_LEN];
+} BT_EVENT;
+
+#if defined(SDIO_SUSPEND_RESUME)
+#define DEF_GPIO_GAP        0xffff
+#endif
+
+/** This function verify the received event pkt */
+int check_evtpkt(bt_private *priv, struct sk_buff *skb);
+
+/* Prototype of global function */
+/** This function gets the priv reference */
+struct kobject *bt_priv_get(bt_private *priv);
+/** This function release the priv reference */
+void bt_priv_put(bt_private *priv);
+/** This function adds the card */
+bt_private *bt_add_card(void *card);
+/** This function removes the card */
+int bt_remove_card(void *card);
+/** This function handles the interrupt */
+void bt_interrupt(struct m_dev *m_dev);
+
+/** This function creates proc interface directory structure */
+int bt_root_proc_init(void);
+/** This function removes proc interface directory structure */
+int bt_root_proc_remove(void);
+/** This function initializes proc entry */
+int bt_proc_init(bt_private *priv, struct m_dev *m_dev, int seq);
+/** This function removes proc interface */
+void bt_proc_remove(bt_private *priv);
+
+/** This function process the received event */
+int bt_process_event(bt_private *priv, struct sk_buff *skb);
+/** This function enables host sleep */
+int bt_enable_hs(bt_private *priv, bool is_shutdown);
+/** This function used to send command to firmware */
+int bt_prepare_command(bt_private *priv);
+/** This function frees the structure of adapter */
+void bt_free_adapter(bt_private *priv);
+/** This function handle the receive packet */
+void bt_recv_frame(bt_private *priv, struct sk_buff *skb);
+void bt_store_firmware_dump(bt_private *priv, u8 *buf, u32 len);
+
+/** clean up m_devs */
+void clean_up_m_devs(bt_private *priv);
+/** bt driver call this function to register to bus driver */
+int *sbi_register(void);
+/** bt driver call this function to unregister to bus driver */
+void sbi_unregister(void);
+/** bt driver calls this function to register the device  */
+int sbi_register_dev(bt_private *priv);
+/** bt driver calls this function to unregister the device */
+int sbi_unregister_dev(bt_private *priv);
+/** This function initializes firmware */
+int sbi_download_fw(bt_private *priv);
+/** Configures hardware to quit deep sleep state */
+int sbi_wakeup_firmware(bt_private *priv);
+/** Module configuration and register device */
+int sbi_register_conf_dpc(bt_private *priv);
+
+/** This function is used to send the data/cmd to hardware */
+int sbi_host_to_card(bt_private *priv, u8 *payload, u16 nb);
+/** This function reads the current interrupt status register */
+int sbi_get_int_status(bt_private *priv);
+/** This function enables the host interrupts */
+int sbi_enable_host_int(bt_private *priv);
+/** This function disables the host interrupts */
+int sbi_disable_host_int(bt_private *priv);
+
+/** bt fw reload flag */
+extern int bt_fw_reload;
+/** driver initial the fw reset */
+#define FW_RELOAD_SDIO_INBAND_RESET   1
+/** out band reset trigger reset, no interface re-emulation */
+#define FW_RELOAD_NO_EMULATION  2
+/** out band reset with interface re-emulation */
+#define FW_RELOAD_WITH_EMULATION 3
+/** This function reload firmware */
+void bt_request_fw_reload(bt_private *priv, int mode);
+#define MAX_TX_BUF_SIZE     2312
+/** This function downloads firmware image to the card */
+int sd_download_firmware_w_helper(bt_private *priv);
+void bt_dump_sdio_regs(bt_private *priv);
+#define FW_DUMP_TYPE_ENDED                    0x002
+#define FW_DUMP_TYPE_MEM_ITCM                 0x004
+#define FW_DUMP_TYPE_MEM_DTCM                 0x005
+#define FW_DUMP_TYPE_MEM_SQRAM                0x006
+#define FW_DUMP_TYPE_MEM_IRAM                 0x007
+#define FW_DUMP_TYPE_REG_MAC                  0x009
+#define FW_DUMP_TYPE_REG_CIU                  0x00E
+#define FW_DUMP_TYPE_REG_APU                  0x00F
+#define FW_DUMP_TYPE_REG_ICU                  0x014
+/* dumps the firmware to /var/ or /data/ */
+void bt_dump_firmware_info_v2(bt_private *priv);
+
+/** Max line length allowed in init config file */
+#define MAX_LINE_LEN        256
+/** Max MAC address string length allowed */
+#define MAX_MAC_ADDR_LEN    18
+/** Max register type/offset/value etc. parameter length allowed */
+#define MAX_PARAM_LEN       12
+
+/** Bluetooth command : Mac address configuration */
+#define BT_CMD_CONFIG_MAC_ADDR		0x22
+/** Bluetooth command : Write CSU register */
+#define BT_CMD_CSU_WRITE_REG		0x66
+/** Bluetooth command : Load calibrate data */
+#define BT_CMD_LOAD_CONFIG_DATA     0x61
+/** Bluetooth command : Load calibrate ext data */
+#define BT_CMD_LOAD_CONFIG_DATA_EXT     0x60
+
+/** Bluetooth command : BLE deepsleep */
+#define BT_CMD_BLE_DEEP_SLEEP       0x8b
+
+/** BT_BLE command structure */
+typedef struct _BT_BLE_CMD {
+	/** OCF OGF */
+	u16 ocf_ogf;
+	/** Length */
+	u8 length;
+	/** deepsleep flag */
+	u8 deepsleep;
+} __ATTRIB_PACK__ BT_BLE_CMD;
+
+/** BT_CSU command structure */
+typedef struct _BT_CSU_CMD {
+	/** OCF OGF */
+	u16 ocf_ogf;
+	/** Length */
+	u8 length;
+	/** reg type */
+	u8 type;
+	/** address */
+	u8 offset[4];
+	/** Data */
+	u8 value[2];
+} __ATTRIB_PACK__ BT_CSU_CMD;
+
+/** This function sets mac address */
+int bt_set_mac_address(bt_private *priv, u8 *mac);
+/** This function writes value to CSU registers */
+int bt_write_reg(bt_private *priv, u8 type, u32 offset, u16 value);
+/** BT set user defined init data and param */
+int bt_init_config(bt_private *priv, char *cfg_file);
+/** BT set uer defined init commands */
+int bt_init_cmds(bt_private *priv, char *init_cmds_file);
+/** BT process command */
+int bt_process_commands(bt_private *priv, u8 *cmd_data, u32 cmd_len);
+/** BT PMIC Configure command */
+int bt_pmic_configure(bt_private *priv);
+/** This function load the calibrate data */
+int bt_load_cal_data(bt_private *priv, u8 *config_data, u8 *mac);
+/** This function load the calibrate ext data */
+int bt_load_cal_data_ext(bt_private *priv, u8 *config_data, u32 cfg_data_len);
+/** BT set user defined calibration data */
+int bt_cal_config(bt_private *priv, char *cfg_file, char *mac);
+/** BT set user defined calibration ext data */
+int bt_cal_config_ext(bt_private *priv, char *cfg_file);
+int bt_init_mac_address(bt_private *priv, char *mac);
+
+int bt_set_independent_reset(bt_private *priv);
+/** Bluetooth command : Independent reset */
+#define BT_CMD_INDEPENDENT_RESET     0x0D
+
+/** BT HCI command structure */
+typedef struct _BT_HCI_CMD {
+	/** OCF OGF */
+	u16 ocf_ogf;
+	/** Length */
+	u8 length;
+	/** cmd type */
+	u8 cmd_type;
+	/** cmd len */
+	u8 cmd_len;
+	/** Data */
+	u8 data[6];
+} __ATTRIB_PACK__ BT_HCI_CMD;
+
+static inline void
+get_monotonic_time(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	struct __kernel_old_timeval
+#else
+	struct timeval
+#endif
+	*tv)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	struct timespec64 ts;
+	ktime_get_raw_ts64(&ts);
+#else
+	struct timespec ts;
+	getrawmonotonic(&ts);
+#endif
+
+	if (tv) {
+		tv->tv_sec = (u32)ts.tv_sec;
+		tv->tv_usec = (u32)ts.tv_nsec / 1000;
+	}
+}
+
+#endif /* _BT_DRV_H_ */
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_init.c b/drivers/bluetooth/mbtex_8997/bt/bt_init.c
new file mode 100755
index 000000000000..cf9bfc41d46d
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_init.c
@@ -0,0 +1,871 @@
+/** @file bt_init.c
+ *
+ *  @brief This file contains the init functions for BlueTooth
+ *  driver.
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#include <linux/string.h>
+#include <linux/firmware.h>
+
+#include "bt_drv.h"
+
+extern int bt_req_fw_nowait;
+
+#define isxdigit(c)	(('0' <= (c) && (c) <= '9') \
+			 || ('a' <= (c) && (c) <= 'f') \
+			 || ('A' <= (c) && (c) <= 'F'))
+
+#define isdigit(c)	(('0' <= (c) && (c) <= '9'))
+#define isspace(c)  (c <= ' ' && (c == ' ' || (c <= 13 && c >= 9)))
+/**
+ *  @brief Returns hex value of a give character
+ *
+ *  @param chr	Character to be converted
+ *
+ *  @return	The converted character if chr is a valid hex, else 0
+ */
+static int
+bt_hexval(char chr)
+{
+	ENTER();
+
+	if (chr >= '0' && chr <= '9')
+		return chr - '0';
+	if (chr >= 'A' && chr <= 'F')
+		return chr - 'A' + 10;
+	if (chr >= 'a' && chr <= 'f')
+		return chr - 'a' + 10;
+
+	LEAVE();
+	return 0;
+}
+
+/**
+ *  @brief Extension of strsep lib command. This function will also take care
+ *	   escape character
+ *
+ *  @param s         A pointer to array of chars to process
+ *  @param delim     The delimiter character to end the string
+ *  @param esc       The escape character to ignore for delimiter
+ *
+ *  @return          Pointer to the separated string if delim found, else NULL
+ */
+static char *
+bt_strsep(char **s, char delim, char esc)
+{
+	char *se = *s, *sb;
+
+	ENTER();
+
+	if (!(*s) || (*se == '\0')) {
+		LEAVE();
+		return NULL;
+	}
+
+	for (sb = *s; *sb != '\0'; ++sb) {
+		if (*sb == esc && *(sb + 1) == esc) {
+			/*
+			 * We get a esc + esc seq then keep the one esc
+			 * and chop off the other esc character
+			 */
+			memmove(sb, sb + 1, strlen(sb));
+			continue;
+		}
+		if (*sb == esc && *(sb + 1) == delim) {
+			/*
+			 * We get a delim + esc seq then keep the delim
+			 * and chop off the esc character
+			 */
+			memmove(sb, sb + 1, strlen(sb));
+			continue;
+		}
+		if (*sb == delim)
+			break;
+	}
+
+	if (*sb == '\0')
+		sb = NULL;
+	else
+		*sb++ = '\0';
+
+	*s = sb;
+
+	LEAVE();
+	return se;
+}
+
+/**
+ *  @brief Returns hex value of a given ascii string
+ *
+ *  @param a	String to be converted
+ *
+ *  @return	hex value
+ */
+static int
+bt_atox(const char *a)
+{
+	int i = 0;
+	ENTER();
+	while (isxdigit(*a))
+		i = i * 16 + bt_hexval(*a++);
+
+	LEAVE();
+	return i;
+}
+
+/**
+ *  @brief Converts mac address from string to t_u8 buffer.
+ *
+ *  @param mac_addr The buffer to store the mac address in.
+ *  @param buf      The source of mac address which is a string.
+ *
+ *  @return	N/A
+ */
+static void
+bt_mac2u8(u8 *mac_addr, char *buf)
+{
+	char *begin, *end, *mac_buff;
+	int i;
+
+	ENTER();
+
+	if (!buf) {
+		LEAVE();
+		return;
+	}
+
+	mac_buff = kzalloc(strlen(buf) + 1, GFP_KERNEL);
+	if (!mac_buff) {
+		LEAVE();
+		return;
+	}
+	memcpy(mac_buff, buf, strlen(buf));
+
+	begin = mac_buff;
+	for (i = 0; i < ETH_ALEN; ++i) {
+		end = bt_strsep(&begin, ':', '/');
+		if (end)
+			mac_addr[i] = bt_atox(end);
+	}
+
+	kfree(mac_buff);
+	LEAVE();
+}
+
+/**
+ *  @brief Returns integer value of a given ascii string
+ *
+ *  @param data    Converted data to be returned
+ *  @param a       String to be converted
+ *
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_atoi(int *data, char *a)
+{
+	int i, val = 0, len;
+
+	ENTER();
+
+	len = strlen(a);
+	if (!strncmp(a, "0x", 2)) {
+		a = a + 2;
+		len -= 2;
+		*data = bt_atox(a);
+		return BT_STATUS_SUCCESS;
+	}
+	for (i = 0; i < len; i++) {
+		if (isdigit(a[i])) {
+			val = val * 10 + (a[i] - '0');
+		} else {
+			PRINTM(ERROR, "Invalid char %c in string %s\n", a[i],
+			       a);
+			return BT_STATUS_FAILURE;
+		}
+	}
+	*data = val;
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief parse cal-data
+ *
+ *  @param src      a pointer to cal-data string
+ *  @param len      len of cal-data
+ *  @param dst      a pointer to return cal-data
+ *  @param dst_size size of dest buffer
+ *
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_parse_cal_cfg(const u8 *src, u32 len, u8 *dst, u32 *dst_size)
+{
+	const u8 *ptr;
+	u8 *dptr;
+	u32 count = 0;
+	int ret = BT_STATUS_FAILURE;
+
+	ENTER();
+	ptr = src;
+	dptr = dst;
+
+	while ((ptr - src) < len) {
+		if (*ptr && isspace(*ptr)) {
+			ptr++;
+			continue;
+		}
+
+		if (isxdigit(*ptr)) {
+			if ((dptr - dst) >= *dst_size) {
+				PRINTM(ERROR, "cal_file size too big!!!\n");
+				goto done;
+			}
+			*dptr++ = bt_atox((const char *)ptr);
+			ptr += 2;
+			count++;
+		} else {
+			ptr++;
+		}
+	}
+	if (dptr == dst) {
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+
+	*dst_size = count;
+	ret = BT_STATUS_SUCCESS;
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief parse ASCII format raw data to hex format
+ *
+ *    @param priv         bt_private
+ *    @param data         Source data
+ *    @param size         Source data length
+ *    @return             MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int
+bt_process_init_raw_cmds(bt_private *priv, u8 *data, u32 size)
+{
+	int ret = 0;
+	u8 *pos = data;
+	u8 *intf_s, *intf_e;
+	u8 *buf = NULL;
+	u8 *ptr = NULL;
+	u8 cmd_len = 0;
+	bool start_raw = false;
+	gfp_t flag;
+
+	flag = (in_atomic() || irqs_disabled())? GFP_ATOMIC : GFP_KERNEL;
+	buf = kzalloc(MRVDRV_SIZE_OF_CMD_BUFFER, flag);
+
+	if (!buf) {
+		PRINTM(ERROR, "Could not allocate buffer space!\n");
+		return -EFAULT;
+	}
+	ptr = buf;
+	while ((pos - data) < size) {
+		while ((*pos == ' ' || *pos == '\t') && ((pos - data) < size))
+			pos++;
+		if (*pos == '#') {	/* Line comment */
+			while ((*pos != '\n') && ((pos - data) < size))
+				pos++;
+			pos++;
+		}
+		if ((*pos == '\r' && *(pos + 1) == '\n') || *pos == '\n' ||
+		    *pos == '\0') {
+			pos++;
+			continue;	/* Needn't process this line */
+		}
+
+		if (*pos == '}') {
+			/* For hostcmd data conf */
+			cmd_len = *(buf + sizeof(u16));
+			ret = bt_process_commands(priv, buf,
+						  cmd_len + BT_CMD_HEADER_SIZE);
+			memset(buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
+			ptr = buf;
+			start_raw = false;
+			pos++;
+			continue;
+		}
+
+		if (start_raw == false) {
+			intf_s = strchr(pos, '=');
+			if (intf_s)
+				intf_e = strchr(intf_s, '{');
+			else
+				intf_e = NULL;
+
+			if (intf_s && intf_e) {
+				start_raw = true;
+				pos = intf_e + 1;
+				continue;
+			}
+		}
+
+		if (start_raw) {
+			/* Raw data block exists */
+			while (*pos != '\n' && ((pos - data) < size)) {
+				if (isxdigit(*pos)) {
+					if ((ptr - buf) <
+					    MRVDRV_SIZE_OF_CMD_BUFFER)
+						*ptr++ = bt_atox(pos);
+					pos += 2;
+				} else
+					pos++;
+			}
+		}
+	}
+	kfree(buf);
+	return ret;
+}
+
+/**
+ *    @brief BT set user init commands
+ *
+ *    @param priv     BT private handle
+ *    @param init_cmds_file user init commands file
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+
+int
+bt_init_cmds(bt_private *priv, char *init_cmds_file)
+{
+	const struct firmware *cfg = NULL;
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+	if ((request_firmware(&cfg, init_cmds_file, priv->hotplug_device)) < 0) {
+		PRINTM(FATAL, "BT: request_firmware() %s failed\n",
+		       init_cmds_file);
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+	if (cfg)
+		ret = bt_process_init_raw_cmds(priv, (u8 *)cfg->data,
+					       cfg->size);
+	else
+		ret = BT_STATUS_FAILURE;
+done:
+	if (cfg)
+		release_firmware(cfg);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT get one line data from ASCII format data
+ *
+ *    @param data         Source data
+ *    @param size         Source data length
+ *    @param line_pos     Destination data
+ *    @return             -1 or length of the line
+ */
+int
+parse_cfg_get_line(u8 *data, u32 size, u8 *line_pos)
+{
+	static s32 pos;
+	u8 *src, *dest;
+
+	if (pos >= size) {	/* reach the end */
+		pos = 0;	/* Reset position for rfkill */
+		return -1;
+	}
+	memset(line_pos, 0, MAX_LINE_LEN);
+	src = data + pos;
+	dest = line_pos;
+
+	while ((dest - line_pos < MAX_LINE_LEN - 1) && pos < size &&
+	       *src != '\x0A' && *src != '\0') {
+		if (*src != ' ' && *src != '\t')	/* parse space */
+			*dest++ = *src++;
+		else
+			src++;
+		pos++;
+	}
+	*dest = '\0';
+	/* parse new line */
+	pos++;
+	return strlen((const char *)line_pos);
+}
+
+/**
+ *    @brief BT parse ASCII format data to MAC address
+ *
+ *    @param priv          BT private handle
+ *    @param data          Source data
+ *    @param size          data length
+ *    @return              BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_init_cfg(bt_private *priv, u8 *data, u32 size)
+{
+	u8 *pos;
+	u8 *intf_s, *intf_e;
+	u8 s[MAX_LINE_LEN];	/* 1 line data */
+	u32 line_len;
+	char dev_name[MAX_PARAM_LEN];
+	u8 buf[MAX_PARAM_LEN];
+	u8 bt_addr[MAX_MAC_ADDR_LEN];
+	u8 bt_mac[ETH_ALEN];
+	int setting = 0;
+	u8 type = 0;
+	u16 value = 0;
+	u32 offset = 0;
+	int ret = BT_STATUS_FAILURE;
+
+	memset(dev_name, 0, sizeof(dev_name));
+	memset(bt_addr, 0, sizeof(bt_addr));
+	memset(bt_mac, 0, sizeof(bt_mac));
+
+	while ((line_len = parse_cfg_get_line(data, size, s)) != -1) {
+		pos = s;
+		while (*pos == ' ' || *pos == '\t')
+			pos++;
+
+		if (*pos == '#' || (*pos == '\r' && *(pos + 1) == '\n') ||
+		    *pos == '\n' || *pos == '\0')
+			continue;	/* Need n't process this line */
+
+		/* Process MAC addr */
+		if (strncmp((char *)pos, "mac_addr", 8) == 0) {
+			intf_s = (u8 *)strchr((const char *)pos, '=');
+			if (intf_s != NULL)
+				intf_e = (u8 *)strchr((const char *)intf_s,
+						      ':');
+			else
+				intf_e = NULL;
+			if (intf_s != NULL && intf_e != NULL) {
+				if ((intf_e - intf_s) > MAX_PARAM_LEN) {
+					PRINTM(ERROR,
+					       "BT: Too long interface name %d\n",
+					       __LINE__);
+					goto done;
+				}
+				strncpy(dev_name, (const char *)intf_s + 1,
+					intf_e - intf_s - 1);
+				dev_name[intf_e - intf_s - 1] = '\0';
+				strncpy((char *)bt_addr,
+					(const char *)intf_e + 1,
+					MAX_MAC_ADDR_LEN - 1);
+				bt_addr[MAX_MAC_ADDR_LEN - 1] = '\0';
+				/* Convert MAC format */
+				bt_mac2u8(bt_mac, (char *)bt_addr);
+				PRINTM(CMD,
+				       "HCI: %s new BT Address " MACSTR "\n",
+				       dev_name, MAC2STR(bt_mac));
+				if (BT_STATUS_SUCCESS !=
+				    bt_set_mac_address(priv, bt_mac)) {
+					PRINTM(FATAL,
+					       "BT: Fail to set mac address\n");
+					goto done;
+				}
+			} else {
+				PRINTM(ERROR,
+				       "BT: Wrong config file format %d\n",
+				       __LINE__);
+				goto done;
+			}
+		}
+		/* Process REG value */
+		else if (strncmp((char *)pos, "bt_reg", 6) == 0) {
+			intf_s = (u8 *)strchr((const char *)pos, '=');
+			if (intf_s != NULL)
+				intf_e = (u8 *)strchr((const char *)intf_s,
+						      ',');
+			else
+				intf_e = NULL;
+			if (intf_s != NULL && intf_e != NULL) {
+				/* Copy type */
+				memset(buf, 0, sizeof(buf));
+				strncpy((char *)buf, (const char *)intf_s + 1,
+					1);
+				buf[1] = '\0';
+				if (0 == bt_atoi(&setting, (char *)buf))
+					type = (u8)setting;
+				else {
+					PRINTM(ERROR,
+					       "BT: Fail to parse reg type\n");
+					goto done;
+				}
+			} else {
+				PRINTM(ERROR,
+				       "BT: Wrong config file format %d\n",
+				       __LINE__);
+				goto done;
+			}
+			intf_s = intf_e + 1;
+			intf_e = (u8 *)strchr((const char *)intf_s, ',');
+			if (intf_e != NULL) {
+				if ((intf_e - intf_s) >= MAX_PARAM_LEN) {
+					PRINTM(ERROR,
+					       "BT: Regsier offset is too long %d\n",
+					       __LINE__);
+					goto done;
+				}
+				/* Copy offset */
+				memset(buf, 0, sizeof(buf));
+				strncpy((char *)buf, (const char *)intf_s,
+					intf_e - intf_s);
+				buf[intf_e - intf_s] = '\0';
+				if (0 == bt_atoi(&setting, (char *)buf))
+					offset = (u32)setting;
+				else {
+					PRINTM(ERROR,
+					       "BT: Fail to parse reg offset\n");
+					goto done;
+				}
+			} else {
+				PRINTM(ERROR,
+				       "BT: Wrong config file format %d\n",
+				       __LINE__);
+				goto done;
+			}
+			intf_s = intf_e + 1;
+			if ((strlen((const char *)intf_s) >= MAX_PARAM_LEN)) {
+				PRINTM(ERROR,
+				       "BT: Regsier value is too long %d\n",
+				       __LINE__);
+				goto done;
+			}
+			/* Copy value */
+			memset(buf, 0, sizeof(buf));
+			strncpy((char *)buf, (const char *)intf_s, sizeof(buf));
+			if (0 == bt_atoi(&setting, (char *)buf))
+				value = (u16) setting;
+			else {
+				PRINTM(ERROR, "BT: Fail to parse reg value\n");
+				goto done;
+			}
+
+			PRINTM(CMD,
+			       "BT: Write reg type: %d offset: 0x%x value: 0x%x\n",
+			       type, offset, value);
+			if (BT_STATUS_SUCCESS !=
+			    bt_write_reg(priv, type, offset, value)) {
+				PRINTM(FATAL,
+				       "BT: Write reg failed. type: %d offset: 0x%x value: 0x%x\n",
+				       type, offset, value);
+				goto done;
+			}
+		}
+	}
+	ret = BT_STATUS_SUCCESS;
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief BT request init conf firmware callback
+ *        This function is invoked by request_firmware_nowait system call
+ *
+ * @param firmware  A pointer to firmware image
+ * @param context   A pointer to bt_private structure
+ *
+ * @return          N/A
+ */
+static void
+bt_request_init_user_conf_callback(const struct firmware *firmware,
+				   void *context)
+{
+	bt_private *priv = (bt_private *)context;
+
+	ENTER();
+
+	if (!firmware)
+		PRINTM(ERROR, "BT user init config request firmware failed\n");
+
+	priv->init_user_cfg = firmware;
+	priv->init_user_conf_wait_flag = TRUE;
+	wake_up_interruptible(&priv->init_user_conf_wait_q);
+
+	LEAVE();
+	return;
+}
+
+/**
+ *    @brief BT set user defined init data and param
+ *
+ *    @param priv     BT private handle
+ *    @param cfg_file user cofig file
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_init_config(bt_private *priv, char *cfg_file)
+{
+	const struct firmware *cfg = NULL;
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+	if ((request_firmware(&cfg, cfg_file, priv->hotplug_device)) < 0) {
+		PRINTM(FATAL, "BT: request_firmware() %s failed\n", cfg_file);
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+	if (cfg)
+		ret = bt_process_init_cfg(priv, (u8 *)cfg->data, cfg->size);
+	else
+		ret = BT_STATUS_FAILURE;
+done:
+	if (cfg)
+		release_firmware(cfg);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT process calibration data
+ *
+ *    @param priv    a pointer to bt_private structure
+ *    @param data    a pointer to cal data
+ *    @param size    cal data size
+ *    @param mac     mac address buf
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_cal_cfg(bt_private *priv, u8 *data, u32 size, char *mac)
+{
+	u8 bt_mac[ETH_ALEN];
+	u8 cal_data[32];
+	u8 *mac_data = NULL;
+	u32 cal_data_len;
+	int ret = BT_STATUS_FAILURE;
+	u8 *pcal_data = cal_data;
+
+	memset(bt_mac, 0, sizeof(bt_mac));
+	cal_data_len = sizeof(cal_data);
+	if (BT_STATUS_SUCCESS !=
+	    bt_parse_cal_cfg(data, size, cal_data, &cal_data_len)) {
+		goto done;
+	}
+	if (mac != NULL) {
+		/* Convert MAC format */
+		bt_mac2u8(bt_mac, mac);
+		PRINTM(CMD, "HCI: new BT Address " MACSTR "\n",
+		       MAC2STR(bt_mac));
+		mac_data = bt_mac;
+	}
+	if (BT_STATUS_SUCCESS != bt_load_cal_data(priv, pcal_data, mac_data)) {
+		PRINTM(FATAL, "BT: Fail to load calibrate data\n");
+		goto done;
+	}
+	ret = BT_STATUS_SUCCESS;
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT process calibration EXT data
+ *
+ *    @param priv    a pointer to bt_private structure
+ *    @param data    a pointer to cal data
+ *    @param size    cal data size
+ *    @param mac     mac address buf
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_cal_cfg_ext(bt_private *priv, u8 *data, u32 size)
+{
+	u8 cal_data[128];
+	u32 cal_data_len;
+	int ret = BT_STATUS_FAILURE;
+
+	cal_data_len = sizeof(cal_data);
+	if (BT_STATUS_SUCCESS !=
+	    bt_parse_cal_cfg(data, size, cal_data, &cal_data_len)) {
+		goto done;
+	}
+	if (BT_STATUS_SUCCESS !=
+	    bt_load_cal_data_ext(priv, cal_data, cal_data_len)) {
+		PRINTM(FATAL, "BT: Fail to load calibrate data\n");
+		goto done;
+	}
+	ret = BT_STATUS_SUCCESS;
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT process calibration file
+ *
+ *    @param priv    a pointer to bt_private structure
+ *    @param cal_file calibration file name
+ *    @param mac     mac address buf
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_cal_config(bt_private *priv, char *cal_file, char *mac)
+{
+	const struct firmware *cfg = NULL;
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cal_file, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      bt_request_init_user_conf_callback);
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cal_file, priv->hotplug_device,
+					      priv,
+					      bt_request_init_user_conf_callback);
+#else
+		ret = request_firmware_nowait(THIS_MODULE,
+					      cal_file, priv->hotplug_device,
+					      priv,
+					      bt_request_init_user_conf_callback);
+#endif
+#endif
+		if (ret < 0) {
+			PRINTM(FATAL,
+			       "BT: bt_cal_config() failed, error code = %#x cal_file=%s\n",
+			       ret, cal_file);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		priv->init_user_conf_wait_flag = FALSE;
+		wait_event_interruptible(priv->init_user_conf_wait_q,
+					 priv->init_user_conf_wait_flag);
+		cfg = priv->init_user_cfg;
+	} else {
+		if ((request_firmware(&cfg, cal_file, priv->hotplug_device)) <
+		    0) {
+			PRINTM(FATAL, "BT: request_firmware() %s failed\n",
+			       cal_file);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (cfg)
+		ret = bt_process_cal_cfg(priv, (u8 *)cfg->data, cfg->size, mac);
+	else
+		ret = BT_STATUS_FAILURE;
+done:
+	if (cfg)
+		release_firmware(cfg);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT process calibration EXT file
+ *
+ *    @param priv    a pointer to bt_private structure
+ *    @param cal_file calibration file name
+ *    @param mac     mac address buf
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_cal_config_ext(bt_private *priv, char *cal_file)
+{
+	const struct firmware *cfg = NULL;
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cal_file, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      bt_request_init_user_conf_callback);
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cal_file, priv->hotplug_device,
+					      priv,
+					      bt_request_init_user_conf_callback);
+#else
+		ret = request_firmware_nowait(THIS_MODULE,
+					      cal_file, priv->hotplug_device,
+					      priv,
+					      bt_request_init_user_conf_callback);
+#endif
+#endif
+		if (ret < 0) {
+			PRINTM(FATAL,
+			       "BT: bt_cal_config_ext() failed, error code = %#x cal_file=%s\n",
+			       ret, cal_file);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		priv->init_user_conf_wait_flag = FALSE;
+		wait_event_interruptible(priv->init_user_conf_wait_q,
+					 priv->init_user_conf_wait_flag);
+		cfg = priv->init_user_cfg;
+	} else {
+		if ((request_firmware(&cfg, cal_file, priv->hotplug_device)) <
+		    0) {
+			PRINTM(FATAL, "BT: request_firmware() %s failed\n",
+			       cal_file);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (cfg)
+		ret = bt_process_cal_cfg_ext(priv, (u8 *)cfg->data, cfg->size);
+	else
+		ret = BT_STATUS_FAILURE;
+done:
+	if (cfg)
+		release_firmware(cfg);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *    @brief BT init mac address from bt_mac parametre when insmod
+ *
+ *    @param priv    a pointer to bt_private structure
+ *    @param bt_mac  mac address buf
+ *    @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_init_mac_address(bt_private *priv, char *mac)
+{
+	u8 bt_mac[ETH_ALEN];
+	int ret = BT_STATUS_FAILURE;
+
+	ENTER();
+	memset(bt_mac, 0, sizeof(bt_mac));
+	bt_mac2u8(bt_mac, mac);
+	PRINTM(CMD, "HCI: New BT Address " MACSTR "\n", MAC2STR(bt_mac));
+	ret = bt_set_mac_address(priv, bt_mac);
+	if (ret != BT_STATUS_SUCCESS)
+		PRINTM(FATAL,
+		       "BT: Fail to set mac address from insmod parametre.\n");
+
+	LEAVE();
+	return ret;
+}
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_main.c b/drivers/bluetooth/mbtex_8997/bt/bt_main.c
new file mode 100755
index 000000000000..45a4ecccd7ef
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_main.c
@@ -0,0 +1,3706 @@
+/** @file bt_main.c
+ *
+ *  @brief This file contains the major functions in BlueTooth
+ *  driver. It includes init, exit, open, close and main
+ *  thread etc..
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+/**
+  * @mainpage M-BT Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * The M-BT is a Linux reference driver for NXP Bluetooth chipset.
+  *
+  * @section copyright_sec Copyright
+  *
+  * Copyright 2014-2020 NXP
+  *
+  */
+#include <linux/module.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include <linux/mmc/sdio_func.h>
+
+#include "bt_drv.h"
+#include "mbt_char.h"
+#include "bt_sdio.h"
+
+/** Version */
+#define VERSION "C4X14114"
+
+/** Driver version */
+static char mbt_driver_version[] = "SD8997-%s-" VERSION "-(" "FP" FPNUM ")"
+#ifdef DEBUG_LEVEL2
+	"-dbg"
+#endif
+	" ";
+
+/** Declare and initialize fw_version */
+static char fw_version[32] = "0.0.0.p0";
+
+#define AID_SYSTEM        1000	/* system server */
+
+#define AID_BLUETOOTH     1002	/* bluetooth subsystem */
+
+#define AID_NET_BT_STACK  3008	/* bluetooth stack */
+
+/** Define module name */
+
+#define MODULE_NAME  "bt_fm_nfc"
+
+/** Declaration of chardev class */
+static struct class *chardev_class;
+
+/** Interface specific variables */
+
+/**
+ * The global variable of a pointer to bt_private
+ * structure variable
+ **/
+bt_private *m_priv[MAX_BT_ADAPTER];
+
+/** Default Driver mode */
+static int drv_mode = (DRV_MODE_BT);
+
+/** fw reload flag */
+int bt_fw_reload;
+/** fw serial download flag */
+int bt_fw_serial = 1;
+
+/** Firmware flag */
+static int fw = 1;
+/** default powermode */
+static int psmode = 1;
+/** default BLE deep sleep */
+static int deep_sleep = 1;
+/** init cmds file */
+static char *init_cmds;
+/** Init config file (MAC address, register etc.) */
+static char *init_cfg;
+/** Calibration config file (MAC address, init powe etc.) */
+static char *cal_cfg;
+/** Calibration config file EXT */
+static char *cal_cfg_ext;
+/** Init MAC address */
+static char *bt_mac;
+static int btindrst = -1;
+
+/** Setting mbt_drvdbg value based on DEBUG level */
+#ifdef DEBUG_LEVEL1
+#ifdef DEBUG_LEVEL2
+#define DEFAULT_DEBUG_MASK  (0xffffffff & ~DBG_EVENT)
+#else
+#define DEFAULT_DEBUG_MASK  (DBG_MSG | DBG_FATAL | DBG_ERROR)
+#endif /* DEBUG_LEVEL2 */
+u32 mbt_drvdbg = DEFAULT_DEBUG_MASK;
+#endif
+
+#ifdef CONFIG_OF
+static int dts_enable = 1;
+#endif
+
+#ifdef SDIO_SUSPEND_RESUME
+/** PM keep power */
+int mbt_pm_keep_power = 1;
+#endif
+
+static int btpmic = 0;
+
+/** Offset of sequence number in event */
+#define OFFSET_SEQNUM 4
+
+/**
+ *  @brief handle received packet
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb
+ *
+ *  @return        N/A
+ */
+void
+bt_recv_frame(bt_private *priv, struct sk_buff *skb)
+{
+	struct hci_dev *hdev = NULL;
+	if (priv->bt_dev.m_dev[BT_SEQ].spec_type == BLUEZ_SPEC)
+		hdev = (struct hci_dev *)priv->bt_dev.m_dev[BT_SEQ].dev_pointer;
+	if (hdev) {
+		skb->dev = (void *)hdev;
+		hdev->stat.byte_rx += skb->len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+		hci_recv_frame(skb);
+#else
+		hci_recv_frame(hdev, skb);
+#endif
+	}
+	return;
+}
+
+/**
+ *  @brief Alloc bt device
+ *
+ *  @return    pointer to structure mbt_dev or NULL
+ */
+struct mbt_dev *
+alloc_mbt_dev(void)
+{
+	struct mbt_dev *mbt_dev;
+	ENTER();
+
+	mbt_dev = kzalloc(sizeof(struct mbt_dev), GFP_KERNEL);
+	if (!mbt_dev) {
+		LEAVE();
+		return NULL;
+	}
+
+	LEAVE();
+	return mbt_dev;
+}
+
+/**
+ *  @brief Frees m_dev
+ *
+ *  @return    N/A
+ */
+void
+free_m_dev(struct m_dev *m_dev)
+{
+	ENTER();
+	kfree(m_dev->dev_pointer);
+	m_dev->dev_pointer = NULL;
+	LEAVE();
+}
+
+/**
+ *  @brief clean up m_devs
+ *
+ *  @return    N/A
+ */
+void
+clean_up_m_devs(bt_private *priv)
+{
+	struct m_dev *m_dev = NULL;
+	struct hci_dev *hdev = NULL;
+
+	ENTER();
+	if (priv->bt_dev.m_dev[BT_SEQ].dev_pointer) {
+		m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+		PRINTM(MSG, "BT: Delete %s\n", m_dev->name);
+		if (m_dev->spec_type == BLUEZ_SPEC) {
+			hdev = (struct hci_dev *)m_dev->dev_pointer;
+			/** check if dev->name has been assigned */
+			if (strstr(hdev->name, "hci"))
+				hci_unregister_dev(hdev);
+			hci_free_dev(hdev);
+		}
+		priv->bt_dev.m_dev[BT_SEQ].dev_pointer = NULL;
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function verify the received event pkt
+ *
+ *  Event format:
+ *  +--------+--------+--------+--------+--------+
+ *  | Event  | Length |  ncmd  |      Opcode     |
+ *  +--------+--------+--------+--------+--------+
+ *  | 1-byte | 1-byte | 1-byte |      2-byte     |
+ *  +--------+--------+--------+--------+--------+
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+check_evtpkt(bt_private *priv, struct sk_buff *skb)
+{
+	struct hci_event_hdr *hdr = (struct hci_event_hdr *)skb->data;
+	struct hci_ev_cmd_complete *ec;
+	u16 opcode, ocf;
+	int ret = BT_STATUS_SUCCESS;
+	ENTER();
+	if (!priv->bt_dev.sendcmdflag) {
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	if (hdr->evt == HCI_EV_CMD_COMPLETE) {
+		ec = (struct hci_ev_cmd_complete *)
+			(skb->data + HCI_EVENT_HDR_SIZE);
+		opcode = __le16_to_cpu(ec->opcode);
+		ocf = hci_opcode_ocf(opcode);
+		PRINTM(CMD,
+		       "BT: CMD_COMPLTE opcode=0x%x, ocf=0x%x, send_cmd_opcode=0x%x\n",
+		       opcode, ocf, priv->bt_dev.send_cmd_opcode);
+		if (opcode != priv->bt_dev.send_cmd_opcode) {
+			ret = BT_STATUS_FAILURE;
+			goto exit;
+		}
+		switch (ocf) {
+		case BT_CMD_MODULE_CFG_REQ:
+		case BT_CMD_BLE_DEEP_SLEEP:
+		case BT_CMD_CONFIG_MAC_ADDR:
+		case BT_CMD_CSU_WRITE_REG:
+		case BT_CMD_LOAD_CONFIG_DATA:
+		case BT_CMD_LOAD_CONFIG_DATA_EXT:
+		case BT_CMD_AUTO_SLEEP_MODE:
+		case BT_CMD_HOST_SLEEP_CONFIG:
+		case BT_CMD_SDIO_PULL_CFG_REQ:
+		case BT_CMD_SET_EVT_FILTER:
+			// case BT_CMD_ENABLE_DEVICE_TESTMODE:
+		case BT_CMD_PMIC_CONFIGURE:
+		case BT_CMD_INDEPENDENT_RESET:
+			priv->bt_dev.sendcmdflag = FALSE;
+			priv->adapter->cmd_complete = TRUE;
+			wake_up_interruptible(&priv->adapter->cmd_wait_q);
+			break;
+		case BT_CMD_GET_FW_VERSION:
+			{
+				u8 *pos = (skb->data + HCI_EVENT_HDR_SIZE +
+					   sizeof(struct hci_ev_cmd_complete) +
+					   1);
+				snprintf(fw_version, sizeof(fw_version),
+					 "%u.%u.%u.p%u", pos[2], pos[1], pos[0],
+					 pos[3]);
+				priv->bt_dev.sendcmdflag = FALSE;
+				priv->adapter->cmd_complete = TRUE;
+				wake_up_interruptible(&priv->adapter->
+						      cmd_wait_q);
+				break;
+			}
+		case BT_CMD_HISTOGRAM:
+			{
+				u8 *status =
+					skb->data + HCI_EVENT_HDR_SIZE +
+					sizeof(struct hci_ev_cmd_complete);
+				u8 *pos =
+					(skb->data + HCI_EVENT_HDR_SIZE +
+					 sizeof(struct hci_ev_cmd_complete) +
+					 1);
+				if (*status == 0) {
+					priv->hist_data_len =
+						hdr->plen -
+						sizeof(struct
+						       hci_ev_cmd_complete) - 1;
+					if (priv->hist_data_len >
+					    sizeof(priv->hist_data))
+						priv->hist_data_len =
+							sizeof(priv->hist_data);
+					memcpy(priv->hist_data, pos,
+					       priv->hist_data_len);
+					PRINTM(CMD, "histogram len=%d\n",
+					       priv->hist_data_len);
+				}
+				priv->bt_dev.sendcmdflag = FALSE;
+				priv->adapter->cmd_complete = TRUE;
+				wake_up_interruptible(&priv->adapter->
+						      cmd_wait_q);
+				break;
+			}
+		case BT_CMD_RESET:
+		case BT_CMD_ENABLE_WRITE_SCAN:
+			{
+				priv->bt_dev.sendcmdflag = FALSE;
+				priv->adapter->cmd_complete = TRUE;
+				if (priv->adapter->wait_event_timeout == TRUE) {
+					wake_up(&priv->adapter->cmd_wait_q);
+					priv->adapter->wait_event_timeout =
+						FALSE;
+				} else
+					wake_up_interruptible(&priv->adapter->
+							      cmd_wait_q);
+			}
+			break;
+		case BT_CMD_HOST_SLEEP_ENABLE:
+			priv->bt_dev.sendcmdflag = FALSE;
+			break;
+		default:
+			/** Ignore command not defined but send by driver */
+			if (opcode == priv->bt_dev.send_cmd_opcode) {
+				priv->bt_dev.sendcmdflag = FALSE;
+				priv->adapter->cmd_complete = TRUE;
+				wake_up_interruptible(&priv->adapter->
+						      cmd_wait_q);
+			} else {
+				ret = BT_STATUS_FAILURE;
+			}
+			break;
+		}
+	} else
+		ret = BT_STATUS_FAILURE;
+exit:
+	if (ret == BT_STATUS_SUCCESS)
+		kfree_skb(skb);
+	LEAVE();
+	return ret;
+}
+
+/**
+*  @brief This function stores the FW dumps received from events
+*
+*  @param priv    A pointer to bt_private structure
+*  @param skb     A pointer to rx skb
+*
+*  @return        N/A
+*/
+void
+bt_store_firmware_dump(bt_private *priv, u8 *buf, u32 len)
+{
+	struct file *pfile_fwdump = NULL;
+	loff_t pos = 0;
+	u16 seqnum = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	struct __kernel_old_timeval t;
+#else
+	struct timeval t;
+#endif
+	u32 sec;
+
+	ENTER();
+
+	seqnum = __le16_to_cpu(*(u16 *) (buf + OFFSET_SEQNUM));
+
+	if (priv->adapter->fwdump_fname && seqnum != 1) {
+		pfile_fwdump =
+			filp_open((const char *)priv->adapter->fwdump_fname,
+				  O_CREAT | O_WRONLY | O_APPEND, 0644);
+		if (IS_ERR(pfile_fwdump)) {
+			PRINTM(MSG, "Cannot create firmware dump file.\n");
+			LEAVE();
+			return;
+		}
+	} else {
+		if (!priv->adapter->fwdump_fname) {
+			gfp_t flag;
+			flag = (in_atomic() ||
+				irqs_disabled())? GFP_ATOMIC : GFP_KERNEL;
+			priv->adapter->fwdump_fname = kzalloc(64, flag);
+		} else
+			memset(priv->adapter->fwdump_fname, 0, 64);
+
+		get_monotonic_time(&t);
+		sec = (u32)t.tv_sec;
+		sprintf(priv->adapter->fwdump_fname, "%s%u",
+			"/var/log/bt_fwdump_", sec);
+		pfile_fwdump =
+			filp_open(priv->adapter->fwdump_fname,
+				  O_CREAT | O_WRONLY | O_APPEND, 0644);
+		if (IS_ERR(pfile_fwdump)) {
+			sprintf(priv->adapter->fwdump_fname, "%s%u",
+				"/data/bt_fwdump_", sec);
+			pfile_fwdump =
+				filp_open((const char *)priv->adapter->
+					  fwdump_fname,
+					  O_CREAT | O_WRONLY | O_APPEND, 0644);
+		}
+	}
+
+	if (IS_ERR(pfile_fwdump)) {
+		PRINTM(MSG, "Cannot create firmware dump file\n");
+		LEAVE();
+		return;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+	vfs_write(pfile_fwdump, buf, len, &pos);
+#else
+	//kernel_write(pfile_fwdump, buf, len, &pos);
+#endif
+	filp_close(pfile_fwdump, NULL);
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function process the received event
+ *
+ *  Event format:
+ *  +--------+--------+--------+--------+-----+
+ *  |   EC   | Length |           Data        |
+ *  +--------+--------+--------+--------+-----+
+ *  | 1-byte | 1-byte |          n-byte       |
+ *  +--------+--------+--------+--------+-----+
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_event(bt_private *priv, struct sk_buff *skb)
+{
+	int ret = BT_STATUS_SUCCESS;
+#ifdef DEBUG_LEVEL1
+	struct m_dev *m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+#endif
+	BT_EVENT *pevent;
+
+	ENTER();
+	if (!m_dev) {
+		PRINTM(CMD, "BT: bt_process_event without m_dev\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pevent = (BT_EVENT *)skb->data;
+	if (pevent->EC != 0xff) {
+		PRINTM(CMD, "BT: Not NXP Event=0x%x\n", pevent->EC);
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	switch (pevent->data[0]) {
+	case BT_CMD_HISTOGRAM:
+		break;
+	case BT_CMD_AUTO_SLEEP_MODE:
+		if (pevent->data[2] == BT_STATUS_SUCCESS) {
+			if (pevent->data[1] == BT_PS_ENABLE)
+				priv->adapter->psmode = 1;
+			else
+				priv->adapter->psmode = 0;
+			PRINTM(CMD, "BT: PS Mode %s:%s\n", m_dev->name,
+			       (priv->adapter->psmode) ? "Enable" : "Disable");
+
+		} else {
+			PRINTM(CMD, "BT: PS Mode Command Fail %s\n",
+			       m_dev->name);
+		}
+		break;
+	case BT_CMD_HOST_SLEEP_CONFIG:
+		if (pevent->data[3] == BT_STATUS_SUCCESS) {
+			PRINTM(CMD, "BT: %s: gpio=0x%x, gap=0x%x\n",
+			       m_dev->name, pevent->data[1], pevent->data[2]);
+		} else {
+			PRINTM(CMD, "BT: %s: HSCFG Command Fail\n",
+			       m_dev->name);
+		}
+		break;
+	case BT_CMD_HOST_SLEEP_ENABLE:
+		if (pevent->data[1] == BT_STATUS_SUCCESS) {
+			priv->adapter->hs_state = HS_ACTIVATED;
+			if (priv->adapter->suspend_fail == FALSE) {
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+				bt_is_suspended(priv);
+#endif
+#endif
+#endif
+				if (priv->adapter->wait_event_timeout) {
+					wake_up(&priv->adapter->cmd_wait_q);
+					priv->adapter->wait_event_timeout =
+						FALSE;
+				} else
+					wake_up_interruptible(&priv->adapter->
+							      cmd_wait_q);
+
+			}
+			if (priv->adapter->psmode)
+				priv->adapter->ps_state = PS_SLEEP;
+			PRINTM(CMD, "BT: EVENT %s: HS ACTIVATED!\n",
+			       m_dev->name);
+
+		} else {
+			PRINTM(CMD, "BT: %s: HS Enable Fail\n", m_dev->name);
+		}
+		break;
+	case BT_CMD_MODULE_CFG_REQ:
+		if ((priv->bt_dev.sendcmdflag == TRUE) &&
+		    ((pevent->data[1] == MODULE_BRINGUP_REQ)
+		     || (pevent->data[1] == MODULE_SHUTDOWN_REQ))) {
+			if (pevent->data[1] == MODULE_BRINGUP_REQ) {
+				PRINTM(CMD, "BT: EVENT %s:%s\n", m_dev->name,
+				       (pevent->data[2] && (pevent->data[2] !=
+							    MODULE_CFG_RESP_ALREADY_UP))
+				       ? "Bring up Fail" : "Bring up success");
+				priv->bt_dev.devType = pevent->data[3];
+				PRINTM(CMD, "devType:%s\n",
+				       (pevent->data[3] ==
+					DEV_TYPE_AMP) ? "AMP controller" :
+				       "BR/EDR controller");
+				priv->bt_dev.devFeature = pevent->data[4];
+				PRINTM(CMD, "devFeature:  %s,    %s,    %s"
+				       "\n",
+				       ((pevent->
+					 data[4] & DEV_FEATURE_BT) ?
+					"BT Feature" : "No BT Feature"),
+				       ((pevent->
+					 data[4] & DEV_FEATURE_BTAMP) ?
+					"BTAMP Feature" : "No BTAMP Feature"),
+				       ((pevent->
+					 data[4] & DEV_FEATURE_BLE) ?
+					"BLE Feature" : "No BLE Feature")
+					);
+			}
+			if (pevent->data[1] == MODULE_SHUTDOWN_REQ) {
+				PRINTM(CMD, "BT: EVENT %s:%s\n", m_dev->name,
+				       (pevent->data[2]) ? "Shut down Fail"
+				       : "Shut down success");
+
+			}
+			if (pevent->data[2]) {
+				priv->bt_dev.sendcmdflag = FALSE;
+				priv->adapter->cmd_complete = TRUE;
+				wake_up_interruptible(&priv->adapter->
+						      cmd_wait_q);
+			}
+		} else {
+			PRINTM(CMD, "BT_CMD_MODULE_CFG_REQ resp for APP\n");
+			ret = BT_STATUS_FAILURE;
+		}
+		break;
+	case BT_EVENT_POWER_STATE:
+		if (pevent->data[1] == BT_PS_SLEEP)
+			priv->adapter->ps_state = PS_SLEEP;
+		PRINTM(CMD, "BT: EVENT %s:%s\n", m_dev->name,
+		       (priv->adapter->ps_state) ? "PS_SLEEP" : "PS_AWAKE");
+
+		break;
+	case BT_CMD_SDIO_PULL_CFG_REQ:
+		if (pevent->data[pevent->length - 1] == BT_STATUS_SUCCESS)
+			PRINTM(CMD, "BT: %s: SDIO pull configuration success\n",
+			       m_dev->name);
+
+		else {
+			PRINTM(CMD, "BT: %s: SDIO pull configuration fail\n",
+			       m_dev->name);
+
+		}
+		break;
+	default:
+		PRINTM(CMD, "BT: Unknown Event=%d %s\n", pevent->data[0],
+		       m_dev->name);
+		ret = BT_STATUS_FAILURE;
+		break;
+	}
+exit:
+	if (ret == BT_STATUS_SUCCESS)
+		kfree_skb(skb);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function save the dump info to file
+ *
+ *  @param dir_name     directory name
+ *  @param file_name    file_name
+ *  @param buf			buffer
+ *  @param buf_len		buffer length
+ *
+ *  @return   		    0 --success otherwise fail
+ */
+int
+bt_save_dump_info_to_file(char *dir_name, char *file_name, u8 *buf, u32 buf_len)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct file *pfile = NULL;
+	u8 name[64];
+	loff_t pos;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+	mm_segment_t fs;
+#endif
+
+	ENTER();
+
+	if (!dir_name || !file_name || !buf) {
+		PRINTM(ERROR, "Can't save dump info to file\n");
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+
+	memset(name, 0, sizeof(name));
+	snprintf((char *)name, sizeof(name), "%s/%s", dir_name, file_name);
+	pfile = filp_open((const char *)name, O_CREAT | O_RDWR, 0644);
+	if (IS_ERR(pfile)) {
+		PRINTM(MSG,
+		       "Create file %s error, try to save dump file in /var\n",
+		       name);
+		memset(name, 0, sizeof(name));
+		snprintf((char *)name, sizeof(name), "%s/%s", "/var",
+			 file_name);
+		pfile = filp_open((const char *)name, O_CREAT | O_RDWR, 0644);
+	}
+	if (IS_ERR(pfile)) {
+		PRINTM(ERROR, "Create Dump file for %s error\n", name);
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+
+	PRINTM(MSG, "Dump data %s saved in %s\n", file_name, name);
+
+	pos = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	vfs_write(pfile, (const char __user *)buf, buf_len, &pos);
+	set_fs(fs);
+#else
+	//kernel_write(pfile, (const char __user *)buf, buf_len, &pos);
+#endif
+	filp_close(pfile, NULL);
+
+	PRINTM(MSG, "Dump data %s saved in %s successfully\n", file_name, name);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+#define DEBUG_HOST_READY		0xEE
+#define DEBUG_FW_DONE			0xFF
+#define DUMP_MAX_POLL_TRIES			200
+
+#define DEBUG_DUMP_CTRL_REG               0xF0
+#define DEBUG_DUMP_START_REG              0xF1
+#define DEBUG_DUMP_END_REG                0xF8
+
+typedef enum {
+	DUMP_TYPE_ITCM = 0,
+	DUMP_TYPE_DTCM = 1,
+	DUMP_TYPE_SQRAM = 2,
+	DUMP_TYPE_APU_REGS = 3,
+	DUMP_TYPE_CIU_REGS = 4,
+	DUMP_TYPE_ICU_REGS = 5,
+	DUMP_TYPE_MAC_REGS = 6,
+	DUMP_TYPE_EXTEND_7 = 7,
+	DUMP_TYPE_EXTEND_8 = 8,
+	DUMP_TYPE_EXTEND_9 = 9,
+	DUMP_TYPE_EXTEND_10 = 10,
+	DUMP_TYPE_EXTEND_11 = 11,
+	DUMP_TYPE_EXTEND_12 = 12,
+	DUMP_TYPE_EXTEND_13 = 13,
+	DUMP_TYPE_EXTEND_LAST = 14
+} dumped_mem_type;
+
+#define MAX_NAME_LEN               8
+#define MAX_FULL_NAME_LEN               32
+
+/** Memory type mapping structure */
+typedef struct {
+	/** memory name */
+	u8 mem_name[MAX_NAME_LEN];
+	/** memory pointer */
+	u8 *mem_Ptr;
+	/** file structure */
+	struct file *pfile_mem;
+	/** donbe flag */
+	u8 done_flag;
+	/** dump type */
+	u8 type;
+} memory_type_mapping;
+
+memory_type_mapping bt_mem_type_mapping_tbl[] = {
+	{"ITCM", NULL, NULL, 0xF0, FW_DUMP_TYPE_MEM_ITCM},
+	{"DTCM", NULL, NULL, 0xF1, FW_DUMP_TYPE_MEM_DTCM},
+	{"SQRAM", NULL, NULL, 0xF2, FW_DUMP_TYPE_MEM_SQRAM},
+	{"APU", NULL, NULL, 0xF3, FW_DUMP_TYPE_REG_APU},
+	{"CIU", NULL, NULL, 0xF4, FW_DUMP_TYPE_REG_CIU},
+	{"ICU", NULL, NULL, 0xF5, FW_DUMP_TYPE_REG_ICU},
+	{"MAC", NULL, NULL, 0xF6, FW_DUMP_TYPE_REG_MAC},
+	{"EXT7", NULL, NULL, 0xF7},
+	{"EXT8", NULL, NULL, 0xF8},
+	{"EXT9", NULL, NULL, 0xF9},
+	{"EXT10", NULL, NULL, 0xFA},
+	{"EXT11", NULL, NULL, 0xFB},
+	{"EXT12", NULL, NULL, 0xFC},
+	{"EXT13", NULL, NULL, 0xFD},
+	{"EXTLAST", NULL, NULL, 0xFE},
+};
+
+typedef enum {
+	RDWR_STATUS_SUCCESS = 0,
+	RDWR_STATUS_FAILURE = 1,
+	RDWR_STATUS_DONE = 2
+} rdwr_status;
+
+/**
+ *  @brief This function read/write firmware via cmd52
+ *
+ *  @param phandle   A pointer to moal_handle
+ *
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+rdwr_status
+bt_cmd52_rdwr_firmware(bt_private *priv, u8 doneflag)
+{
+	int ret = 0;
+	int tries = 0;
+	u8 ctrl_data = 0;
+	u8 dbg_dump_ctrl_reg = 0;
+
+	dbg_dump_ctrl_reg = DEBUG_DUMP_CTRL_REG;
+
+	ret = sd_write_reg(priv, dbg_dump_ctrl_reg, DEBUG_HOST_READY);
+	if (ret) {
+		PRINTM(ERROR, "SDIO Write ERR\n");
+		return RDWR_STATUS_FAILURE;
+	}
+	for (tries = 0; tries < DUMP_MAX_POLL_TRIES; tries++) {
+		ret = sd_read_reg(priv, dbg_dump_ctrl_reg, &ctrl_data);
+		if (ret) {
+			PRINTM(ERROR, "SDIO READ ERR\n");
+			return RDWR_STATUS_FAILURE;
+		}
+		if (ctrl_data == DEBUG_FW_DONE)
+			break;
+		if (doneflag && ctrl_data == doneflag)
+			return RDWR_STATUS_DONE;
+		if (ctrl_data != DEBUG_HOST_READY) {
+			PRINTM(INFO,
+			       "The ctrl reg was changed, re-try again!\n");
+			ret = sd_write_reg(priv, dbg_dump_ctrl_reg,
+					   DEBUG_HOST_READY);
+			if (ret) {
+				PRINTM(ERROR, "SDIO Write ERR\n");
+				return RDWR_STATUS_FAILURE;
+			}
+		}
+		udelay(100);
+	}
+	if (ctrl_data == DEBUG_HOST_READY) {
+		PRINTM(ERROR, "Fail to pull ctrl_data\n");
+		return RDWR_STATUS_FAILURE;
+	}
+
+	return RDWR_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function dump firmware memory to file
+ *
+ *  @param phandle   A pointer to moal_handle
+ *
+ *  @return         N/A
+ */
+void
+bt_dump_firmware_info_v2(bt_private *priv)
+{
+	int ret = 0;
+	unsigned int reg, reg_start, reg_end;
+	u8 *dbg_ptr = NULL;
+	u8 dump_num = 0;
+	u8 idx = 0;
+	u8 doneflag = 0;
+	rdwr_status stat;
+	u8 i = 0;
+	u8 read_reg = 0;
+	u32 memory_size = 0;
+	u8 path_name[64], file_name[32];
+	u8 *end_ptr = NULL;
+	u8 dbg_dump_start_reg = 0;
+	u8 dbg_dump_end_reg = 0;
+
+	if (!priv) {
+		PRINTM(ERROR, "Could not dump firmwware info\n");
+		return;
+	}
+
+	memset(path_name, 0, sizeof(path_name));
+	strcpy((char *)path_name, "/data");
+	PRINTM(MSG, "Create DUMP directory success:dir_name=%s\n", path_name);
+
+	dbg_dump_start_reg = DEBUG_DUMP_START_REG;
+	dbg_dump_end_reg = DEBUG_DUMP_END_REG;
+
+	sbi_wakeup_firmware(priv);
+	priv->fw_dump = TRUE;
+	/* start dump fw memory */
+	PRINTM(MSG, "==== DEBUG MODE OUTPUT START ====\n");
+	/* read the number of the memories which will dump */
+	if (RDWR_STATUS_FAILURE == bt_cmd52_rdwr_firmware(priv, doneflag))
+		goto done;
+	reg = dbg_dump_start_reg;
+	ret = sd_read_reg(priv, reg, &dump_num);
+	if (ret) {
+		PRINTM(MSG, "SDIO READ MEM NUM ERR\n");
+		goto done;
+	}
+	if (dump_num >
+	    (sizeof(bt_mem_type_mapping_tbl) / sizeof(memory_type_mapping))) {
+		PRINTM(MSG, "Invalid dump_num=%d\n", dump_num);
+		return;
+	}
+
+	/* read the length of every memory which will dump */
+	for (idx = 0; idx < dump_num; idx++) {
+		if (RDWR_STATUS_FAILURE ==
+		    bt_cmd52_rdwr_firmware(priv, doneflag))
+			goto done;
+		memory_size = 0;
+		reg = dbg_dump_start_reg;
+		for (i = 0; i < 4; i++) {
+			ret = sd_read_reg(priv, reg, &read_reg);
+			if (ret) {
+				PRINTM(MSG, "SDIO READ ERR\n");
+				goto done;
+			}
+			memory_size |= (read_reg << i * 8);
+			reg++;
+		}
+		if (memory_size == 0) {
+			PRINTM(MSG, "Firmware Dump Finished!\n");
+			break;
+		} else {
+			PRINTM(MSG, "%s_SIZE=0x%x\n",
+			       bt_mem_type_mapping_tbl[idx].mem_name,
+			       memory_size);
+			bt_mem_type_mapping_tbl[idx].mem_Ptr =
+				vmalloc(memory_size + 1);
+			if ((ret != BT_STATUS_SUCCESS) ||
+			    !bt_mem_type_mapping_tbl[idx].mem_Ptr) {
+				PRINTM(ERROR,
+				       "Error: vmalloc %s buffer failed!!!\n",
+				       bt_mem_type_mapping_tbl[idx].mem_name);
+				goto done;
+			}
+			dbg_ptr = bt_mem_type_mapping_tbl[idx].mem_Ptr;
+			end_ptr = dbg_ptr + memory_size;
+		}
+		doneflag = bt_mem_type_mapping_tbl[idx].done_flag;
+		PRINTM(MSG, "Start %s output, please wait...\n",
+		       bt_mem_type_mapping_tbl[idx].mem_name);
+		do {
+			stat = bt_cmd52_rdwr_firmware(priv, doneflag);
+			if (RDWR_STATUS_FAILURE == stat)
+				goto done;
+
+			reg_start = dbg_dump_start_reg;
+			reg_end = dbg_dump_end_reg;
+			for (reg = reg_start; reg <= reg_end; reg++) {
+				ret = sd_read_reg(priv, reg, dbg_ptr);
+				if (ret) {
+					PRINTM(MSG, "SDIO READ ERR\n");
+					goto done;
+				}
+				if (dbg_ptr < end_ptr)
+					dbg_ptr++;
+				else
+					PRINTM(MSG,
+					       "pre-allocced buf is not enough\n");
+			}
+			if (RDWR_STATUS_DONE == stat) {
+				PRINTM(MSG, "%s done:"
+				       "size = 0x%x\n",
+				       bt_mem_type_mapping_tbl[idx].mem_name,
+				       (unsigned int)(dbg_ptr -
+						      bt_mem_type_mapping_tbl
+						      [idx].mem_Ptr));
+				memset(file_name, 0, sizeof(file_name));
+				snprintf((char *)file_name, sizeof(file_name),
+					 "%s%s", "file_bt_",
+					 bt_mem_type_mapping_tbl[idx].mem_name);
+				if (BT_STATUS_SUCCESS !=
+				    bt_save_dump_info_to_file((char *)path_name,
+							      (char *)file_name,
+							      bt_mem_type_mapping_tbl
+							      [idx].mem_Ptr,
+							      memory_size))
+					PRINTM(MSG,
+					       "Can't save dump file %s in %s\n",
+					       file_name, path_name);
+				vfree(bt_mem_type_mapping_tbl[idx].mem_Ptr);
+				bt_mem_type_mapping_tbl[idx].mem_Ptr = NULL;
+				break;
+			}
+		} while (1);
+	}
+	PRINTM(MSG, "==== DEBUG MODE OUTPUT END ====\n");
+	/* end dump fw memory */
+done:
+	priv->fw_dump = FALSE;
+	for (idx = 0; idx < dump_num; idx++) {
+		if (bt_mem_type_mapping_tbl[idx].mem_Ptr) {
+			vfree(bt_mem_type_mapping_tbl[idx].mem_Ptr);
+			bt_mem_type_mapping_tbl[idx].mem_Ptr = NULL;
+		}
+	}
+	PRINTM(MSG, "==== DEBUG MODE END ====\n");
+	return;
+}
+
+/**
+ *  @brief This function shows debug info for timeout of command sending.
+ *
+ *  @param adapter  A pointer to bt_private
+ *  @param cmd      Timeout command id
+ *
+ *  @return         N/A
+ */
+static void
+bt_cmd_timeout_func(bt_private *priv, u16 cmd)
+{
+	bt_adapter *adapter = priv->adapter;
+	ENTER();
+
+	adapter->num_cmd_timeout++;
+
+	PRINTM(ERROR, "Version = %s\n", adapter->drv_ver);
+	PRINTM(ERROR, "Timeout Command id = 0x%x\n", cmd);
+	PRINTM(ERROR, "Number of command timeout = %d\n",
+	       adapter->num_cmd_timeout);
+	PRINTM(ERROR, "Interrupt counter = %d\n", adapter->IntCounter);
+	PRINTM(ERROR, "Power Save mode = %d\n", adapter->psmode);
+	PRINTM(ERROR, "Power Save state = %d\n", adapter->ps_state);
+	PRINTM(ERROR, "Host Sleep state = %d\n", adapter->hs_state);
+	PRINTM(ERROR, "hs skip count = %d\n", adapter->hs_skip);
+	PRINTM(ERROR, "suspend_fail flag = %d\n", adapter->suspend_fail);
+	PRINTM(ERROR, "suspended flag = %d\n", adapter->is_suspended);
+	PRINTM(ERROR, "Number of wakeup tries = %d\n", adapter->WakeupTries);
+	PRINTM(ERROR, "Host Cmd complet state = %d\n", adapter->cmd_complete);
+	PRINTM(ERROR, "Last irq recv = %d\n", adapter->irq_recv);
+	PRINTM(ERROR, "Last irq processed = %d\n", adapter->irq_done);
+	PRINTM(ERROR, "tx pending = %d\n", adapter->skb_pending);
+	PRINTM(ERROR, "sdio int status = %d\n", adapter->sd_ireg);
+	bt_dump_sdio_regs(priv);
+	LEAVE();
+}
+
+/**
+ *  @brief This function queue frame
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to sk_buff structure
+ *
+ *  @return    N/A
+ */
+static void
+bt_queue_frame(bt_private *priv, struct sk_buff *skb)
+{
+	skb_queue_tail(&priv->adapter->tx_queue, skb);
+}
+
+/**
+ *  @brief This function send reset cmd to firmware
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return	       BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_reset_command(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_HCI_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_HCI_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_HCI_CMD *)skb->data;
+	pcmd->ocf_ogf = __cpu_to_le16((RESET_OGF << 10) | BT_CMD_RESET);
+	pcmd->length = 0x00;
+	pcmd->cmd_type = 0x00;
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, 3);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	PRINTM(CMD, "Queue Reset Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Reset timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_RESET);
+	} else {
+		PRINTM(CMD, "BT: Reset Command done\n");
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sends module cfg cmd to firmware
+ *
+ *  Command format:
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     OCF OGF     | Length |                Data               |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     2-byte      | 1-byte |               4-byte              |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param subcmd  sub command
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_module_cfg_cmd(bt_private *priv, int subcmd)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "BT: No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_MODULE_CFG_REQ);
+	pcmd->length = 1;
+	pcmd->data[0] = subcmd;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	PRINTM(CMD, "Queue module cfg Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	/*
+	   On some Android platforms certain delay is needed for HCI daemon to
+	   remove this module and close itself gracefully. Otherwise it hangs.
+	   This 10ms delay is a workaround for such platforms as the root cause
+	   has not been found yet. */
+	mdelay(10);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: module_cfg_cmd(%#x): timeout sendcmdflag=%d\n",
+		       subcmd, priv->bt_dev.sendcmdflag);
+		bt_cmd_timeout_func(priv, BT_CMD_MODULE_CFG_REQ);
+	} else {
+		PRINTM(CMD, "BT: module cfg Command done\n");
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function to get histogram
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_get_histogram(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf = __cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_HISTOGRAM);
+	pcmd->length = 0;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue Histogram cmd(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	priv->hist_data_len = 0;
+	memset(priv->hist_data, 0, sizeof(priv->hist_data));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: histogram timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_HISTOGRAM);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function enables power save mode
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_ps(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_AUTO_SLEEP_MODE);
+	if (priv->bt_dev.psmode)
+		pcmd->data[0] = BT_PS_ENABLE;
+	else
+		pcmd->data[0] = BT_PS_DISABLE;
+	if (priv->bt_dev.idle_timeout) {
+		pcmd->length = 3;
+		pcmd->data[1] = (u8)(priv->bt_dev.idle_timeout & 0x00ff);
+		pcmd->data[2] = (priv->bt_dev.idle_timeout & 0xff00) >> 8;
+	} else {
+		pcmd->length = 1;
+	}
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue PSMODE Command(0x%x):%d\n",
+	       __le16_to_cpu(pcmd->ocf_ogf), pcmd->data[0]);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: psmode timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_AUTO_SLEEP_MODE);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sends hscfg command
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_hscfg_cmd(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_HOST_SLEEP_CONFIG);
+	pcmd->length = 2;
+	pcmd->data[0] = (priv->bt_dev.gpio_gap & 0xff00) >> 8;
+	pcmd->data[1] = (u8)(priv->bt_dev.gpio_gap & 0x00ff);
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue HSCFG Command(0x%x),gpio=0x%x,gap=0x%x\n",
+	       __le16_to_cpu(pcmd->ocf_ogf), pcmd->data[0], pcmd->data[1]);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: HSCFG timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_HOST_SLEEP_CONFIG);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sends sdio pull ctrl command
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_sdio_pull_ctrl_cmd(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_SDIO_PULL_CFG_REQ);
+	pcmd->length = 4;
+	pcmd->data[0] = (priv->bt_dev.sdio_pull_cfg & 0x000000ff);
+	pcmd->data[1] = (priv->bt_dev.sdio_pull_cfg & 0x0000ff00) >> 8;
+	pcmd->data[2] = (priv->bt_dev.sdio_pull_cfg & 0x00ff0000) >> 16;
+	pcmd->data[3] = (priv->bt_dev.sdio_pull_cfg & 0xff000000) >> 24;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD,
+	       "Queue SDIO PULL CFG Command(0x%x), PullUp=0x%x%x,PullDown=0x%x%x\n",
+	       __le16_to_cpu(pcmd->ocf_ogf), pcmd->data[1], pcmd->data[0],
+	       pcmd->data[3], pcmd->data[2]);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: SDIO PULL CFG timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_SDIO_PULL_CFG_REQ);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sends command to configure PMIC
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_pmic_configure(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_PMIC_CONFIGURE);
+	pcmd->length = 0;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue PMIC Configure Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: PMIC Configure timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_PMIC_CONFIGURE);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function enables host sleep
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param is_shutdown  indicate shutdown mode
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_hs(bt_private *priv, bool is_shutdown)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	priv->adapter->suspend_fail = FALSE;
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_HOST_SLEEP_ENABLE);
+	pcmd->length = 0;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->adapter->wait_event_timeout = is_shutdown;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	PRINTM(CMD, "Queue hs enable Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (is_shutdown) {
+		if (!os_wait_timeout
+		    (priv->adapter->cmd_wait_q, priv->adapter->hs_state,
+		     WAIT_UNTIL_HS_STATE_CHANGED)) {
+			PRINTM(MSG, "BT: Enable host sleep timeout:\n");
+			priv->adapter->wait_event_timeout = FALSE;
+			bt_cmd_timeout_func(priv, BT_CMD_HOST_SLEEP_ENABLE);
+		}
+	} else {
+		if (!os_wait_interruptible_timeout
+		    (priv->adapter->cmd_wait_q, priv->adapter->hs_state,
+		     WAIT_UNTIL_HS_STATE_CHANGED)) {
+			PRINTM(MSG, "BT: Enable host sleep timeout:\n");
+			bt_cmd_timeout_func(priv, BT_CMD_HOST_SLEEP_ENABLE);
+		}
+	}
+	OS_INT_DISABLE;
+	if ((priv->adapter->hs_state == HS_ACTIVATED) ||
+	    (priv->adapter->is_suspended == TRUE)) {
+		OS_INT_RESTORE;
+		PRINTM(MSG, "BT: suspend success! skip=%d\n",
+		       priv->adapter->hs_skip);
+	} else {
+		priv->adapter->suspend_fail = TRUE;
+		OS_INT_RESTORE;
+		priv->adapter->hs_skip++;
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG,
+		       "BT: suspend skipped! "
+		       "state=%d skip=%d ps_state= %d WakeupTries=%d\n",
+		       priv->adapter->hs_state, priv->adapter->hs_skip,
+		       priv->adapter->ps_state, priv->adapter->WakeupTries);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function Set Evt Filter
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_set_evt_filter(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf = __cpu_to_le16((0x03 << 10) | BT_CMD_SET_EVT_FILTER);
+	pcmd->length = 0x03;
+	pcmd->data[0] = 0x02;
+	pcmd->data[1] = 0x00;
+	pcmd->data[2] = 0x03;
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue Set Evt Filter Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+					   priv->adapter->cmd_complete,
+					   WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Set Evt Filter timeout\n");
+		bt_cmd_timeout_func(priv, BT_CMD_SET_EVT_FILTER);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function Enable Write Scan - Page and Inquiry
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_write_scan(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf = __cpu_to_le16((0x03 << 10) | BT_CMD_ENABLE_WRITE_SCAN);
+	pcmd->length = 0x01;
+	pcmd->data[0] = 0x03;
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue Enable Write Scan Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+					   priv->adapter->cmd_complete,
+					   WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Enable Write Scan timeout\n");
+		bt_cmd_timeout_func(priv, BT_CMD_ENABLE_WRITE_SCAN);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function Enable Device under test mode
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_device_under_testmode(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((0x06 << 10) | BT_CMD_ENABLE_DEVICE_TESTMODE);
+	pcmd->length = 0x00;
+	bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	PRINTM(CMD, "Queue enable device under testmode Command(0x%x)\n",
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+					   priv->adapter->cmd_complete,
+					   WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Enable Device under TEST mode timeout\n");
+		bt_cmd_timeout_func(priv, BT_CMD_ENABLE_DEVICE_TESTMODE);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function enables test mode and send cmd
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_test_mode(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+
+	/** Set Evt Filter Command */
+	ret = bt_set_evt_filter(priv);
+	if (ret != BT_STATUS_SUCCESS) {
+		PRINTM(ERROR, "BT test_mode: Set Evt filter fail\n");
+		goto exit;
+	}
+
+	/** Enable Write Scan Command */
+	ret = bt_enable_write_scan(priv);
+	if (ret != BT_STATUS_SUCCESS) {
+		PRINTM(ERROR, "BT test_mode: Enable Write Scan fail\n");
+		goto exit;
+	}
+
+	/** Enable Device under test mode */
+	ret = bt_enable_device_under_testmode(priv);
+	if (ret != BT_STATUS_SUCCESS)
+		PRINTM(ERROR,
+		       "BT test_mode: Enable device under testmode fail\n");
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+#define DISABLE_RESET  0x0
+#define ENABLE_OUTBAND_RESET 0x1
+#define ENABLE_INBAND_RESET  0x02
+#define DEFAULT_GPIO 0xff
+/**
+ *  @brief This function set GPIO pin
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_set_independent_reset(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	u8 mode, gpio;
+	BT_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_INDEPENDENT_RESET);
+	mode = btindrst & 0xff;
+	gpio = (btindrst & 0xff00) >> 8;
+	if (mode == ENABLE_OUTBAND_RESET) {
+		pcmd->data[0] = ENABLE_OUTBAND_RESET;
+		if (!gpio)
+			pcmd->data[1] = DEFAULT_GPIO;
+		else
+			pcmd->data[1] = gpio;
+	} else if (mode == ENABLE_INBAND_RESET) {
+		pcmd->data[0] = ENABLE_INBAND_RESET;
+		pcmd->data[1] = DEFAULT_GPIO;
+	} else if (mode == DISABLE_RESET) {
+		pcmd->data[0] = DISABLE_RESET;
+		pcmd->data[1] = DEFAULT_GPIO;
+	} else {
+		PRINTM(WARN, "Unsupport mode\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	PRINTM(CMD, "BT: independant reset mode=%d gpio=%d\n", mode, gpio);
+	pcmd->length = 2;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+					   priv->adapter->cmd_complete,
+					   WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Independent reset : timeout!\n");
+		bt_cmd_timeout_func(priv, BT_CMD_INDEPENDENT_RESET);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sets ble deepsleep mode
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param mode    TRUE/FALSE
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_set_ble_deepsleep(bt_private *priv, int mode)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_BLE_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_BLE_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_BLE_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_BLE_DEEP_SLEEP);
+	pcmd->length = 1;
+	pcmd->deepsleep = mode;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, sizeof(BT_BLE_CMD));
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	PRINTM(CMD, "BT: Set BLE deepsleep = %d (0x%x)\n", mode,
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Set BLE deepsleep timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_BLE_DEEP_SLEEP);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function gets FW version
+ *
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_get_fw_version(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_HCI_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_HCI_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_HCI_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_GET_FW_VERSION);
+	pcmd->length = 0x01;
+	pcmd->cmd_type = 0x00;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, 4);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+					   priv->adapter->cmd_complete,
+					   WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Get FW version: timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_GET_FW_VERSION);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sets mac address
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param mac     A pointer to mac address
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_set_mac_address(bt_private *priv, u8 *mac)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_HCI_CMD *pcmd;
+	int i = 0;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_HCI_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_HCI_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_CONFIG_MAC_ADDR);
+	pcmd->length = 8;
+	pcmd->cmd_type = MRVL_VENDOR_PKT;
+	pcmd->cmd_len = 6;
+	for (i = 0; i < 6; i++)
+		pcmd->data[i] = mac[5 - i];
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, sizeof(BT_HCI_CMD));
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	PRINTM(CMD, "BT: Set mac addr " MACSTR " (0x%x)\n", MAC2STR(mac),
+	       __le16_to_cpu(pcmd->ocf_ogf));
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(MSG, "BT: Set mac addr: timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_CONFIG_MAC_ADDR);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function load the calibrate EXT data
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param config_data     A pointer to calibrate data
+ *  @param mac     A pointer to mac address
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_commands(bt_private *priv, u8 *cmd_data, u32 cmd_len)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	u16 ogf = 0;
+
+	ENTER();
+	PRINTM(CMD, "BT: init cmds: len=%d\n", cmd_len);
+	if (cmd_len > BT_CMD_DATA_LEN) {
+		PRINTM(WARN, "cfg_data_len is too long exceed %d.\n",
+		       BT_CMD_DATA_LEN);
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	memcpy(skb->data, cmd_data, cmd_len);
+	pcmd = (BT_CMD *)skb->data;
+
+	ogf = hci_opcode_ogf(pcmd->ocf_ogf);
+	if (ogf == VENDOR_OGF)
+		bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	else
+		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+
+	DBG_HEXDUMP(DAT_D, "init_cmds", skb->data, skb->len);
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(ERROR, "BT: Load init cmds: timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_LOAD_CONFIG_DATA_EXT);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function load the calibrate data
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param config_data     A pointer to calibrate data
+ *  @param mac     A pointer to mac address
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_load_cal_data(bt_private *priv, u8 *config_data, u8 *mac)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+	int i = 0;
+	/* u8 config_data[28] = {0x37 0x01 0x1c 0x00 0xFF 0xFF 0xFF 0xFF 0x01
+	   0x7f 0x04 0x02 0x00 0x00 0xBA 0xCE 0xC0 0xC6 0x2D 0x00 0x00 0x00
+	   0x00 0x00 0x00 0x00 0xF0}; */
+
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_LOAD_CONFIG_DATA);
+	pcmd->length = 0x20;
+	pcmd->data[0] = 0x00;
+	pcmd->data[1] = 0x00;
+	pcmd->data[2] = 0x00;
+	pcmd->data[3] = 0x1C;
+	/* swip cal-data byte */
+	for (i = 4; i < 32; i++)
+		pcmd->data[i] = *(config_data + ((i / 4) * 8 - 1 - i));
+	if (mac != NULL) {
+		pcmd->data[2] = 0x01;	/* skip checksum */
+		for (i = 24; i < 30; i++)
+			pcmd->data[i] = mac[29 - i];
+	}
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+
+	DBG_HEXDUMP(DAT_D, "calirate data: ", pcmd->data, 32);
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(ERROR, "BT: Load calibrate data: timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_LOAD_CONFIG_DATA);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function load the calibrate EXT data
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param config_data     A pointer to calibrate data
+ *  @param mac     A pointer to mac address
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_load_cal_data_ext(bt_private *priv, u8 *config_data, u32 cfg_data_len)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CMD *pcmd;
+
+	ENTER();
+
+	if (cfg_data_len > BT_CMD_DATA_LEN) {
+		PRINTM(WARN, "cfg_data_len is too long exceed %d.\n",
+		       BT_CMD_DATA_LEN);
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+
+	skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_LOAD_CONFIG_DATA_EXT);
+	pcmd->length = cfg_data_len;
+
+	memcpy(pcmd->data, config_data, cfg_data_len);
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, BT_CMD_HEADER_SIZE + pcmd->length);
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+
+	DBG_HEXDUMP(DAT_D, "calirate ext data", pcmd->data, pcmd->length);
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(ERROR, "BT: Load calibrate ext data: timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_LOAD_CONFIG_DATA_EXT);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function writes value to CSU registers
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param type    reg type
+ *  @param offset  register address
+ *  @param value   register value to write
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_write_reg(bt_private *priv, u8 type, u32 offset, u16 value)
+{
+	struct sk_buff *skb = NULL;
+	int ret = BT_STATUS_SUCCESS;
+	BT_CSU_CMD *pcmd;
+	ENTER();
+	skb = bt_skb_alloc(sizeof(BT_CSU_CMD), GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "No free skb\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	pcmd = (BT_CSU_CMD *)skb->data;
+	pcmd->ocf_ogf =
+		__cpu_to_le16((VENDOR_OGF << 10) | BT_CMD_CSU_WRITE_REG);
+	pcmd->length = 7;
+	pcmd->type = type;
+	pcmd->offset[0] = (offset & 0x000000ff);
+	pcmd->offset[1] = (offset & 0x0000ff00) >> 8;
+	pcmd->offset[2] = (offset & 0x00ff0000) >> 16;
+	pcmd->offset[3] = (offset & 0xff000000) >> 24;
+	pcmd->value[0] = (value & 0x00ff);
+	pcmd->value[1] = (value & 0xff00) >> 8;
+	bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+	skb_put(skb, sizeof(BT_CSU_CMD));
+	skb->dev = (void *)(&(priv->bt_dev.m_dev[BT_SEQ]));
+	skb_queue_head(&priv->adapter->tx_queue, skb);
+	priv->bt_dev.sendcmdflag = TRUE;
+	priv->bt_dev.send_cmd_opcode = __le16_to_cpu(pcmd->ocf_ogf);
+	priv->adapter->cmd_complete = FALSE;
+	PRINTM(CMD, "BT: Set CSU reg type=%d reg=0x%x value=0x%x\n",
+	       type, offset, value);
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	if (!os_wait_interruptible_timeout
+	    (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+	     WAIT_UNTIL_CMD_RESP)) {
+		ret = BT_STATUS_FAILURE;
+		PRINTM(ERROR, "BT: Set CSU reg timeout:\n");
+		bt_cmd_timeout_func(priv, BT_CMD_CSU_WRITE_REG);
+	}
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function used to restore tx_queue
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        N/A
+ */
+void
+bt_restore_tx_queue(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	while (!skb_queue_empty(&priv->adapter->pending_queue)) {
+		skb = skb_dequeue(&priv->adapter->pending_queue);
+		if (skb)
+			bt_queue_frame(priv, skb);
+	}
+	wake_up_interruptible(&priv->MainThread.waitQ);
+}
+
+/**
+ *  @brief This function used to send command to firmware
+ *
+ *  Command format:
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     OCF OGF     | Length |                Data               |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     2-byte      | 1-byte |               4-byte              |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_prepare_command(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	ENTER();
+	if (priv->bt_dev.hscfgcmd) {
+		priv->bt_dev.hscfgcmd = 0;
+		ret = bt_send_hscfg_cmd(priv);
+	}
+	if (priv->bt_dev.pscmd) {
+		priv->bt_dev.pscmd = 0;
+		ret = bt_enable_ps(priv);
+	}
+	if (priv->bt_dev.sdio_pull_ctrl) {
+		priv->bt_dev.sdio_pull_ctrl = 0;
+		ret = bt_send_sdio_pull_ctrl_cmd(priv);
+	}
+	if (priv->bt_dev.hscmd) {
+		priv->bt_dev.hscmd = 0;
+		if (priv->bt_dev.hsmode)
+			ret = bt_enable_hs(priv, FALSE);
+		else {
+			ret = sbi_wakeup_firmware(priv);
+			priv->adapter->hs_state = HS_DEACTIVATED;
+		}
+	}
+	if (priv->bt_dev.test_mode) {
+		priv->bt_dev.test_mode = 0;
+		ret = bt_enable_test_mode(priv);
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief Update tx state
+ *
+ * @param priv          A pointer to bt_private structure
+ * @param skb			A pointer to sk_buff structure
+ *
+ * @return                N/A
+ */
+static void
+update_stat_byte_tx(bt_private *priv, struct sk_buff *skb)
+{
+	((struct hci_dev *)priv->bt_dev.m_dev[BT_SEQ].dev_pointer)->stat.
+		byte_tx += skb->len;
+}
+
+/**
+ * @brief Update tx error state
+ *
+ * @param priv          A pointer to bt_private structure
+ * @param skb			A pointer to sk_buff structure
+ *
+ * @return                N/A
+ */
+static void
+update_stat_err_tx(bt_private *priv, struct sk_buff *skb)
+{
+	((struct hci_dev *)priv->bt_dev.m_dev[BT_SEQ].dev_pointer)->stat.
+		err_tx++;
+}
+
+/** @brief This function processes a single packet
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+send_single_packet(bt_private *priv, struct sk_buff *skb)
+{
+	int ret;
+	struct sk_buff *new_skb = NULL;
+	ENTER();
+	if (!skb || !skb->data) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+
+	if (!skb->len || ((skb->len + BT_HEADER_LEN) > BT_UPLD_SIZE)) {
+		PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n", skb->len,
+		       BT_UPLD_SIZE);
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	if (skb_headroom(skb) < BT_HEADER_LEN) {
+		new_skb = skb_realloc_headroom(skb, BT_HEADER_LEN);
+		if (!new_skb) {
+			PRINTM(ERROR, "TX error: realloc_headroom failed %d\n",
+			       BT_HEADER_LEN);
+			kfree_skb(skb);
+			LEAVE();
+			return BT_STATUS_FAILURE;
+		} else {
+			if (new_skb != skb)
+				dev_kfree_skb_any(skb);
+			skb = new_skb;
+		}
+	}
+	/* This is SDIO/PCIE specific header length: byte[3][2][1], * type:
+	   byte[0] (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor)
+	 */
+	skb_push(skb, BT_HEADER_LEN);
+	skb->data[0] = (skb->len & 0x0000ff);
+	skb->data[1] = (skb->len & 0x00ff00) >> 8;
+	skb->data[2] = (skb->len & 0xff0000) >> 16;
+	skb->data[3] = bt_cb(skb)->pkt_type;
+	if (bt_cb(skb)->pkt_type == MRVL_VENDOR_PKT)
+		PRINTM(CMD, "DNLD_CMD: ocf_ogf=0x%x len=%d\n",
+		       __le16_to_cpu(*((u16 *) & skb->data[4])), skb->len);
+	ret = sbi_host_to_card(priv, skb->data, skb->len);
+	if (ret == BT_STATUS_FAILURE)
+		update_stat_err_tx(priv, skb);
+	else
+		update_stat_byte_tx(priv, skb);
+	if (ret != BT_STATUS_PENDING)
+		kfree_skb(skb);
+	LEAVE();
+	return ret;
+}
+
+#ifdef CONFIG_OF
+/**
+ *  @brief This function read the initial parameter from device tress
+ *
+ *
+ *  @return         N/A
+ */
+static void
+bt_init_from_dev_tree(void)
+{
+	struct device_node *dt_node = NULL;
+	struct property *prop;
+	u32 data;
+	const char *string_data;
+
+	ENTER();
+
+	if (!dts_enable) {
+		PRINTM(CMD, "DTS is disabled!");
+		return;
+	}
+
+	dt_node = of_find_node_by_name(NULL, "sd8xxx-bt");
+	if (!dt_node) {
+		LEAVE();
+		return;
+	}
+	for_each_property_of_node(dt_node, prop) {
+#ifdef DEBUG_LEVEL1
+		if (!strncmp(prop->name, "mbt_drvdbg", strlen("mbt_drvdbg"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(CMD, "mbt_drvdbg=0x%x\n", data);
+				mbt_drvdbg = data;
+			}
+		}
+#endif
+		else if (!strncmp(prop->name, "init_cmds", strlen("init_cmds"))) {
+			if (!of_property_read_string
+			    (dt_node, prop->name, &string_data)) {
+				init_cmds = (char *)string_data;
+				PRINTM(CMD, "init_cmds=%s\n", init_cmds);
+			}
+		} else if (!strncmp(prop->name, "init_cfg", strlen("init_cfg"))) {
+			if (!of_property_read_string
+			    (dt_node, prop->name, &string_data)) {
+				init_cfg = (char *)string_data;
+				PRINTM(CMD, "init_cfg=%s\n", init_cfg);
+			}
+		} else if (!strncmp
+			   (prop->name, "cal_cfg_ext", strlen("cal_cfg_ext"))) {
+			if (!of_property_read_string
+			    (dt_node, prop->name, &string_data)) {
+				cal_cfg_ext = (char *)string_data;
+				PRINTM(CMD, "cal_cfg_ext=%s\n", cal_cfg_ext);
+			}
+		} else if (!strncmp(prop->name, "cal_cfg", strlen("cal_cfg"))) {
+			if (!of_property_read_string
+			    (dt_node, prop->name, &string_data)) {
+				cal_cfg = (char *)string_data;
+				PRINTM(CMD, "cal_cfg=%s\n", cal_cfg);
+			}
+		} else if (!strncmp(prop->name, "bt_mac", strlen("bt_mac"))) {
+			if (!of_property_read_string
+			    (dt_node, prop->name, &string_data)) {
+				bt_mac = (char *)string_data;
+				PRINTM(CMD, "bt_mac=%s\n", bt_mac);
+			}
+		} else if (!strncmp(prop->name, "btindrst", strlen("btindrst"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				btindrst = data;
+				PRINTM(CMD, "btindrst=%d\n", btindrst);
+			}
+		} else if (!strncmp(prop->name, "btpmic", strlen("btpmic"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				btpmic = data;
+				PRINTM(CMD, "btpmic=%d\n", btpmic);
+			}
+		}
+	}
+	LEAVE();
+	return;
+}
+#endif
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    N/A
+ */
+static void
+bt_init_adapter(bt_private *priv)
+{
+	ENTER();
+#ifdef CONFIG_OF
+	bt_init_from_dev_tree();
+#endif
+	skb_queue_head_init(&priv->adapter->tx_queue);
+	skb_queue_head_init(&priv->adapter->pending_queue);
+	priv->adapter->tx_lock = FALSE;
+	priv->adapter->ps_state = PS_AWAKE;
+	priv->adapter->suspend_fail = FALSE;
+	priv->adapter->is_suspended = FALSE;
+	priv->adapter->hs_skip = 0;
+	priv->adapter->num_cmd_timeout = 0;
+	priv->adapter->fwdump_fname = NULL;
+	init_waitqueue_head(&priv->adapter->cmd_wait_q);
+	LEAVE();
+}
+
+/**
+ *  @brief This function initializes firmware
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_fw(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	ENTER();
+	if (fw == 0) {
+		sbi_enable_host_int(priv);
+		goto done;
+	}
+	sbi_disable_host_int(priv);
+	if (sbi_download_fw(priv)) {
+		PRINTM(ERROR, " FW failed to be download!\n");
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+done:
+	LEAVE();
+	return ret;
+}
+
+#define FW_POLL_TRIES 100
+#define FW_RESET_REG  0x0EE
+#define FW_RESET_VAL  0x99
+
+/**
+ *  @brief This function reload firmware
+ *
+ *  @param priv   A pointer to bt_private
+ *  @param mode   FW reload mode
+ *
+ *  @return       0--success, otherwise failure
+ */
+static int
+bt_reload_fw(bt_private *priv, int mode)
+{
+	int ret = 0, tries = 0;
+	u8 value = 1;
+	u32 reset_reg = FW_RESET_REG;
+	u8 reset_val = FW_RESET_VAL;
+
+	ENTER();
+	if ((mode != FW_RELOAD_SDIO_INBAND_RESET) &&
+	    (mode != FW_RELOAD_NO_EMULATION)) {
+		PRINTM(ERROR, "Invalid fw reload mode=%d\n", mode);
+		return -EFAULT;
+	}
+
+    /** flush pending tx_queue */
+	skb_queue_purge(&priv->adapter->tx_queue);
+
+	priv->adapter->tx_lock = FALSE;
+	priv->adapter->ps_state = PS_AWAKE;
+	priv->adapter->suspend_fail = FALSE;
+	priv->adapter->is_suspended = FALSE;
+	priv->adapter->hs_skip = 0;
+	priv->adapter->num_cmd_timeout = 0;
+	priv->adapter->fwdump_fname = NULL;
+
+	if (mode == FW_RELOAD_SDIO_INBAND_RESET) {
+		sbi_disable_host_int(priv);
+	    /** Wake up firmware firstly */
+		sbi_wakeup_firmware(priv);
+
+	/** wait SOC fully wake up */
+		for (tries = 0; tries < FW_POLL_TRIES; ++tries) {
+			ret = sd_write_reg(priv, reset_reg, 0xba);
+			if (!ret) {
+				ret = sd_read_reg(priv, reset_reg, &value);
+				if (!ret && (value == 0xba)) {
+					PRINTM(MSG, "Fw wake up\n");
+					break;
+				}
+			}
+			udelay(1000);
+		}
+
+		ret = sd_write_reg(priv, reset_reg, reset_val);
+		if (ret) {
+			PRINTM(ERROR, "Failed to write register.\n");
+			goto done;
+		}
+
+	    /** Poll register around 1 ms */
+		for (; tries < FW_POLL_TRIES; ++tries) {
+			ret = sd_read_reg(priv, reset_reg, &value);
+			if (ret) {
+				PRINTM(ERROR, "Failed to read register.\n");
+				goto done;
+			}
+			if (value == 0)
+			    /** FW is ready */
+				break;
+			udelay(1000);
+		}
+		if (value) {
+			PRINTM(ERROR,
+			       "Failed to poll FW reset register %X=0x%x\n",
+			       reset_reg, value);
+			ret = -EFAULT;
+			goto done;
+		}
+	}
+
+	sbi_enable_host_int(priv);
+	/** reload FW */
+	ret = bt_init_fw(priv);
+	if (ret) {
+		PRINTM(ERROR, "Re download firmware failed.\n");
+		ret = -EFAULT;
+	}
+	LEAVE();
+	return ret;
+done:
+	sbi_enable_host_int(priv);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function request to reload firmware
+ *
+ *  @param priv   A pointer to bt_private
+ *  @param mode   fw reload mode.
+ *
+ *  @return         N/A
+ */
+void
+bt_request_fw_reload(bt_private *priv, int mode)
+{
+	ENTER();
+	if (mode == FW_RELOAD_WITH_EMULATION) {
+		bt_fw_reload = FW_RELOAD_WITH_EMULATION;
+		PRINTM(MSG, "BT: FW reload with re-emulation...\n");
+		LEAVE();
+		return;
+	}
+	/** Reload FW */
+	priv->fw_reload = TRUE;
+	if (bt_reload_fw(priv, mode)) {
+		PRINTM(ERROR, "FW reload fail\n");
+		goto done;
+	}
+	priv->fw_reload = FALSE;
+	/** Other operation here? */
+done:
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function frees the structure of adapter
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return    N/A
+ */
+void
+bt_free_adapter(bt_private *priv)
+{
+	bt_adapter *adapter = priv->adapter;
+	ENTER();
+	skb_queue_purge(&priv->adapter->tx_queue);
+	kfree(adapter->tx_buffer);
+	kfree(adapter->hw_regs_buf);
+	/* Free allocated memory for fwdump filename */
+	if (adapter->fwdump_fname) {
+		kfree(adapter->fwdump_fname);
+		adapter->fwdump_fname = NULL;
+	}
+	/* Free the adapter object itself */
+	kfree(adapter);
+	priv->adapter = NULL;
+
+	LEAVE();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+/**
+ *  @brief This function handles the BT ioctl
+ *
+ *  @param hdev     A pointer to hci_dev structure
+ *  @cmd            ioctl cmd
+ *  @arg            argument
+ *  @return    -ENOIOCTLCMD
+ */
+static int
+bt_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
+{
+	ENTER();
+	LEAVE();
+	return -ENOIOCTLCMD;
+}
+#endif
+
+/**
+ *  @brief This function handles the wrapper_dev ioctl
+ *
+ *  @param hev     A pointer to wrapper_dev structure
+ *  @cmd            ioctl cmd
+ *  @arg            argument
+ *  @return    -ENOIOCTLCMD
+ */
+static int
+mdev_ioctl(struct m_dev *m_dev, unsigned int cmd, void *arg)
+{
+	bt_private *priv = NULL;
+	int ret = 0;
+
+	ENTER();
+
+	if (!m_dev || !m_dev->driver_data) {
+		PRINTM(ERROR, "Ioctl for unknown device (m_dev=NULL)\n");
+		ret = -ENODEV;
+		goto done;
+	}
+	priv = (bt_private *)m_dev->driver_data;
+	if (!test_bit(HCI_RUNNING, &m_dev->flags)) {
+		PRINTM(ERROR, "HCI_RUNNING not set, flag=0x%lx\n",
+		       m_dev->flags);
+		ret = -EBUSY;
+		goto done;
+	}
+	PRINTM(INFO, "IOCTL: cmd=%d\n", cmd);
+	switch (cmd) {
+	case MBTCHAR_IOCTL_BT_FW_DUMP:
+		bt_dump_sdio_regs(priv);
+		bt_dump_firmware_info_v2(priv);
+		break;
+	default:
+		break;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function handles BT destruct
+ *
+ *  @param hdev    A pointer to hci_dev structure
+ *
+ *  @return    N/A
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+static void
+bt_destruct(struct hci_dev *hdev)
+{
+	ENTER();
+	LEAVE();
+	return;
+}
+#endif
+
+/**
+ *  @brief This function handles wrapper device destruct
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return    N/A
+ */
+static void
+mdev_destruct(struct m_dev *m_dev)
+{
+	ENTER();
+	LEAVE();
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+/**
+ *  @brief This function handles the BT transmit
+ *
+ *  @param skb     A pointer to sk_buff structure
+ *
+ *  @return    BT_STATUS_SUCCESS or other error no.
+ */
+static int
+bt_send_frame(struct sk_buff *skb)
+#else
+/**
+ *  @brief This function handles the BT transmit
+ *
+ *  @param hdev    A pointer to hci_dev structure
+ *  @param skb     A pointer to sk_buff structure
+ *
+ *  @return    BT_STATUS_SUCCESS or other error no.
+ */
+static int
+bt_send_frame(struct hci_dev *hdev, struct sk_buff *skb)
+#endif
+{
+	bt_private *priv = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+	struct hci_dev *hdev = (struct hci_dev *)skb->dev;
+#else
+	skb->dev = (void *)hdev;
+#endif
+
+	ENTER();
+	PRINTM(DATA, "bt_send_frame %s: Type=%d, len=%d\n", hdev->name,
+	       bt_cb(skb)->pkt_type, skb->len);
+	DBG_HEXDUMP(CMD_D, "bt_send_frame", skb->data, skb->len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	if (!hdev || !hci_get_drvdata(hdev)) {
+#else
+	if (!hdev || !hdev->driver_data) {
+#endif
+		PRINTM(ERROR, "Frame for unknown HCI device (hdev=NULL)\n");
+		LEAVE();
+		return -ENODEV;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	priv = (bt_private *)hci_get_drvdata(hdev);
+#else
+	priv = (bt_private *)hdev->driver_data;
+#endif
+	if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+		PRINTM(ERROR, "Fail test HCI_RUNNING, flag=0x%lx\n",
+		       hdev->flags);
+		LEAVE();
+		return -EBUSY;
+	}
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_COMMAND_PKT:
+		hdev->stat.cmd_tx++;
+		break;
+	case HCI_ACLDATA_PKT:
+		hdev->stat.acl_tx++;
+		break;
+	case HCI_SCODATA_PKT:
+		hdev->stat.sco_tx++;
+		break;
+	}
+	if (priv->adapter->tx_lock == TRUE)
+		skb_queue_tail(&priv->adapter->pending_queue, skb);
+	else
+		bt_queue_frame(priv, skb);
+
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the wrapper device transmit
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *  @param skb     A pointer to sk_buff structure
+ *
+ *  @return    BT_STATUS_SUCCESS or other error no.
+ */
+static int
+mdev_send_frame(struct m_dev *m_dev, struct sk_buff *skb)
+{
+	bt_private *priv = NULL;
+
+	ENTER();
+	if (!m_dev || !m_dev->driver_data) {
+		PRINTM(ERROR, "Frame for unknown HCI device (m_dev=NULL)\n");
+		LEAVE();
+		return -ENODEV;
+	}
+	priv = (bt_private *)m_dev->driver_data;
+	if (!test_bit(HCI_RUNNING, &m_dev->flags)) {
+		PRINTM(ERROR, "Fail test HCI_RUNNING, flag=0x%lx\n",
+		       m_dev->flags);
+		LEAVE();
+		return -EBUSY;
+	}
+	switch (bt_cb(skb)->pkt_type) {
+	case HCI_COMMAND_PKT:
+		m_dev->stat.cmd_tx++;
+		break;
+	case HCI_ACLDATA_PKT:
+		m_dev->stat.acl_tx++;
+		break;
+	case HCI_SCODATA_PKT:
+		m_dev->stat.sco_tx++;
+		break;
+	}
+
+	if (priv->adapter->tx_lock == TRUE)
+		skb_queue_tail(&priv->adapter->pending_queue, skb);
+	else
+		bt_queue_frame(priv, skb);
+	wake_up_interruptible(&priv->MainThread.waitQ);
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function flushes the transmit queue
+ *
+ *  @param hdev     A pointer to hci_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS
+ */
+static int
+bt_flush(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	bt_private *priv = (bt_private *)hci_get_drvdata(hdev);
+#else
+	bt_private *priv = (bt_private *)hdev->driver_data;
+#endif
+	ENTER();
+	skb_queue_purge(&priv->adapter->tx_queue);
+	skb_queue_purge(&priv->adapter->pending_queue);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function flushes the transmit queue
+ *
+ *  @param m_dev     A pointer to m_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS
+ */
+static int
+mdev_flush(struct m_dev *m_dev)
+{
+	bt_private *priv = (bt_private *)m_dev->driver_data;
+	ENTER();
+	skb_queue_purge(&priv->adapter->tx_queue);
+	skb_queue_purge(&priv->adapter->pending_queue);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function closes the bluetooth device
+ *
+ *  @param hdev    A pointer to hci_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS
+ */
+static int
+bt_close(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	bt_private *priv = (bt_private *)hci_get_drvdata(hdev);
+#else
+	bt_private *priv = (bt_private *)hdev->driver_data;
+#endif
+
+	ENTER();
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 3, 0)
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags)) {
+		LEAVE();
+		return BT_STATUS_SUCCESS;
+	}
+#endif
+	skb_queue_purge(&priv->adapter->tx_queue);
+
+	module_put(THIS_MODULE);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function closes the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS
+ */
+static int
+mdev_close(struct m_dev *m_dev)
+{
+
+	ENTER();
+	mdev_req_lock(m_dev);
+	if (!test_and_clear_bit(HCI_UP, &m_dev->flags)) {
+		mdev_req_unlock(m_dev);
+		LEAVE();
+		return 0;
+	}
+
+	if (m_dev->flush)
+		m_dev->flush(m_dev);
+	/* wait up pending read and unregister char dev */
+	wake_up_interruptible(&m_dev->req_wait_q);
+	/* Drop queues */
+	skb_queue_purge(&m_dev->rx_q);
+	if (!test_and_clear_bit(HCI_RUNNING, &m_dev->flags)) {
+		mdev_req_unlock(m_dev);
+		LEAVE();
+		return 0;
+	}
+	module_put(THIS_MODULE);
+	m_dev->flags = 0;
+	mdev_req_unlock(m_dev);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function opens the bluetooth device
+ *
+ *  @param hdev    A pointer to hci_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS  or other
+ */
+static int
+bt_open(struct hci_dev *hdev)
+{
+	ENTER();
+	if (try_module_get(THIS_MODULE) == 0)
+		return BT_STATUS_FAILURE;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4, 3, 0)
+	set_bit(HCI_RUNNING, &hdev->flags);
+#endif
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function opens the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS  or other
+ */
+static int
+mdev_open(struct m_dev *m_dev)
+{
+	ENTER();
+
+	if (try_module_get(THIS_MODULE) == 0)
+		return BT_STATUS_FAILURE;
+
+	set_bit(HCI_RUNNING, &m_dev->flags);
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function queries the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *  @param arg     arguement
+ *
+ *  @return    BT_STATUS_SUCCESS  or other
+ */
+void
+mdev_query(struct m_dev *m_dev, void *arg)
+{
+	struct mbt_dev *mbt_dev = (struct mbt_dev *)m_dev->dev_pointer;
+
+	ENTER();
+	if (copy_to_user(arg, &mbt_dev->type, sizeof(mbt_dev->type)))
+		PRINTM(ERROR, "IOCTL_QUERY_TYPE: Fail copy to user\n");
+
+	LEAVE();
+}
+
+/**
+ *  @brief This function initializes the wrapper device
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *
+ *  @return    BT_STATUS_SUCCESS  or other
+ */
+void
+init_m_dev(struct m_dev *m_dev)
+{
+	m_dev->dev_pointer = NULL;
+	m_dev->driver_data = NULL;
+	m_dev->dev_type = 0;
+	m_dev->spec_type = 0;
+	skb_queue_head_init(&m_dev->rx_q);
+	init_waitqueue_head(&m_dev->req_wait_q);
+	init_waitqueue_head(&m_dev->rx_wait_q);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)
+	init_MUTEX(&m_dev->req_lock);
+#else
+	sema_init(&m_dev->req_lock, 1);
+#endif
+	spin_lock_init(&m_dev->rxlock);
+	memset(&m_dev->stat, 0, sizeof(struct hci_dev_stats));
+	m_dev->open = mdev_open;
+	m_dev->close = mdev_close;
+	m_dev->flush = mdev_flush;
+	m_dev->send = mdev_send_frame;
+	m_dev->destruct = mdev_destruct;
+	m_dev->ioctl = mdev_ioctl;
+	m_dev->query = mdev_query;
+	m_dev->owner = THIS_MODULE;
+
+}
+
+/**
+ *  @brief This function handles the major job in bluetooth driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *
+ *  @param data    A pointer to bt_thread structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+static int
+bt_service_main_thread(void *data)
+{
+	bt_thread *thread = data;
+	bt_private *priv = thread->priv;
+	bt_adapter *adapter = priv->adapter;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 13, 0)
+	wait_queue_t wait;
+#else
+	wait_queue_entry_t wait;
+#endif
+	struct sk_buff *skb;
+	ENTER();
+	bt_activate_thread(thread);
+	init_waitqueue_entry(&wait, current);
+	current->flags |= PF_NOFREEZE;
+
+	for (;;) {
+		add_wait_queue(&thread->waitQ, &wait);
+		OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+		if (priv->adapter->WakeupTries ||
+		    ((!priv->adapter->IntCounter) &&
+		     (!priv->bt_dev.tx_dnld_rdy ||
+		      skb_queue_empty(&priv->adapter->tx_queue))
+		    )) {
+			PRINTM(INFO, "Main: Thread sleeping...\n");
+			schedule();
+		}
+		OS_SET_THREAD_STATE(TASK_RUNNING);
+		remove_wait_queue(&thread->waitQ, &wait);
+		if (kthread_should_stop() || adapter->SurpriseRemoved) {
+			PRINTM(INFO, "main-thread: break from main thread: "
+			       "SurpriseRemoved=0x%x\n",
+			       adapter->SurpriseRemoved);
+			break;
+		}
+
+		PRINTM(INFO, "Main: Thread waking up...\n");
+
+		if (priv->adapter->IntCounter) {
+			OS_INT_DISABLE;
+			adapter->IntCounter = 0;
+			OS_INT_RESTORE;
+			sbi_get_int_status(priv);
+		} else if ((priv->adapter->ps_state == PS_SLEEP) &&
+			   (!skb_queue_empty(&priv->adapter->tx_queue)
+			   )) {
+			priv->adapter->WakeupTries++;
+			sbi_wakeup_firmware(priv);
+			continue;
+		}
+		if (priv->adapter->ps_state == PS_SLEEP)
+			continue;
+		if (priv->bt_dev.tx_dnld_rdy == TRUE) {
+			if (!skb_queue_empty(&priv->adapter->tx_queue)) {
+				skb = skb_dequeue(&priv->adapter->tx_queue);
+				if (skb)
+					send_single_packet(priv, skb);
+			}
+		}
+	}
+	bt_deactivate_thread(thread);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *
+ *  @param m_dev   A pointer to m_dev structure
+ *  @return        N/A
+ */
+void
+bt_interrupt(struct m_dev *m_dev)
+{
+	bt_private *priv = (bt_private *)m_dev->driver_data;
+	ENTER();
+	if (!priv || !priv->adapter) {
+		LEAVE();
+		return;
+	}
+	PRINTM(INTR, "*\n");
+	priv->adapter->ps_state = PS_AWAKE;
+	if (priv->adapter->hs_state == HS_ACTIVATED) {
+		PRINTM(CMD, "BT: %s: HS DEACTIVATED in ISR!\n", m_dev->name);
+		priv->adapter->hs_state = HS_DEACTIVATED;
+	}
+	priv->adapter->WakeupTries = 0;
+	priv->adapter->IntCounter++;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	LEAVE();
+}
+
+/**
+ * @brief  Dynamic release of bt private
+ *
+ * @param kobj          A pointer to kobject structure
+ *
+ * @return                N/A
+ */
+static void
+bt_private_dynamic_release(struct kobject *kobj)
+{
+	bt_private *priv = container_of(kobj, bt_private, kobj);
+	ENTER();
+	PRINTM(INFO, "free bt priv\n");
+	kfree(priv);
+	LEAVE();
+}
+
+static struct kobj_type ktype_bt_private_dynamic = {
+	.release = bt_private_dynamic_release,
+};
+
+/**
+ * @brief  Allocation of bt private
+ *
+ * @param           	N/A
+ *
+ * @return              bt_private
+ */
+static bt_private *
+bt_alloc_priv(void)
+{
+	bt_private *priv;
+	ENTER();
+	priv = kzalloc(sizeof(bt_private), GFP_KERNEL);
+	if (priv) {
+		kobject_init(&priv->kobj, &ktype_bt_private_dynamic);
+		PRINTM(INFO, "alloc bt priv\n");
+	}
+	LEAVE();
+	return priv;
+}
+
+/**
+ * @brief  Get bt private structure
+ *
+ * @param priv          A pointer to bt_private structure
+ *
+ * @return              kobject structure
+ */
+struct kobject *
+bt_priv_get(bt_private *priv)
+{
+	PRINTM(INFO, "bt priv get object");
+	return kobject_get(&priv->kobj);
+}
+
+/**
+ * @brief  Get bt private structure
+ *
+ * @param priv          A pointer to bt_private structure
+ *
+ * @return              N/A
+ */
+void
+bt_priv_put(bt_private *priv)
+{
+	PRINTM(INFO, "bt priv put object");
+	kobject_put(&priv->kobj);
+}
+
+/**
+ *  @brief This function send init commands to firmware
+ *
+ *  @param priv   A pointer to bt_private structure
+ *  @return       BT_STATUS_SUCESS/BT_STATUS_FAILURE
+ */
+int
+bt_init_cmd(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+
+	ret = bt_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);
+	if (ret < 0) {
+		PRINTM(FATAL, "Module cfg command send failed!\n");
+		goto done;
+	}
+	if (btindrst != -1) {
+		ret = bt_set_independent_reset(priv);
+		if (ret < 0) {
+			PRINTM(FATAL, "Independent reset failed!\n");
+			goto done;
+		}
+	}
+	if (btpmic) {
+		if (BT_STATUS_SUCCESS != bt_pmic_configure(priv)) {
+			PRINTM(FATAL, "BT: PMIC Configure failed \n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	ret = bt_set_ble_deepsleep(priv, deep_sleep ? TRUE : FALSE);
+	if (ret < 0) {
+		PRINTM(FATAL, "%s BLE deepsleep failed!\n",
+		       deep_sleep ? "Enable" : "Disable");
+		goto done;
+	}
+	if (psmode) {
+		priv->bt_dev.psmode = TRUE;
+		priv->bt_dev.idle_timeout = DEFAULT_IDLE_TIME;
+		ret = bt_enable_ps(priv);
+		if (ret < 0) {
+			PRINTM(FATAL, "Enable PS mode failed!\n");
+			goto done;
+		}
+	}
+#if defined(SDIO_SUSPEND_RESUME)
+	priv->bt_dev.gpio_gap = DEF_GPIO_GAP;
+	ret = bt_send_hscfg_cmd(priv);
+	if (ret < 0) {
+		PRINTM(FATAL, "Send HSCFG failed!\n");
+		goto done;
+	}
+#endif
+	priv->bt_dev.sdio_pull_cfg = 0xffffffff;
+	priv->bt_dev.sdio_pull_ctrl = 0;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+#include <linux/delay.h>
+
+void create_mbtex_dep(void)
+{
+	PRINTM(FATAL, "Module bt8xx will load before moal!\n");
+	msleep(500);
+}
+EXPORT_SYMBOL(create_mbtex_dep);
+
+/**
+ *  @brief This function reinit firmware after redownload firmware
+ *
+ *  @param priv   A pointer to bt_private structure
+ *  @return       BT_STATUS_SUCESS/BT_STATUS_FAILURE
+ */
+int
+bt_reinit_fw(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	priv->adapter->tx_lock = FALSE;
+	priv->adapter->ps_state = PS_AWAKE;
+	priv->adapter->suspend_fail = FALSE;
+	priv->adapter->is_suspended = FALSE;
+	priv->adapter->hs_skip = 0;
+	priv->adapter->num_cmd_timeout = 0;
+
+	ret = bt_init_cmd(priv);
+	if (ret < 0) {
+		PRINTM(FATAL, "BT init command failed!\n");
+		goto done;
+	}
+	/* block all the packet from bluez */
+	if (init_cfg || cal_cfg || bt_mac || cal_cfg_ext)
+		priv->adapter->tx_lock = TRUE;
+
+	if (init_cfg) {
+		if (BT_STATUS_SUCCESS != bt_init_config(priv, init_cfg)) {
+			PRINTM(FATAL,
+			       "BT: Set user init data and param failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (cal_cfg) {
+		if (BT_STATUS_SUCCESS != bt_cal_config(priv, cal_cfg, bt_mac)) {
+			PRINTM(FATAL, "BT: Set cal data failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+
+	if (bt_mac) {
+		PRINTM(INFO,
+		       "Set BT mac_addr from insmod parametre bt_mac = %s\n",
+		       bt_mac);
+		if (BT_STATUS_SUCCESS != bt_init_mac_address(priv, bt_mac)) {
+			PRINTM(FATAL,
+			       "BT: Fail to set mac address from insmod parametre\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+
+	if (cal_cfg_ext) {
+		if (BT_STATUS_SUCCESS != bt_cal_config_ext(priv, cal_cfg_ext)) {
+			PRINTM(FATAL, "BT: Set cal ext data failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (init_cfg || cal_cfg || bt_mac || cal_cfg_ext) {
+		priv->adapter->tx_lock = FALSE;
+		bt_restore_tx_queue(priv);
+	}
+
+	if (init_cmds) {
+		if (BT_STATUS_SUCCESS != bt_init_cmds(priv, init_cmds)) {
+			PRINTM(FATAL, "BT: Set user init commands failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	bt_get_fw_version(priv);
+	snprintf((char *)priv->adapter->drv_ver, MAX_VER_STR_LEN,
+		 mbt_driver_version, fw_version);
+done:
+	return ret;
+}
+
+/**
+ *  @brief Module configuration and register device
+ *
+ *  @param priv      A Pointer to bt_private structure
+ *  @return      BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_register_conf_dpc(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct hci_dev *hdev = NULL;
+	unsigned char dev_type = 0;
+
+	ENTER();
+
+	priv->bt_dev.tx_dnld_rdy = TRUE;
+	if (priv->fw_reload) {
+		bt_reinit_fw(priv);
+		LEAVE();
+		return ret;
+	}
+
+	if (drv_mode & DRV_MODE_BT) {
+		hdev = hci_alloc_dev();
+		if (!hdev) {
+			PRINTM(FATAL, "Can not allocate HCI device\n");
+			ret = -ENOMEM;
+			goto err_kmalloc;
+		}
+		hdev->open = bt_open;
+		hdev->close = bt_close;
+		hdev->flush = bt_flush;
+		hdev->send = bt_send_frame;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+		hdev->destruct = bt_destruct;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+		hdev->ioctl = bt_ioctl;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		hci_set_drvdata(hdev, priv);
+#else
+		hdev->driver_data = priv;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
+		hdev->owner = THIS_MODULE;
+#endif
+		init_m_dev(&(priv->bt_dev.m_dev[BT_SEQ]));
+		priv->bt_dev.m_dev[BT_SEQ].dev_type = BT_TYPE;
+		priv->bt_dev.m_dev[BT_SEQ].spec_type = BLUEZ_SPEC;
+		priv->bt_dev.m_dev[BT_SEQ].dev_pointer = (void *)hdev;
+		priv->bt_dev.m_dev[BT_SEQ].driver_data = priv;
+	}
+
+	dev_type = HCI_SDIO;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+	if (hdev)
+		hdev->bus = dev_type;
+#else
+	if (hdev)
+		hdev->type = dev_type;
+#endif /* >= 2.6.34 */
+
+	ret = bt_init_cmd(priv);
+	if (ret < 0) {
+		PRINTM(FATAL, "BT init command failed!\n");
+		goto done;
+	}
+
+	/** Process device tree init parameters before register hci device.
+	 *  Since uplayer device has not yet registered, no need to block tx queue.
+	 * */
+	if (init_cfg) {
+		if (BT_STATUS_SUCCESS != bt_init_config(priv, init_cfg)) {
+			PRINTM(FATAL,
+			       "BT: Set user init data and param failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (cal_cfg) {
+		if (BT_STATUS_SUCCESS != bt_cal_config(priv, cal_cfg, bt_mac)) {
+			PRINTM(FATAL, "BT: Set cal data failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	} else if (bt_mac) {
+		PRINTM(INFO,
+		       "Set BT mac_addr from insmod parametre bt_mac = %s\n",
+		       bt_mac);
+		if (BT_STATUS_SUCCESS != bt_init_mac_address(priv, bt_mac)) {
+			PRINTM(FATAL,
+			       "BT: Fail to set mac address from insmod parametre\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (cal_cfg_ext) {
+		if (BT_STATUS_SUCCESS != bt_cal_config_ext(priv, cal_cfg_ext)) {
+			PRINTM(FATAL, "BT: Set cal ext data failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	if (init_cmds) {
+		if (BT_STATUS_SUCCESS != bt_init_cmds(priv, init_cmds)) {
+			PRINTM(FATAL, "BT: Set user init commands failed\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	}
+
+	/* Get FW version */
+	bt_get_fw_version(priv);
+	snprintf((char *)priv->adapter->drv_ver, MAX_VER_STR_LEN,
+		 mbt_driver_version, fw_version);
+
+	if (hdev) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+		hdev->dev_type = priv->bt_dev.devType;
+#endif
+		ret = hci_register_dev(hdev);
+		if (ret < 0) {
+			PRINTM(FATAL, "Can not register HCI device\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		snprintf((char *)priv->bt_dev.m_dev[BT_SEQ].name,
+			 sizeof(priv->bt_dev.m_dev[BT_SEQ].name), hdev->name);
+		bt_proc_init(priv, &(priv->bt_dev.m_dev[BT_SEQ]), BT_SEQ);
+	}
+
+done:
+	LEAVE();
+	return ret;
+err_kmalloc:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function adds the card. it will probe the
+ *  card, allocate the bt_priv and initialize the device.
+ *
+ *  @param card    A pointer to card
+ *  @return        A pointer to bt_private structure
+ */
+
+bt_private *
+bt_add_card(void *card)
+{
+	bt_private *priv = NULL;
+	int index = 0;
+
+	ENTER();
+
+	priv = bt_alloc_priv();
+	if (!priv) {
+		PRINTM(FATAL, "Can not allocate priv\n");
+		LEAVE();
+		return NULL;
+	}
+	/* Save the handle */
+	for (index = 0; index < MAX_BT_ADAPTER; index++) {
+		if (m_priv[index] == NULL)
+			break;
+	}
+	if (index < MAX_BT_ADAPTER) {
+		m_priv[index] = priv;
+	} else {
+		PRINTM(ERROR, "Exceeded maximum cards supported!\n");
+		goto err_kmalloc;
+	}
+	/* allocate buffer for bt_adapter */
+	priv->adapter = kzalloc(sizeof(bt_adapter), GFP_KERNEL);
+	if (!priv->adapter) {
+		PRINTM(FATAL, "Allocate buffer for bt_adapter failed!\n");
+		goto err_kmalloc;
+	}
+	priv->adapter->tx_buffer =
+		kzalloc(MAX_TX_BUF_SIZE + DMA_ALIGNMENT, GFP_KERNEL);
+	if (!priv->adapter->tx_buffer) {
+		PRINTM(FATAL, "Allocate buffer for transmit\n");
+		goto err_kmalloc;
+	}
+	priv->adapter->tx_buf =
+		(u8 *)ALIGN_ADDR(priv->adapter->tx_buffer, DMA_ALIGNMENT);
+	priv->adapter->hw_regs_buf =
+		kzalloc(SD_BLOCK_SIZE + DMA_ALIGNMENT, GFP_KERNEL);
+	if (!priv->adapter->hw_regs_buf) {
+		PRINTM(FATAL, "Allocate buffer for INT read buf failed!\n");
+		goto err_kmalloc;
+	}
+	priv->adapter->hw_regs =
+		(u8 *)ALIGN_ADDR(priv->adapter->hw_regs_buf, DMA_ALIGNMENT);
+	bt_init_adapter(priv);
+
+	PRINTM(INFO, "Starting kthread...\n");
+	priv->MainThread.priv = priv;
+	spin_lock_init(&priv->driver_lock);
+
+	bt_create_thread(bt_service_main_thread, &priv->MainThread,
+			 "bt_main_service");
+
+	/* wait for mainthread to up */
+	while (!priv->MainThread.pid)
+		os_sched_timeout(1);
+
+	/** user config file */
+	init_waitqueue_head(&priv->init_user_conf_wait_q);
+
+	priv->bt_dev.card = card;
+
+	((struct sdio_mmc_card *)card)->priv = priv;
+	priv->adapter->sd_ireg = 0;
+	/*
+	 * Register the device. Fillup the private data structure with
+	 * relevant information from the card and request for the required
+	 * IRQ.
+	 */
+	if (sbi_register_dev(priv) < 0) {
+		PRINTM(FATAL, "Failed to register bt device!\n");
+		goto err_registerdev;
+	}
+	if (bt_init_fw(priv)) {
+		PRINTM(FATAL, "BT Firmware Init Failed\n");
+		goto err_init_fw;
+	}
+	LEAVE();
+	return priv;
+
+err_init_fw:
+	clean_up_m_devs(priv);
+	bt_proc_remove(priv);
+	PRINTM(INFO, "Unregister device\n");
+	sbi_unregister_dev(priv);
+err_registerdev:
+	((struct sdio_mmc_card *)card)->priv = NULL;
+	/* Stop the thread servicing the interrupts */
+	priv->adapter->SurpriseRemoved = TRUE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	while (priv->MainThread.pid)
+		os_sched_timeout(1);
+err_kmalloc:
+	if (priv->adapter)
+		bt_free_adapter(priv);
+	for (index = 0; index < MAX_BT_ADAPTER; index++) {
+		if (m_priv[index] == priv) {
+			m_priv[index] = NULL;
+			break;
+		}
+	}
+	bt_priv_put(priv);
+	LEAVE();
+	return NULL;
+}
+
+/**
+ *  @brief This function send hardware remove event
+ *
+ *  @param priv    A pointer to bt_private
+ *  @return        N/A
+ */
+void
+bt_send_hw_remove_event(bt_private *priv)
+{
+	struct sk_buff *skb = NULL;
+	struct hci_dev *hdev = NULL;
+	ENTER();
+	if (!priv->bt_dev.m_dev[BT_SEQ].dev_pointer) {
+		LEAVE();
+		return;
+	}
+	if (priv->bt_dev.m_dev[BT_SEQ].spec_type == BLUEZ_SPEC)
+		hdev = (struct hci_dev *)priv->bt_dev.m_dev[BT_SEQ].dev_pointer;
+#define HCI_HARDWARE_ERROR_EVT  0x10
+#define HCI_HARDWARE_REMOVE     0x24
+	skb = bt_skb_alloc(3, GFP_ATOMIC);
+	skb->data[0] = HCI_HARDWARE_ERROR_EVT;
+	skb->data[1] = 1;
+	skb->data[2] = HCI_HARDWARE_REMOVE;
+	bt_cb(skb)->pkt_type = HCI_EVENT_PKT;
+	skb_put(skb, 3);
+	if (hdev) {
+		skb->dev = (void *)hdev;
+		PRINTM(MSG, "Send HW ERROR event\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+		hci_recv_frame(skb);
+#else
+		hci_recv_frame(hdev, skb);
+#endif
+		os_sched_timeout(5);
+		hdev->stat.byte_rx += 3;
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function removes the card.
+ *
+ *  @param card    A pointer to card
+ *  @return        BT_STATUS_SUCCESS
+ */
+int
+bt_remove_card(void *card)
+{
+	bt_private *priv = (bt_private *)card;
+	int index;
+	ENTER();
+	if (!priv) {
+		LEAVE();
+		return BT_STATUS_SUCCESS;
+	}
+
+	priv->adapter->SurpriseRemoved = TRUE;
+
+	bt_send_hw_remove_event(priv);
+	wake_up_interruptible(&priv->adapter->cmd_wait_q);
+	priv->adapter->SurpriseRemoved = TRUE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	while (priv->MainThread.pid) {
+		os_sched_timeout(1);
+		wake_up_interruptible(&priv->MainThread.waitQ);
+	}
+
+	bt_proc_remove(priv);
+	PRINTM(INFO, "Unregister device\n");
+	sbi_unregister_dev(priv);
+	clean_up_m_devs(priv);
+	PRINTM(INFO, "Free Adapter\n");
+	bt_free_adapter(priv);
+	for (index = 0; index < MAX_BT_ADAPTER; index++) {
+		if (m_priv[index] == priv) {
+			m_priv[index] = NULL;
+			break;
+		}
+	}
+	bt_priv_put(priv);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function initializes module.
+ *
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_module(void)
+{
+	int ret = BT_STATUS_SUCCESS;
+	int index;
+	ENTER();
+	PRINTM(MSG, "BT: Loading driver\n");
+	/* Init the bt_private pointer array first */
+	for (index = 0; index < MAX_BT_ADAPTER; index++)
+		m_priv[index] = NULL;
+	bt_root_proc_init();
+
+	/** create char device class */
+	chardev_class = class_create(THIS_MODULE, MODULE_NAME);
+	if (IS_ERR(chardev_class)) {
+		PRINTM(ERROR, "Unable to allocate class\n");
+		bt_root_proc_remove();
+		ret = PTR_ERR(chardev_class);
+		goto done;
+	}
+
+	if (sbi_register() == NULL) {
+		bt_root_proc_remove();
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+done:
+	if (ret)
+		PRINTM(MSG, "BT: Driver loading failed\n");
+	else
+		PRINTM(MSG, "BT: Driver loaded successfully\n");
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function cleans module
+ *
+ *  @return        N/A
+ */
+static void
+bt_exit_module(void)
+{
+	bt_private *priv;
+	int index;
+	ENTER();
+	PRINTM(MSG, "BT: Unloading driver\n");
+	for (index = 0; index < MAX_BT_ADAPTER; index++) {
+		priv = m_priv[index];
+		if (!priv)
+			continue;
+		if (priv && !priv->adapter->SurpriseRemoved) {
+			if (BT_STATUS_SUCCESS == bt_send_reset_command(priv))
+				bt_send_module_cfg_cmd(priv,
+						       MODULE_SHUTDOWN_REQ);
+		}
+		sbi_disable_host_int(priv);
+
+	}
+
+	sbi_unregister();
+
+	bt_root_proc_remove();
+	class_destroy(chardev_class);
+	PRINTM(MSG, "BT: Driver unloaded\n");
+	LEAVE();
+}
+
+module_init(bt_init_module);
+module_exit(bt_exit_module);
+
+MODULE_AUTHOR("NXP");
+MODULE_DESCRIPTION("NXP Bluetooth Driver Ver. " VERSION);
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
+module_param(fw, int, 0);
+MODULE_PARM_DESC(fw, "0: Skip firmware download; otherwise: Download firmware");
+module_param(psmode, int, 0);
+MODULE_PARM_DESC(psmode, "1: Enable powermode; 0: Disable powermode");
+module_param(deep_sleep, int, 0);
+MODULE_PARM_DESC(deep_sleep, "1: Enable deep sleep; 0: Disable deep sleep");
+#ifdef CONFIG_OF
+module_param(dts_enable, int, 0);
+MODULE_PARM_DESC(dts_enable, "0: Disable DTS; 1: Enable DTS");
+#endif
+#ifdef	DEBUG_LEVEL1
+module_param(mbt_drvdbg, uint, 0);
+MODULE_PARM_DESC(mbt_drvdbg, "BIT3:DBG_DATA BIT4:DBG_CMD 0xFF:DBG_ALL");
+#endif
+#ifdef SDIO_SUSPEND_RESUME
+module_param(mbt_pm_keep_power, int, 0);
+MODULE_PARM_DESC(mbt_pm_keep_power, "1: PM keep power; 0: PM no power");
+#endif
+module_param(init_cfg, charp, 0);
+MODULE_PARM_DESC(init_cfg, "BT init config file name");
+module_param(cal_cfg, charp, 0);
+MODULE_PARM_DESC(cal_cfg, "BT calibrate file name");
+module_param(cal_cfg_ext, charp, 0);
+MODULE_PARM_DESC(cal_cfg_ext, "BT calibrate ext file name");
+module_param(bt_mac, charp, 0660);
+MODULE_PARM_DESC(bt_mac, "BT init mac address");
+module_param(init_cmds, charp, 0);
+MODULE_PARM_DESC(init_cmds, "BT init commands file name");
+module_param(drv_mode, int, 0);
+MODULE_PARM_DESC(drv_mode, "Bit 0: BT/AMP/BLE;");
+module_param(bt_fw_reload, int, 0);
+MODULE_PARM_DESC(bt_fw_reload,
+		 "0: disable fw_reload; 1: enable fw reload feature");
+module_param(btindrst, int, 0);
+MODULE_PARM_DESC(btindrst,
+		 "Independent reset configuration; high byte:GPIO pin number;low byte:0x0:disable, 0x1:out-band reset, 0x2:in-band reset.");
+module_param(btpmic, int, 0);
+MODULE_PARM_DESC(btpmic,
+		 "1: Send pmic configure cmd to firmware; 0: No pmic configure cmd sent to firmware (default)");
+module_param(bt_fw_serial, int, 0);
+MODULE_PARM_DESC(bt_fw_serial,
+		 "0: Support parallel download FW; 1: Support serial download FW");
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_proc.c b/drivers/bluetooth/mbtex_8997/bt/bt_proc.c
new file mode 100755
index 000000000000..754bd0c4af5c
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_proc.c
@@ -0,0 +1,924 @@
+/** @file bt_proc.c
+ *
+ *  @brief This file handle the functions for proc files
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#include <linux/proc_fs.h>
+
+#include "bt_drv.h"
+#include "bt_sdio.h"
+
+/** proc diretory root */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+#define PROC_DIR NULL
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+#define PROC_DIR (&proc_root)
+#else
+#define PROC_DIR proc_net
+#endif
+
+/** Proc mbt directory entry */
+static struct proc_dir_entry *proc_mbt;
+
+#define     CMD52_STR_LEN   50
+static char cmd52_string[CMD52_STR_LEN];
+
+/** proc data structure */
+struct proc_data {
+	/** Read length */
+	int rdlen;
+	/** Read buffer */
+	char *rdbuf;
+	/** Write length */
+	int wrlen;
+	/** Maximum write length */
+	int maxwrlen;
+	/** Write buffer */
+	char *wrbuf;
+	/** Private structure */
+	struct _bt_private *pbt;
+	void (*on_close) (struct inode *, struct file *);
+};
+
+/** Default file permission */
+#define DEFAULT_FILE_PERM  0644
+
+/** Bluetooth device offset */
+#define OFFSET_BT_DEV		0x01
+/** Bluetooth adapter offset */
+#define OFFSET_BT_ADAPTER	0x02
+/** Show integer */
+#define SHOW_INT		0x10
+/** Show hex */
+#define SHOW_HEX		0x20
+/** Show string */
+#define SHOW_STRING		0x40
+
+/** Device size */
+#define item_dev_size(n) (sizeof((bt_dev_t *)0)->n)
+/** Device address */
+#define item_dev_addr(n) ((t_ptr) &((bt_dev_t *)0)->n)
+
+/** Adapter size */
+#define item_adapter_size(n) (sizeof((bt_adapter *)0)->n)
+/** Adapter address */
+#define item_adapter_addr(n) ((t_ptr) &((bt_adapter *)0)->n)
+
+static struct item_data config_items[] = {
+#ifdef	DEBUG_LEVEL1
+	{"drvdbg", sizeof(u32), (t_ptr)&mbt_drvdbg, 0, SHOW_HEX}
+	,
+#endif
+	{"idle_timeout", item_dev_size(idle_timeout), 0,
+	 item_dev_addr(idle_timeout), OFFSET_BT_DEV | SHOW_HEX}
+	,
+	{"psmode", item_dev_size(psmode), 0, item_dev_addr(psmode),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"pscmd", item_dev_size(pscmd), 0, item_dev_addr(pscmd),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"hsmode", item_dev_size(hsmode), 0, item_dev_addr(hsmode),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"hscmd", item_dev_size(hscmd), 0, item_dev_addr(hscmd),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"gpio_gap", item_dev_size(gpio_gap), 0, item_dev_addr(gpio_gap),
+	 OFFSET_BT_DEV | SHOW_HEX}
+	,
+	{"hscfgcmd", item_dev_size(hscfgcmd), 0, item_dev_addr(hscfgcmd),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"sdio_pull_cfg", item_dev_size(sdio_pull_cfg), 0,
+	 item_dev_addr(sdio_pull_cfg), OFFSET_BT_DEV | SHOW_HEX}
+	,
+	{"sdio_pull_ctrl", item_dev_size(sdio_pull_ctrl), 0,
+	 item_dev_addr(sdio_pull_ctrl), OFFSET_BT_DEV | SHOW_INT}
+	,
+	{"test_mode", item_dev_size(test_mode), 0, item_dev_addr(test_mode),
+	 OFFSET_BT_DEV | SHOW_INT}
+	,
+
+};
+
+static struct item_data status_items[] = {
+	{"version", item_adapter_size(drv_ver), 0, item_adapter_addr(drv_ver),
+	 OFFSET_BT_ADAPTER | SHOW_STRING},
+	{"tx_dnld_rdy", item_dev_size(tx_dnld_rdy), 0,
+	 item_dev_addr(tx_dnld_rdy),
+	 OFFSET_BT_DEV | SHOW_INT},
+	{"psmode", item_adapter_size(psmode), 0, item_adapter_addr(psmode),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"hs_state", item_adapter_size(hs_state), 0,
+	 item_adapter_addr(hs_state),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"hs_skip", item_adapter_size(hs_skip), 0, item_adapter_addr(hs_skip),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"ps_state", item_adapter_size(ps_state), 0,
+	 item_adapter_addr(ps_state),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"WakeupTries", item_adapter_size(WakeupTries), 0,
+	 item_adapter_addr(WakeupTries), OFFSET_BT_ADAPTER | SHOW_INT},
+	{"irq_recv", item_adapter_size(irq_recv), 0,
+	 item_adapter_addr(irq_recv),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"irq_done", item_adapter_size(irq_done), 0,
+	 item_adapter_addr(irq_done),
+	 OFFSET_BT_ADAPTER | SHOW_INT},
+	{"skb_pending", item_adapter_size(skb_pending), 0,
+	 item_adapter_addr(skb_pending), OFFSET_BT_ADAPTER | SHOW_INT},
+};
+
+static struct item_data debug_items[] = {
+	{"sdcmd52rw", 0, (t_ptr)cmd52_string, 0, SHOW_STRING},
+};
+
+/**
+ *  @brief convert string to number
+ *
+ *  @param s	pointer to numbered string
+ *  @return	converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+	int r = 0;
+	int base = 0;
+	int pn = 1;
+
+	if (strncmp(s, "-", 1) == 0) {
+		pn = -1;
+		s++;
+	}
+	if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0)) {
+		base = 16;
+		s += 2;
+	} else
+		base = 10;
+
+	for (s = s; *s != 0; s++) {
+		if ((*s >= '0') && (*s <= '9'))
+			r = (r * base) + (*s - '0');
+		else if ((*s >= 'A') && (*s <= 'F'))
+			r = (r * base) + (*s - 'A' + 10);
+		else if ((*s >= 'a') && (*s <= 'f'))
+			r = (r * base) + (*s - 'a' + 10);
+		else
+			break;
+	}
+
+	return r * pn;
+}
+
+/**
+ *  @brief Create cmd52 string
+ *
+ *  @param priv	A pointer to bt_private structure
+ *  @return	BT_STATUS_SUCCESS
+ */
+static int
+form_cmd52_string(bt_private *priv)
+{
+	ENTER();
+
+	memset(cmd52_string, 0, CMD52_STR_LEN);
+	snprintf(cmd52_string, CMD52_STR_LEN - 1, "BT: %d 0x%0x 0x%02X",
+		 priv->bt_dev.cmd52_func, priv->bt_dev.cmd52_reg,
+		 priv->bt_dev.cmd52_val);
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/*
+ *  @brief Parse cmd52 string
+ *
+ *  @param buffer  A pointer user buffer
+ *  @param len     Length of user buffer
+ *  @param func    Parsed func number
+ *  @param reg     Parsed reg value
+ *  @param val     Parsed value to set
+ *  @return	BT_STATUS_SUCCESS
+ */
+static int
+parse_cmd52_string(const char __user * buffer, size_t len,
+		   int *func, int *reg, int *val)
+{
+	int ret = BT_STATUS_SUCCESS;
+	char *string = NULL;
+	char *pos = NULL;
+
+	ENTER();
+
+	string = kzalloc(CMD52_STR_LEN, GFP_KERNEL);
+	if (!string) {
+		PRINTM(ERROR, "BT: Can not alloc mem for cmd52 string\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+	memcpy(string, buffer + strlen("sdcmd52rw="),
+	       len - strlen("sdcmd52rw="));
+	string = strstrip(string);
+
+	*func = -1;
+	*reg = -1;
+	*val = -1;
+
+	/* Get func */
+	pos = strsep(&string, " \t");
+	if (pos)
+		*func = string_to_number(pos);
+
+	/* Get reg */
+	pos = strsep(&string, " \t");
+	if (pos)
+		*reg = string_to_number(pos);
+
+	/* Get val (optional) */
+	pos = strsep(&string, " \t");
+	if (pos)
+		*val = string_to_number(pos);
+	kfree(string);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function handle generic proc file close
+ *
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return	BT_STATUS_SUCCESS
+ */
+static int
+proc_close(struct inode *inode, struct file *file)
+{
+	struct proc_data *pdata = file->private_data;
+	ENTER();
+	if (pdata) {
+		if (pdata->on_close != NULL)
+			pdata->on_close(inode, file);
+		kfree(pdata->rdbuf);
+		kfree(pdata->wrbuf);
+		kfree(pdata);
+	}
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handle generic proc file read
+ *
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to output buffer
+ *  @param len     number of byte to read
+ *  @param offset  A pointer to offset of file
+ *  @return		number of output data
+ */
+static ssize_t
+proc_read(struct file *file, char __user * buffer, size_t len, loff_t * offset)
+{
+	loff_t pos = *offset;
+	struct proc_data *pdata = (struct proc_data *)file->private_data;
+	if ((!pdata->rdbuf) || (pos < 0))
+		return -EINVAL;
+	if (pos >= pdata->rdlen)
+		return 0;
+	if (len > pdata->rdlen - pos)
+		len = pdata->rdlen - pos;
+	if (copy_to_user(buffer, pdata->rdbuf + pos, len))
+		return -EFAULT;
+	*offset = pos + len;
+	return len;
+}
+
+/**
+ *  @brief This function handle generic proc file write
+ *
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to input buffer
+ *  @param len     number of byte to write
+ *  @param offset  A pointer to offset of file
+ *  @return		number of input data
+ */
+static ssize_t
+proc_write(struct file *file,
+	   const char __user * buffer, size_t len, loff_t * offset)
+{
+	loff_t pos = *offset;
+	struct proc_data *pdata = (struct proc_data *)file->private_data;
+	int func = 0, reg = 0, val = 0;
+	int config_data = 0;
+	char *line = NULL;
+
+	if (!pdata->wrbuf || (pos < 0))
+		return -EINVAL;
+	if (pos >= pdata->maxwrlen)
+		return 0;
+	if (len > pdata->maxwrlen - pos)
+		len = pdata->maxwrlen - pos;
+	if (copy_from_user(pdata->wrbuf + pos, buffer, len))
+		return -EFAULT;
+	if (!strncmp(pdata->wrbuf + pos, "fw_reload", strlen("fw_reload"))) {
+		if (!strncmp
+		    (pdata->wrbuf + pos, "fw_reload=", strlen("fw_reload="))) {
+			line = pdata->wrbuf + pos;
+			line += strlen("fw_reload") + 1;
+			config_data = string_to_number(line);
+		} else
+			config_data = FW_RELOAD_SDIO_INBAND_RESET;
+		PRINTM(MSG, "Request fw_reload=%d\n", config_data);
+		bt_request_fw_reload(pdata->pbt, config_data);
+	}
+	if (!strncmp(pdata->wrbuf + pos, "sdcmd52rw=", strlen("sdcmd52rw="))) {
+		parse_cmd52_string(pdata->wrbuf + pos, len, &func, &reg, &val);
+		sd_write_cmd52_val(pdata->pbt, func, reg, val);
+	}
+	if (!strncmp(pdata->wrbuf + pos, "debug_dump", strlen("debug_dump"))) {
+		bt_dump_sdio_regs(pdata->pbt);
+		bt_dump_firmware_info_v2(pdata->pbt);
+	}
+
+	if (pos + len > pdata->wrlen)
+		pdata->wrlen = len + file->f_pos;
+	*offset = pos + len;
+	return len;
+}
+
+/**
+ *  @brief This function handle the generic file close
+ *
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return		N/A
+ */
+static void
+proc_on_close(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct proc_private_data *priv = PDE_DATA(inode);
+#else
+	struct proc_private_data *priv = PDE(inode)->data;
+#endif
+	struct proc_data *pdata = file->private_data;
+	char *line;
+	int i;
+	ENTER();
+	if (!pdata->wrlen)
+		return;
+	line = pdata->wrbuf;
+	while (line[0]) {
+		for (i = 0; i < priv->num_items; i++) {
+			if (!strncmp
+			    (line, priv->pdata[i].name,
+			     strlen(priv->pdata[i].name))) {
+				line += strlen(priv->pdata[i].name) + 1;
+				if (priv->pdata[i].size == 1)
+					*((u8 *)priv->pdata[i].addr) =
+						(u8)string_to_number(line);
+				else if (priv->pdata[i].size == 2)
+					*((u16 *) priv->pdata[i].addr) =
+						(u16) string_to_number(line);
+				else if (priv->pdata[i].size == 4)
+					*((u32 *)priv->pdata[i].addr) =
+						(u32)string_to_number(line);
+			}
+		}
+		while (line[0] && line[0] != '\n')
+			line++;
+		if (line[0])
+			line++;
+	}
+	if (priv->pbt->bt_dev.hscmd || priv->pbt->bt_dev.pscmd
+	    || priv->pbt->bt_dev.sdio_pull_ctrl
+	    || priv->pbt->bt_dev.test_mode || priv->pbt->bt_dev.hscfgcmd) {
+		bt_prepare_command(priv->pbt);
+		wake_up_interruptible(&priv->pbt->MainThread.waitQ);
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function handle the generic file open
+ *
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return	BT_STATUS_SUCCESS or other error no.
+ */
+static int
+proc_open(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	struct proc_private_data *priv = PDE_DATA(inode);
+#else
+	struct proc_private_data *priv = PDE(inode)->data;
+#endif
+	struct proc_data *pdata;
+	int i;
+	char *p;
+	u32 val = 0;
+	ENTER();
+	priv->pbt->adapter->skb_pending =
+		skb_queue_len(&priv->pbt->adapter->tx_queue);
+	file->private_data = kzalloc(sizeof(struct proc_data), GFP_KERNEL);
+	if (file->private_data == NULL) {
+		PRINTM(ERROR, "BT: Can not alloc mem for proc_data\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+	pdata = (struct proc_data *)file->private_data;
+	pdata->pbt = priv->pbt;
+	pdata->rdbuf = kmalloc(priv->bufsize, GFP_KERNEL);
+	if (pdata->rdbuf == NULL) {
+		PRINTM(ERROR, "BT: Can not alloc mem for rdbuf\n");
+		kfree(file->private_data);
+		LEAVE();
+		return -ENOMEM;
+	}
+	if (priv->fileflag == DEFAULT_FILE_PERM) {
+		pdata->wrbuf = kzalloc(priv->bufsize, GFP_KERNEL);
+		if (pdata->wrbuf == NULL) {
+			PRINTM(ERROR, "BT: Can not alloc mem for wrbuf\n");
+			kfree(pdata->rdbuf);
+			kfree(file->private_data);
+			return -ENOMEM;
+		}
+		pdata->maxwrlen = priv->bufsize;
+		pdata->on_close = proc_on_close;
+	}
+	p = pdata->rdbuf;
+	for (i = 0; i < priv->num_items; i++) {
+		if (priv->pdata[i].size == 1)
+			val = *((u8 *)priv->pdata[i].addr);
+		else if (priv->pdata[i].size == 2)
+			val = *((u16 *) priv->pdata[i].addr);
+		else if (priv->pdata[i].size == 4)
+			val = *((u32 *)priv->pdata[i].addr);
+		if (priv->pdata[i].flag & SHOW_INT)
+			p += sprintf(p, "%s=%d\n", priv->pdata[i].name, val);
+		else if (priv->pdata[i].flag & SHOW_HEX)
+			p += sprintf(p, "%s=0x%x\n", priv->pdata[i].name, val);
+		else if (priv->pdata[i].flag & SHOW_STRING) {
+			if (!strncmp
+			    (priv->pdata[i].name, "sdcmd52rw",
+			     strlen("sdcmd52rw"))) {
+				sd_read_cmd52_val(priv->pbt);
+				form_cmd52_string(priv->pbt);
+			}
+			p += sprintf(p, "%s=%s\n", priv->pdata[i].name,
+				     (char *)priv->pdata[i].addr);
+		}
+	}
+	pdata->rdlen = strlen(pdata->rdbuf);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/** Proc read ops */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static const struct proc_ops proc_read_ops = {
+	.proc_read = proc_read,
+	.proc_open = proc_open,
+	.proc_release = proc_close
+};
+
+/** Proc Read-Write ops */
+static const struct proc_ops proc_rw_ops = {
+	.proc_read = proc_read,
+	.proc_write = proc_write,
+	.proc_open = proc_open,
+	.proc_release = proc_close
+};
+#else
+static const struct file_operations proc_read_ops = {
+	.read = proc_read,
+	.open = proc_open,
+	.release = proc_close
+};
+
+/** Proc Read-Write ops */
+static const struct file_operations proc_rw_ops = {
+	.read = proc_read,
+	.write = proc_write,
+	.open = proc_open,
+	.release = proc_close
+};
+#endif
+
+static struct proc_private_data proc_files[] = {
+	{"status", S_IRUGO, 1024,
+	 sizeof(status_items) / sizeof(status_items[0]),
+	 &status_items[0], NULL, &proc_read_ops}
+	,
+	{"config", DEFAULT_FILE_PERM, 512,
+	 sizeof(config_items) / sizeof(config_items[0]), &config_items[0], NULL,
+	 &proc_rw_ops}
+	,
+	{"debug", DEFAULT_FILE_PERM, 512,
+	 sizeof(debug_items) / sizeof(debug_items[0]), &debug_items[0], NULL,
+	 &proc_rw_ops}
+	,
+};
+
+/**
+ *  @brief Proc read function for histogram
+ *
+ *  @param sfp     pointer to seq_file structure
+ *  @param data
+ *
+ *  @return        Number of output data or MLAN_STATUS_FAILURE
+ */
+static int
+bt_histogram_read(struct seq_file *sfp, void *data)
+{
+	bt_hist_proc_data *pdata = (bt_hist_proc_data *) sfp->private;
+	bt_private *priv = (bt_private *)pdata->pbt;
+	u8 ant_num;
+	int i, j;
+
+	ENTER();
+	if (!priv) {
+		LEAVE();
+		return -EFAULT;
+	}
+	bt_get_histogram(priv);
+	ant_num = priv->hist_data_len / sizeof(bt_histogram_data);
+	seq_printf(sfp, "BT histogram:\n");
+	seq_printf(sfp, "antenna: 0=2.4G antenna a,  1=2.4G antenna b\n\n");
+	if (ant_num < 1) {
+		seq_printf(sfp, "no histogram data from FW\n");
+		LEAVE();
+		return 0;
+	}
+	for (i = 0; i < ant_num; i++) {
+		if (pdata->antenna != priv->hist_data[i].antenna)
+			continue;
+		seq_printf(sfp, "antenna %d\n", priv->hist_data[i].antenna);
+		switch (priv->hist_data[i].powerclass) {
+		case 2:
+			seq_printf(sfp, "Power class=1.5\n");
+			break;
+		case 5:
+			seq_printf(sfp, "Power class=2\n");
+			break;
+		case 6:
+			seq_printf(sfp, "Power class=1\n");
+			break;
+		default:
+			seq_printf(sfp, "Power class=%d\n",
+				   priv->hist_data[i].powerclass);
+			break;
+		}
+		for (j = 0; j < (MAX_BT_LINK + MAX_BLE_LINK); j++) {
+			switch (priv->hist_data[i].link[j].txrxrate) {
+			case BDR_RATE_1M:
+				seq_printf(sfp,
+					   "BT link[%d]: TxPower=%d dBm, TxRx Rate=BDR(1 mbps), RSSI=%d dBm\n",
+					   j + 1,
+					   priv->hist_data[i].link[j].txpower,
+					   priv->hist_data[i].link[j].rssi);
+				break;
+			case EDR_RATE_2_3M:
+				seq_printf(sfp,
+					   "BT link[%d]: TxPower=%d dBm, TxRx Rate=EDR(2/3 mbps), RSSI=%d dBm\n",
+					   j + 1,
+					   priv->hist_data[i].link[j].txpower,
+					   priv->hist_data[i].link[j].rssi);
+				break;
+			case BLE_RATE_1M:
+				seq_printf(sfp,
+					   "BLE link[%d]: TxPower=%d dBm, TxRx Rate=BLE(1 mbps), RSSI=%d dBm\n",
+					   j - MAX_BT_LINK + 0x80,
+					   priv->hist_data[i].link[j].txpower,
+					   priv->hist_data[i].link[j].rssi);
+				break;
+			default:
+				if (j < MAX_BT_LINK)
+					seq_printf(sfp,
+						   "BT link[%d]: TxPower=%d dBm, TxRx Rate=(%d), RSSI=%d dBm\n",
+						   j + 1,
+						   priv->hist_data[i].link[j].
+						   txpower,
+						   priv->hist_data[i].link[j].
+						   txrxrate,
+						   priv->hist_data[i].link[j].
+						   rssi);
+				else
+					seq_printf(sfp,
+						   "BLE link[%d]: TxPower=%d dBm, TxRx Rate=(%d), RSSI=%d dBm\n",
+						   j - MAX_BT_LINK + 0x80,
+						   priv->hist_data[i].link[j].
+						   txpower,
+						   priv->hist_data[i].link[j].
+						   txrxrate,
+						   priv->hist_data[i].link[j].
+						   rssi);
+				break;
+			}
+		}
+		seq_printf(sfp, "\n");
+	}
+	LEAVE();
+	return 0;
+}
+
+/**
+ *  @brief Proc open function for histogram
+ *
+ *  @param inode     A pointer to inode structure
+ *  @param file		 A pointer to file structure
+ *
+ *  @return        Number of output data or MLAN_STATUS_FAILURE
+ */
+static int
+bt_histogram_proc_open(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	return single_open(file, bt_histogram_read, PDE_DATA(inode));
+#else
+	return single_open(file, bt_histogram_read, PDE(inode)->data);
+#endif
+}
+
+/** Histogram proc fops */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+
+static const struct proc_ops histogram_proc_fops = {
+	.proc_open = bt_histogram_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+#else
+
+static const struct file_operations histogram_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = bt_histogram_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
+/**
+ *  @brief This function initializes proc entry
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param m_dev    A pointer to struct m_dev
+ *  @param seq      Sequence number
+ *
+ *  @return	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_proc_init(bt_private *priv, struct m_dev *m_dev, int seq)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct proc_dir_entry *entry;
+	int i, j;
+	char hist_entry[50];
+
+	ENTER();
+
+	memset(cmd52_string, 0, CMD52_STR_LEN);
+	if (proc_mbt) {
+		priv->dev_proc[seq].proc_entry =
+			proc_mkdir(m_dev->name, proc_mbt);
+		if (!priv->dev_proc[seq].proc_entry) {
+			PRINTM(ERROR, "BT: Could not mkdir %s!\n", m_dev->name);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		priv->dev_proc[seq].hist_entry =
+			proc_mkdir("histogram", priv->dev_proc[seq].proc_entry);
+		if (!priv->dev_proc[seq].hist_entry) {
+			PRINTM(ERROR, "BT: Could not mkdir histogram!\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		for (i = 0; i < MAX_ANTENNA_NUM; i++) {
+			priv->hist_proc[i].antenna = i;
+			priv->hist_proc[i].pbt = priv;
+			snprintf(hist_entry, sizeof(hist_entry), "bt-ant%d", i);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+			entry = proc_create_data(hist_entry, 0644,
+						 priv->dev_proc[seq].hist_entry,
+						 &histogram_proc_fops,
+						 &priv->hist_proc[i]);
+			if (entry == NULL)
+#else
+			entry = create_proc_entry(hist_entry, 0644,
+						  priv->dev_proc[seq].
+						  hist_entry);
+			if (entry) {
+				entry->data = &priv->hist_proc[i];
+				entry->proc_fops = &histogram_proc_fops;
+			} else
+#endif
+			{
+				PRINTM(MSG,
+				       "Fail to create histogram proc %s\n",
+				       hist_entry);
+				ret = BT_STATUS_FAILURE;
+				goto done;
+			}
+		}
+
+		priv->dev_proc[seq].pfiles =
+			kmalloc(sizeof(proc_files), GFP_ATOMIC);
+		if (!priv->dev_proc[seq].pfiles) {
+			PRINTM(ERROR,
+			       "BT: Could not alloc memory for pfile!\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		memcpy((u8 *)priv->dev_proc[seq].pfiles, (u8 *)proc_files,
+		       sizeof(proc_files));
+		priv->dev_proc[seq].num_proc_files = ARRAY_SIZE(proc_files);
+		for (j = 0; j < priv->dev_proc[seq].num_proc_files; j++)
+			priv->dev_proc[seq].pfiles[j].pdata = NULL;
+		for (j = 0; j < priv->dev_proc[seq].num_proc_files; j++) {
+			priv->dev_proc[seq].pfiles[j].pdata =
+				kmalloc(priv->dev_proc[seq].pfiles[j].
+					num_items * sizeof(struct item_data),
+					GFP_ATOMIC);
+			if (!priv->dev_proc[seq].pfiles[j].pdata) {
+				PRINTM(ERROR,
+				       "BT: Could not alloc memory for pdata!\n");
+				ret = BT_STATUS_FAILURE;
+				goto done;
+			}
+			memcpy((u8 *)priv->dev_proc[seq].pfiles[j].pdata,
+			       (u8 *)proc_files[j].pdata,
+			       priv->dev_proc[seq].pfiles[j].num_items *
+			       sizeof(struct item_data));
+			for (i = 0; i < priv->dev_proc[seq].pfiles[j].num_items;
+			     i++) {
+				if (priv->dev_proc[seq].pfiles[j].
+				    pdata[i].flag & OFFSET_BT_DEV)
+					priv->dev_proc[seq].pfiles[j].pdata[i].
+						addr =
+						priv->dev_proc[seq].pfiles[j].
+						pdata[i].offset +
+						(t_ptr)&priv->bt_dev;
+				if (priv->dev_proc[seq].pfiles[j].
+				    pdata[i].flag & OFFSET_BT_ADAPTER)
+					priv->dev_proc[seq].pfiles[j].pdata[i].
+						addr =
+						priv->dev_proc[seq].pfiles[j].
+						pdata[i].offset +
+						(t_ptr)priv->adapter;
+			}
+			priv->dev_proc[seq].pfiles[j].pbt = priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+			entry = proc_create_data(proc_files[j].name,
+						 S_IFREG | proc_files[j].
+						 fileflag,
+						 priv->dev_proc[seq].proc_entry,
+						 proc_files[j].fops,
+						 &priv->dev_proc[seq].
+						 pfiles[j]);
+			if (entry == NULL)
+#else
+			entry = create_proc_entry(proc_files[j].name,
+						  S_IFREG | proc_files[j].
+						  fileflag,
+						  priv->dev_proc[seq].
+						  proc_entry);
+			if (entry) {
+				entry->data = &priv->dev_proc[seq].pfiles[j];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+				entry->owner = THIS_MODULE;
+#endif
+				entry->proc_fops = proc_files[j].fops;
+			} else
+#endif
+				PRINTM(MSG, "BT: Fail to create proc %s\n",
+				       proc_files[j].name);
+		}
+	}
+done:
+	if (ret == BT_STATUS_FAILURE) {
+		if (priv->dev_proc[seq].proc_entry) {
+			remove_proc_entry(m_dev->name, proc_mbt);
+			priv->dev_proc[seq].proc_entry = NULL;
+		}
+		if (priv->dev_proc[seq].pfiles) {
+			for (j = 0; j < priv->dev_proc[seq].num_proc_files; j++) {
+				if (priv->dev_proc[seq].pfiles[j].pdata) {
+					kfree(priv->dev_proc[seq].pfiles[j].
+					      pdata);
+					priv->dev_proc[seq].pfiles[j].pdata =
+						NULL;
+				}
+			}
+			kfree(priv->dev_proc[seq].pfiles);
+			priv->dev_proc[seq].pfiles = NULL;
+		}
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function removes proc interface
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return	N/A
+ */
+void
+bt_proc_remove(bt_private *priv)
+{
+	int j, i;
+	char hist_entry[50];
+
+	ENTER();
+	PRINTM(INFO, "BT: Remove Proc Interface\n");
+	if (proc_mbt) {
+		for (i = 0; i < MAX_RADIO_FUNC; i++) {
+			if (!priv->dev_proc[i].proc_entry)
+				continue;
+			for (j = 0; j < ARRAY_SIZE(proc_files); j++) {
+				remove_proc_entry(proc_files[j].name,
+						  priv->dev_proc[i].proc_entry);
+			}
+			for (j = 0; j < MAX_ANTENNA_NUM; j++) {
+				snprintf(hist_entry, sizeof(hist_entry),
+					 "bt-ant%d", j);
+				remove_proc_entry(hist_entry,
+						  priv->dev_proc[i].hist_entry);
+			}
+			remove_proc_entry("histogram",
+					  priv->dev_proc[i].proc_entry);
+			remove_proc_entry(priv->bt_dev.m_dev[i].name, proc_mbt);
+			priv->dev_proc[i].proc_entry = NULL;
+
+			if (priv->dev_proc[i].pfiles) {
+				for (j = 0;
+				     j < priv->dev_proc[i].num_proc_files;
+				     j++) {
+					if (priv->dev_proc[i].pfiles[j].pdata) {
+						kfree(priv->dev_proc[i].
+						      pfiles[j].pdata);
+						priv->dev_proc[i].pfiles[j].
+							pdata = NULL;
+					}
+				}
+				kfree(priv->dev_proc[i].pfiles);
+				priv->dev_proc[i].pfiles = NULL;
+			}
+		}
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function creates proc interface
+ *  directory structure
+ *
+ *  @return		BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_root_proc_init(void)
+{
+	PRINTM(INFO, "BT: Create Proc Interface\n");
+	proc_mbt = proc_mkdir("mbt", PROC_DIR);
+	if (!proc_mbt) {
+		PRINTM(ERROR, "BT: Cannot create proc interface\n");
+		return BT_STATUS_FAILURE;
+	}
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function removes proc interface
+ *  directory structure
+ *
+ *  @return		BT_STATUS_SUCCESS
+ */
+int
+bt_root_proc_remove(void)
+{
+	remove_proc_entry("mbt", PROC_DIR);
+	proc_mbt = NULL;
+	return BT_STATUS_SUCCESS;
+}
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_sdio.h b/drivers/bluetooth/mbtex_8997/bt/bt_sdio.h
new file mode 100755
index 000000000000..7b55d738ba16
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_sdio.h
@@ -0,0 +1,259 @@
+/** @file bt_sdio.h
+ *  @brief This file contains SDIO (interface) module
+ *  related macros, enum, and structure.
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_SDIO_H_
+#define _BT_SDIO_H_
+
+#include <linux/irqreturn.h>
+
+/** IRQ return type */
+typedef irqreturn_t IRQ_RET_TYPE;
+/** IRQ return */
+#define IRQ_RET		(return IRQ_HANDLED)
+/** ISR notifier function */
+typedef IRQ_RET_TYPE (*isr_notifier_fn_t) (s32 irq, void *dev_id,
+					   struct pt_regs * reg);
+
+/** SDIO header length */
+#define SDIO_HEADER_LEN			4
+
+/** Interrupt Mode SDIO */
+#define INT_MODE_SDIO       0
+/** Interrupt Mode GPIO */
+#define INT_MODE_GPIO       1
+/** New mode: GPIO-1 as a duplicated signal of interrupt as appear of SDIO_DAT1 */
+#define GPIO_INT_NEW_MODE   255
+/* SD block size can not bigger than 64 due to buf size limit in firmware */
+/** define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE			64
+/** define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL		256
+
+/** Number of blocks for firmware transfer */
+#define FIRMWARE_TRANSFER_NBLOCK	2
+
+/** Firmware ready */
+#define FIRMWARE_READY			0xfedc
+
+/* Bus Interface Control Reg 0x07 */
+/** SD BUS width 1 */
+#define SD_BUS_WIDTH_1			0x00
+/** SD BUS width 4 */
+#define SD_BUS_WIDTH_4			0x02
+/** SD BUS width mask */
+#define SD_BUS_WIDTH_MASK		0x03
+/** Asynchronous interrupt mode */
+#define ASYNC_INT_MODE			0x20
+
+/** magic register */
+#define CARD_MAGIC_REG          0xF0
+/** magic value */
+#define MAGIC_VAL               0x24
+
+/* Host Control Registers */
+/** Host Control Registers : Configuration */
+#define CONFIGURATION_REG		0x00
+/** Host Control Registers : Host without Command 53 finish host*/
+#define HOST_TO_CARD_EVENT		(0x1U << 3)
+/** Host Control Registers : Host terminates Command 53 */
+#define HOST_TERM_CMD53			(0x1U << 2)
+/** Host Control Registers : Host power up */
+#define HOST_POWER_UP			(0x1U << 1)
+/** Host Control Registers : Host power down */
+#define HOST_POWER_DOWN			(0x1U << 0)
+
+/** Host Control Registers : Host interrupt RSR */
+#define HOST_INT_RSR_REG		0x04
+
+/** Host Control Registers : Upload host interrupt RSR */
+#define UP_LD_HOST_INT_RSR		(0x1U)
+
+/** Host Control Registers : Host interrupt mask */
+#define HOST_INT_MASK_REG		0x08
+
+/** Host Control Registers : Upload host interrupt mask */
+#define UP_LD_HOST_INT_MASK		(0x1U)
+/** Host Control Registers : Download host interrupt mask */
+#define DN_LD_HOST_INT_MASK		(0x2U)
+/** Enable Host interrupt mask */
+#define HIM_ENABLE			(UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK)
+/** Disable Host interrupt mask */
+#define	HIM_DISABLE			0xff
+
+/** Host Control Registers : Host interrupt status */
+#define HOST_INTSTATUS_REG		0x0C
+/** Host Control Registers : Upload host interrupt status */
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+/** Host Control Registers : Download host interrupt status */
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+
+/** Host Control Registers : Host Transfer status */
+#define HOST_INT_STATUS_REG		0x58
+/** Host Control Registers : Upload CRC error */
+#define UP_LD_CRC_ERR			(0x1U << 2)
+/** Host Control Registers : Upload restart */
+#define UP_LD_RESTART			(0x1U << 1)
+/** Host Control Registers : Download restart */
+#define DN_LD_RESTART			(0x1U << 0)
+
+/** Card Control Registers : Card to Host Event register */
+#define CARD_STATUS_REG			0x5C
+/** Card Control Registers : Card I/O ready */
+#define CARD_IO_READY			(0x1U << 3)
+/** Card Control Registers : CIS card ready */
+#define CIS_CARD_RDY			(0x1U << 2)
+/** Card Control Registers : Upload card ready */
+#define UP_LD_CARD_RDY			(0x1U << 1)
+/** Card Control Registers : Download card ready */
+#define DN_LD_CARD_RDY			(0x1U << 0)
+
+/** Card Control Registers : Host interrupt mask register */
+#define HOST_INTERRUPT_MASK_REG 	0x60
+/** Card Control Registers : Host power interrupt mask */
+#define HOST_POWER_INT_MASK		(0x1U << 3)
+/** Card Control Registers : Abort card interrupt mask */
+#define ABORT_CARD_INT_MASK		(0x1U << 2)
+/** Card Control Registers : Upload card interrupt mask */
+#define UP_LD_CARD_INT_MASK          	(0x1U << 1)
+/** Card Control Registers : Download card interrupt mask */
+#define DN_LD_CARD_INT_MASK          	(0x1U << 0)
+
+/** Card Control Registers : Card interrupt status register */
+#define CARD_INTERRUPT_STATUS_REG    	0x64
+/** Card Control Registers : Power up interrupt */
+#define POWER_UP_INT			(0x1U << 4)
+/** Card Control Registers : Power down interrupt */
+#define POWER_DOWN_INT               	(0x1U << 3)
+
+/** Card Control Registers : Card interrupt RSR register */
+#define CARD_INTERRUPT_RSR_REG       	0x68
+/** Card Control Registers : Power up RSR */
+#define POWER_UP_RSR                 	(0x1U << 4)
+/** Card Control Registers : Power down RSR */
+#define POWER_DOWN_RSR               	(0x1U << 3)
+
+/* Card Control Registers */
+/** Card Control Registers : Read SQ base address A0 register */
+#define SQ_READ_BASE_ADDRESS_A0_REG  	0xf8
+/** Card Control Registers : Read SQ base address A1 register */
+#define SQ_READ_BASE_ADDRESS_A1_REG  	0xf9
+/** Card Control Registers : Read SQ base address A2 register */
+#define SQ_READ_BASE_ADDRESS_A2_REG  	0x6E
+/** Card Control Registers : Read SQ base address A3 register */
+#define SQ_READ_BASE_ADDRESS_A3_REG  	0x6F
+/** Card Control Registers : Write SQ base address A0 register */
+#define SQ_WRITE_BASE_ADDRESS_A0_REG  	0x70
+/** Card Control Registers : Write SQ base address A1 register */
+#define SQ_WRITE_BASE_ADDRESS_A1_REG  	0x71
+/** Card Control Registers : Write SQ base address A2 register */
+#define SQ_WRITE_BASE_ADDRESS_A2_REG  	0x72
+/** Card Control Registers : Write SQ base address A3 register */
+#define SQ_WRITE_BASE_ADDRESS_A3_REG  	0x73
+
+/** Card Control Registers : Card revision register */
+#define CARD_REVISION_REG            	0xC8
+
+/** Firmware status 0 register (SCRATCH0_0) */
+#define CARD_FW_STATUS0_REG             0xe8
+/** Firmware status 1 register (SCRATCH0_1) */
+#define CARD_FW_STATUS1_REG             0xe9
+/** Rx length register (SCRATCH0_2) */
+#define CARD_RX_LEN_REG                 0xea
+/** Rx unit register (SCRATCH0_3) */
+#define CARD_RX_UNIT_REG                0xeb
+/** Enable GPIO-1 as a duplicated signal of interrupt as appear of SDIO_DAT1*/
+#define ENABLE_GPIO_1_INT_MODE  0x88
+/** Scratch reg 3 2  :     Configure GPIO-1 INT*/
+#define SCRATCH_REG_32          0xEE
+
+/** Card Control Registers : Card OCR 0 register */
+#define CARD_OCR_0_REG			0xD4
+/** Card Control Registers : Card OCR 1 register */
+#define CARD_OCR_1_REG			0xD5
+/** Card Control Registers : Card OCR 3 register */
+#define CARD_OCR_3_REG			0xD6
+/** Card Control Registers : Card config register */
+#define CARD_CONFIG_REG			0xD7
+/** Card Control Registers : Miscellaneous Configuration Register */
+#define CARD_MISC_CFG_REG		0xD8
+/** Misc. Config Register : Auto Re-enable interrupts */
+#define AUTO_RE_ENABLE_INT		(0x1U << 4)
+
+/** Card Control Registers : Debug 0 register */
+#define DEBUG_0_REG			0xDC
+/** Card Control Registers : SD test BUS 0 */
+#define SD_TESTBUS0			(0x1U)
+/** Card Control Registers : Debug 1 register */
+#define DEBUG_1_REG			0xDD
+/** Card Control Registers : SD test BUS 1 */
+#define SD_TESTBUS1			(0x1U)
+/** Card Control Registers : Debug 2 register */
+#define DEBUG_2_REG			0xDE
+/** Card Control Registers : SD test BUS 2 */
+#define SD_TESTBUS2			(0x1U)
+/** Card Control Registers : Debug 3 register */
+#define DEBUG_3_REG			0xDF
+/** Card Control Registers : SD test BUS 3 */
+#define SD_TESTBUS3			(0x1U)
+
+/** Host Control Registers : I/O port 0 */
+#define IO_PORT_0_REG			0xE4
+/** Host Control Registers : I/O port 1 */
+#define IO_PORT_1_REG			0xE5
+/** Host Control Registers : I/O port 2 */
+#define IO_PORT_2_REG			0xE6
+
+struct sdio_mmc_card {
+	/** sdio_func structure pointer */
+	struct sdio_func *func;
+	/** bt_private structure pointer */
+	bt_private *priv;
+};
+
+/** DMA alignment value */
+#define DMA_ALIGNMENT	64
+/** Macros for Data Alignment : size */
+#define ALIGN_SZ(p, a)	\
+	(((p) + ((a) - 1)) & ~((a) - 1))
+
+/** Macros for Data Alignment : address */
+#define ALIGN_ADDR(p, a)	\
+	((((t_ptr)(p)) + (((t_ptr)(a)) - 1)) & ~(((t_ptr)(a)) - 1))
+
+/** This function read cmd52 register */
+int sd_write_reg(bt_private *priv, int reg, u8 val);
+/** This function write cmd52 value to register */
+int sd_read_reg(bt_private *priv, int reg, u8 *data);
+/** This function reads the Cmd52 value in dev structure */
+int sd_read_cmd52_val(bt_private *priv);
+/** This function updates card reg based on the Cmd52 value in dev structure */
+int sd_write_cmd52_val(bt_private *priv, int func, int reg, int val);
+
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+/** This function tells lower driver that BT is suspended */
+void bt_is_suspended(bt_private *priv);
+#endif
+#endif
+#endif
+#endif /* _BT_SDIO_H_ */
diff --git a/drivers/bluetooth/mbtex_8997/bt/bt_sdiommc.c b/drivers/bluetooth/mbtex_8997/bt/bt_sdiommc.c
new file mode 100755
index 000000000000..012af3771953
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/bt_sdiommc.c
@@ -0,0 +1,1933 @@
+/** @file bt_sdiommc.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#include <linux/firmware.h>
+#include <linux/mmc/sdio_func.h>
+#include        <linux/mmc/sdio.h>
+#include        <linux/mmc/card.h>
+
+#include "bt_drv.h"
+#include "bt_sdio.h"
+
+/** define nxp vendor id */
+#define NXP_VENDOR_ID 0x02df
+
+/** Max retry number of CMD53 read/write */
+#define MAX_CMD53_RETRY 	3
+/** Max retry number of CMD53 read/write */
+#define MAX_CMD52_RETRY     3
+/** Firmware name */
+static char *fw_name;
+/** fw serial download flag */
+extern int bt_fw_serial;
+/** request firmware nowait */
+int bt_req_fw_nowait;
+static int multi_fn = BIT(2);
+
+#define SD8997_FW_NAME "nxp/sdsd8997_combo_v4.bin"
+#define SD8997_BT_FW_NAME "nxp/sd8997_bt_v4.bin"
+#define DEFAULT_FW_NAME "nxp/sdsd8997_combo_v4.bin"
+#define DEFAULT_BT_FW_NAME "nxp/sd8997_bt_v4.bin"
+
+/** Function number 2 */
+#define FN2			2
+/** Device ID for SD8997 FN2 */
+#define SD_DEVICE_ID_8997_BT_FN2    0x9142
+
+/** Array of SDIO device ids when multi_fn=0x12 */
+static const struct sdio_device_id bt_ids[] = {
+	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8997_BT_FN2)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(sdio, bt_ids);
+
+#ifdef SDIO_OOB_IRQ
+extern int mrvl_sdio_claim_irq(struct sdio_func *func,
+			       sdio_irq_handler_t * handler);
+extern int mrvl_sdio_release_irq(struct sdio_func *func);
+extern int mrvl_sdio_suspend(struct sdio_func *func);
+extern int mrvl_sdio_resume(struct sdio_func *func);
+#endif
+
+/********************************************************
+		Global Variables
+********************************************************/
+#ifdef SDIO_SUSPEND_RESUME
+/** PM keep power */
+extern int mbt_pm_keep_power;
+#endif
+
+extern bt_private *m_priv[];
+/********************************************************
+		Local Functions
+********************************************************/
+
+/**
+ *  @brief This function gets rx_unit value
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_get_rx_unit(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 reg;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 card_rx_unit_reg = CARD_RX_UNIT_REG;
+
+	ENTER();
+
+	reg = sdio_readb(card->func, card_rx_unit_reg, &ret);
+	if (ret == BT_STATUS_SUCCESS)
+		priv->bt_dev.rx_unit = reg;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function reads fwstatus registers
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_read_firmware_status(bt_private *priv, u16 * dat)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 fws0;
+	u8 fws1;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 card_fw_status0_reg = CARD_FW_STATUS0_REG;
+	u8 card_fw_status1_reg = CARD_FW_STATUS1_REG;
+
+	ENTER();
+
+	fws0 = sdio_readb(card->func, card_fw_status0_reg, &ret);
+	if (ret < 0) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+
+	fws1 = sdio_readb(card->func, card_fw_status1_reg, &ret);
+	if (ret < 0) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+
+	*dat = (((u16) fws1) << 8) | fws0;
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function reads rx length
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return        BT_STATUS_SUCCESS or other error no.
+ */
+static int
+sd_read_rx_len(bt_private *priv, u16 * dat)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 reg;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 card_rx_len_reg = CARD_RX_LEN_REG;
+
+	ENTER();
+
+	reg = sdio_readb(card->func, card_rx_len_reg, &ret);
+	if (ret == BT_STATUS_SUCCESS)
+		*dat = (u16) reg << priv->bt_dev.rx_unit;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function enables the host interrupts mask
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_enable_host_int_mask(bt_private *priv, u8 mask)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 host_int_mask_reg = HOST_INT_MASK_REG;
+
+	ENTER();
+
+	sdio_writeb(card->func, mask, host_int_mask_reg, &ret);
+	if (ret) {
+		PRINTM(WARN, "BT: Unable to enable the host interrupt!\n");
+		ret = BT_STATUS_FAILURE;
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/** @brief This function disables the host interrupts mask.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return        BT_STATUS_SUCCESS or other error no.
+ */
+static int
+sbi_disable_host_int_mask(bt_private *priv, u8 mask)
+{
+	int ret = BT_STATUS_FAILURE;
+	u8 host_int_mask;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 host_int_mask_reg = HOST_INT_MASK_REG;
+
+	ENTER();
+
+	/* Read back the host_int_mask register */
+	host_int_mask = sdio_readb(card->func, host_int_mask_reg, &ret);
+	if (ret)
+		goto done;
+
+	/* Update with the mask and write back to the register */
+	host_int_mask &= ~mask;
+	sdio_writeb(card->func, host_int_mask, host_int_mask_reg, &ret);
+	if (ret < 0) {
+		PRINTM(WARN, "BT: Unable to diable the host interrupt!\n");
+		goto done;
+	}
+	ret = BT_STATUS_SUCCESS;
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function polls the card status register
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param bits     the bit mask
+ *  @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_poll_card_status(bt_private *priv, u8 bits)
+{
+	int tries;
+	int rval;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 cs;
+	u8 card_status_reg = CARD_STATUS_REG;
+
+	ENTER();
+
+	for (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {
+		cs = sdio_readb(card->func, card_status_reg, &rval);
+		if (rval != 0)
+			break;
+		if (rval == 0 && (cs & bits) == bits) {
+			LEAVE();
+			return BT_STATUS_SUCCESS;
+		}
+		udelay(1);
+	}
+	PRINTM(ERROR,
+	       "BT: sdio_poll_card_status failed (%d), tries = %d, cs = 0x%x\n",
+	       rval, tries, cs);
+
+	LEAVE();
+	return BT_STATUS_FAILURE;
+}
+
+/**
+ *  @brief This function reads updates the Cmd52 value in dev structure
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @return         BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_read_cmd52_val(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 func, reg, val;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+
+	ENTER();
+
+	func = priv->bt_dev.cmd52_func;
+	reg = priv->bt_dev.cmd52_reg;
+	sdio_claim_host(card->func);
+	if (func)
+		val = sdio_readb(card->func, reg, &ret);
+	else
+		val = sdio_f0_readb(card->func, reg, &ret);
+	sdio_release_host(card->func);
+	if (ret) {
+		PRINTM(ERROR, "BT: Cannot read value from func %d reg %d\n",
+		       func, reg);
+	} else {
+		priv->bt_dev.cmd52_val = val;
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function updates card reg based on the Cmd52 value in dev structure
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param func     Stores func variable
+ *  @param reg      Stores reg variable
+ *  @param val      Stores val variable
+ *  @return         BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_write_cmd52_val(bt_private *priv, int func, int reg, int val)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+
+	ENTER();
+
+	if (val >= 0) {
+		/* Perform actual write only if val is provided */
+		sdio_claim_host(card->func);
+		if (func)
+			sdio_writeb(card->func, val, reg, &ret);
+		else
+			sdio_f0_writeb(card->func, val, reg, &ret);
+		sdio_release_host(card->func);
+		if (ret) {
+			PRINTM(ERROR,
+			       "BT: Cannot write value (0x%x) to func %d reg %d\n",
+			       val, func, reg);
+			goto done;
+		}
+		priv->bt_dev.cmd52_val = val;
+	}
+
+	/* Save current func and reg for future read */
+	priv->bt_dev.cmd52_func = func;
+	priv->bt_dev.cmd52_reg = reg;
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function updates card reg based on the Cmd52 value in dev structure
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param reg      register to write
+ *  @param val      value
+ *  @return         BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_write_reg(bt_private *priv, int reg, u8 val)
+{
+	int ret = BT_STATUS_SUCCESS;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	ENTER();
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, val, reg, &ret);
+	sdio_release_host(card->func);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function reads updates the Cmd52 value in dev structure
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param reg      register to read
+ *  @param data		Data
+ *  @return         BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_read_reg(bt_private *priv, int reg, u8 *data)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 val;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	ENTER();
+	sdio_claim_host(card->func);
+	val = sdio_readb(card->func, reg, &ret);
+	sdio_release_host(card->func);
+	*data = val;
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function reads FN0 reg value
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param reg      register to read
+ *  @param data		Data
+ *  @return         BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_f0_read_reg(bt_private *priv, int reg, u8 *data)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 val;
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	ENTER();
+	sdio_claim_host(card->func);
+	val = sdio_f0_readb(card->func, reg, &ret);
+	sdio_release_host(card->func);
+	*data = val;
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function probes the card
+ *
+ *  @param func    A pointer to sdio_func structure.
+ *  @param id      A pointer to structure sdio_device_id
+ *  @return        BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+static int
+sd_probe_card(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	int ret = BT_STATUS_SUCCESS;
+	bt_private *priv = NULL;
+	struct sdio_mmc_card *card = NULL;
+
+	ENTER();
+
+	PRINTM(INFO, "BT: vendor=0x%x,device=0x%x,class=%d,fn=%d\n", id->vendor,
+	       id->device, id->class, func->num);
+	card = kzalloc(sizeof(struct sdio_mmc_card), GFP_KERNEL);
+	if (!card) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	card->func = func;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	/* wait for chip fully wake up */
+	if (!func->enable_timeout)
+		func->enable_timeout = 200;
+#endif
+	sdio_claim_host(func);
+	ret = sdio_enable_func(func);
+	if (ret) {
+		sdio_disable_func(func);
+		sdio_release_host(func);
+		PRINTM(FATAL, "BT: sdio_enable_func() failed: ret=%d\n", ret);
+		kfree(card);
+		LEAVE();
+		return -EIO;
+	}
+	sdio_release_host(func);
+	priv = bt_add_card(card);
+	if (!priv) {
+		sdio_claim_host(func);
+		sdio_disable_func(func);
+		sdio_release_host(func);
+		ret = BT_STATUS_FAILURE;
+		kfree(card);
+	}
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @param pollnum  Number of times to poll fw status
+ *  @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_verify_fw_download(bt_private *priv, int pollnum)
+{
+	int ret = BT_STATUS_FAILURE;
+	u16 firmwarestat = 0;
+	int tries;
+
+	ENTER();
+
+	/* Wait for firmware initialization event */
+	for (tries = 0; tries < pollnum; tries++) {
+		if (sd_read_firmware_status(priv, &firmwarestat) < 0)
+			continue;
+		if (firmwarestat == FIRMWARE_READY) {
+			PRINTM(MSG, "BT FW is active(%d)\n", tries);
+			ret = BT_STATUS_SUCCESS;
+			break;
+		}
+		mdelay(100);
+	}
+	if ((pollnum > 1) && (ret != BT_STATUS_SUCCESS)) {
+		PRINTM(ERROR,
+		       "Fail to poll firmware status: firmwarestat=0x%x\n",
+		       firmwarestat);
+		bt_dump_sdio_regs(priv);
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Transfers firmware to card
+ *
+ *  @param priv      A Pointer to bt_private structure
+ *  @param fw        A Pointer to fw image
+ *  @param fw_len    fw image len
+ *  @return          BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+static int
+sd_init_fw_dpc(bt_private *priv, u8 *fw, int fw_len)
+{
+	struct sdio_mmc_card *card = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 *firmware = fw;
+	int firmwarelen = fw_len;
+	u8 base0;
+	u8 base1;
+	int ret = BT_STATUS_SUCCESS;
+	int offset;
+	void *tmpfwbuf = NULL;
+	int tmpfwbufsz;
+	u8 *fwbuf;
+	u16 len;
+	int txlen = 0;
+	int tx_blocks = 0;
+	int i = 0;
+	int tries = 0;
+#ifdef FW_DOWNLOAD_SPEED
+	u32 tv1, tv2;
+#endif
+	u8 sq_read_base_address_a0_reg = SQ_READ_BASE_ADDRESS_A0_REG;
+	u8 sq_read_base_address_a1_reg = SQ_READ_BASE_ADDRESS_A1_REG;
+
+	ENTER();
+
+	PRINTM(INFO, "BT: Downloading FW image (%d bytes)\n", firmwarelen);
+
+#ifdef FW_DOWNLOAD_SPEED
+	tv1 = get_utimeofday();
+#endif
+
+	tmpfwbufsz = BT_UPLD_SIZE + DMA_ALIGNMENT;
+	tmpfwbuf = kzalloc(tmpfwbufsz, GFP_KERNEL);
+	if (!tmpfwbuf) {
+		PRINTM(ERROR,
+		       "BT: Unable to allocate buffer for firmware. Terminating download\n");
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+	/* Ensure aligned firmware buffer */
+	fwbuf = (u8 *)ALIGN_ADDR(tmpfwbuf, DMA_ALIGNMENT);
+
+	/* Perform firmware data transfer */
+	offset = 0;
+	do {
+		/* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits
+		 */
+		ret = sd_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+		if (ret < 0) {
+			PRINTM(FATAL,
+			       "BT: FW download with helper poll status timeout @ %d\n",
+			       offset);
+			goto done;
+		}
+		/* More data? */
+		if (offset >= firmwarelen)
+			break;
+
+		for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+			base0 = sdio_readb(card->func,
+					   sq_read_base_address_a0_reg, &ret);
+			if (ret) {
+				PRINTM(WARN, "Dev BASE0 register read failed:"
+				       " base0=0x%04X(%d). Terminating download\n",
+				       base0, base0);
+				ret = BT_STATUS_FAILURE;
+				goto done;
+			}
+			base1 = sdio_readb(card->func,
+					   sq_read_base_address_a1_reg, &ret);
+			if (ret) {
+				PRINTM(WARN, "Dev BASE1 register read failed:"
+				       " base1=0x%04X(%d). Terminating download\n",
+				       base1, base1);
+				ret = BT_STATUS_FAILURE;
+				goto done;
+			}
+			len = (((u16) base1) << 8) | base0;
+
+			if (len != 0)
+				break;
+			udelay(10);
+		}
+
+		if (len == 0)
+			break;
+		else if (len > BT_UPLD_SIZE) {
+			PRINTM(FATAL,
+			       "BT: FW download failure @ %d, invalid length %d\n",
+			       offset, len);
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+	/** ignore CRC check before download the first packet */
+		if (offset == 0 && (len & BIT(0)))
+			len &= ~BIT(0);
+		txlen = len;
+
+		if (len & BIT(0)) {
+			i++;
+			if (i >= MAX_CMD53_RETRY) {
+				PRINTM(FATAL,
+				       "BT: FW download failure @ %d, over max retry count\n",
+				       offset);
+				ret = BT_STATUS_FAILURE;
+				goto done;
+			}
+			PRINTM(ERROR,
+			       "BT: FW CRC error indicated by the helper:"
+			       " len = 0x%04X, txlen = %d\n", len, txlen);
+			len &= ~BIT(0);
+
+			PRINTM(ERROR, "BT: retry: %d, offset %d\n", i, offset);
+			/* Setting this to 0 to resend from same offset */
+			txlen = 0;
+		} else {
+			i = 0;
+
+			/* Set blocksize to transfer - checking for last block */
+			if (firmwarelen - offset < txlen)
+				txlen = firmwarelen - offset;
+
+			PRINTM(INFO, ".");
+
+			tx_blocks =
+				(txlen + SD_BLOCK_SIZE_FW_DL -
+				 1) / SD_BLOCK_SIZE_FW_DL;
+
+			/* Copy payload to buffer */
+			memcpy(fwbuf, &firmware[offset], txlen);
+		}
+
+		/* Send data */
+		ret = sdio_writesb(card->func, priv->bt_dev.ioport, fwbuf,
+				   tx_blocks * SD_BLOCK_SIZE_FW_DL);
+
+		if (ret < 0) {
+			PRINTM(ERROR,
+			       "BT: FW download, write iomem (%d) failed @ %d\n",
+			       i, offset);
+			sdio_writeb(card->func, 0x04, CONFIGURATION_REG, &ret);
+			if (ret)
+				PRINTM(ERROR, "write ioreg failed (CFG)\n");
+		}
+
+		offset += txlen;
+	} while (TRUE);
+
+	PRINTM(MSG, "BT: FW download over, size %d bytes\n", offset);
+
+	ret = BT_STATUS_SUCCESS;
+done:
+#ifdef FW_DOWNLOAD_SPEED
+	tv2 = get_utimeofday();
+	PRINTM(INFO, "FW: %d.%03d.%03d ", tv1 / 1000000,
+	       (tv1 % 1000000) / 1000, tv1 % 1000);
+	PRINTM(INFO, " -> %d.%03d.%03d ", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+	tv2 -= tv1;
+	PRINTM(INFO, " == %d.%03d.%03d\n", tv2 / 1000000,
+	       (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+	kfree(tmpfwbuf);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief request_firmware callback
+ *
+ * @param fw_firmware  A pointer to firmware structure
+ * @param context      A Pointer to bt_private structure
+ * @return             BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_request_fw_dpc(const struct firmware *fw_firmware, void *context)
+{
+	int ret = BT_STATUS_SUCCESS;
+	bt_private *priv = (bt_private *)context;
+	struct sdio_mmc_card *card = NULL;
+	struct m_dev *m_dev_bt = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+	struct __kernel_old_timeval tstamp;
+#else
+	struct timeval tstamp;
+#endif
+	int index;
+
+	ENTER();
+
+	m_dev_bt = &priv->bt_dev.m_dev[BT_SEQ];
+
+	if ((priv == NULL) || (priv->adapter == NULL) ||
+	    (priv->bt_dev.card == NULL) || (m_dev_bt == NULL)
+		) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+
+	card = (struct sdio_mmc_card *)priv->bt_dev.card;
+
+	if (!fw_firmware) {
+		get_monotonic_time(&tstamp);
+		if (tstamp.tv_sec >
+		    (priv->req_fw_time.tv_sec + REQUEST_FW_TIMEOUT)) {
+			PRINTM(ERROR,
+			       "BT: No firmware image found. Skipping download\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		PRINTM(ERROR,
+		       "BT: No firmware image found! Retrying download\n");
+		/* Wait a second here before calling the callback again */
+		os_sched_timeout(1000);
+		sd_download_firmware_w_helper(priv);
+		LEAVE();
+		return ret;
+	}
+
+	priv->firmware = fw_firmware;
+
+	if (BT_STATUS_FAILURE ==
+	    sd_init_fw_dpc(priv, (u8 *)priv->firmware->data,
+			   priv->firmware->size)) {
+		PRINTM(ERROR,
+		       "BT: sd_init_fw_dpc failed (download fw with nowait: %d). Terminating download\n",
+		       bt_req_fw_nowait);
+		sdio_release_host(card->func);
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* check if the fimware is downloaded successfully or not */
+	if (sd_verify_fw_download(priv, MAX_FIRMWARE_POLL_TRIES)) {
+		PRINTM(ERROR, "BT: FW failed to be active in time!\n");
+		ret = BT_STATUS_FAILURE;
+		sdio_release_host(card->func);
+		goto done;
+	}
+	sdio_release_host(card->func);
+	sbi_enable_host_int(priv);
+	if (BT_STATUS_FAILURE == sbi_register_conf_dpc(priv)) {
+		PRINTM(ERROR,
+		       "BT: sbi_register_conf_dpc failed. Terminating download\n");
+		ret = BT_STATUS_FAILURE;
+		goto done;
+	}
+	if (fw_firmware) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+		if (!bt_req_fw_nowait)
+#endif
+			release_firmware(fw_firmware);
+	}
+	LEAVE();
+	return ret;
+
+done:
+	if (fw_firmware) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+		if (!bt_req_fw_nowait)
+#endif
+			release_firmware(fw_firmware);
+	}
+	/* For synchronous download cleanup will be done in add_card */
+	if (!bt_req_fw_nowait)
+		return ret;
+	PRINTM(INFO, "unregister device\n");
+	sbi_unregister_dev(priv);
+	((struct sdio_mmc_card *)card)->priv = NULL;
+	/* Stop the thread servicing the interrupts */
+	priv->adapter->SurpriseRemoved = TRUE;
+	wake_up_interruptible(&priv->MainThread.waitQ);
+	while (priv->MainThread.pid)
+		os_sched_timeout(1);
+	bt_proc_remove(priv);
+	clean_up_m_devs(priv);
+	bt_free_adapter(priv);
+	for (index = 0; index < MAX_BT_ADAPTER; index++) {
+		if (m_priv[index] == priv) {
+			m_priv[index] = NULL;
+			break;
+		}
+	}
+	bt_priv_put(priv);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief request_firmware callback
+ *        This function is invoked by request_firmware_nowait system call
+ *
+ * @param firmware     A pointer to firmware structure
+ * @param context      A Pointer to bt_private structure
+ * @return             None
+ **/
+static void
+sd_request_fw_callback(const struct firmware *firmware, void *context)
+{
+	ENTER();
+	sd_request_fw_dpc(firmware, context);
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function downloads firmware image to the card.
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @return         BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sd_download_firmware_w_helper(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	int err;
+	char *cur_fw_name = NULL;
+
+	ENTER();
+
+	cur_fw_name = fw_name;
+	if (fw_name == NULL) {
+		if (!bt_fw_serial || priv->fw_reload || bt_fw_reload)
+			cur_fw_name = DEFAULT_BT_FW_NAME;
+		else
+			cur_fw_name = DEFAULT_FW_NAME;
+	}
+
+	PRINTM(MSG, "BT Request firmware: %s\n", cur_fw_name);
+	if (bt_req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cur_fw_name, priv->hotplug_device,
+					      GFP_KERNEL, priv,
+					      sd_request_fw_callback);
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13)
+		ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+					      cur_fw_name, priv->hotplug_device,
+					      priv, sd_request_fw_callback);
+#else
+		ret = request_firmware_nowait(THIS_MODULE,
+					      cur_fw_name, priv->hotplug_device,
+					      priv, sd_request_fw_callback);
+#endif
+#endif
+		if (ret < 0)
+			PRINTM(FATAL,
+			       "BT: request_firmware_nowait() failed, error code = %#x\n",
+			       ret);
+	} else {
+		err = request_firmware(&priv->firmware, cur_fw_name,
+				       priv->hotplug_device);
+		if (err < 0) {
+			PRINTM(FATAL,
+			       "BT: request_firmware() failed, error code = %#x\n",
+			       err);
+			ret = BT_STATUS_FAILURE;
+		} else
+			ret = sd_request_fw_dpc(priv->firmware, priv);
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function reads data from the card.
+ *
+ *  @param priv     A pointer to bt_private structure
+ *  @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_card_to_host(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u16 buf_len = 0;
+	int buf_block_len;
+	int blksz;
+	struct sk_buff *skb = NULL;
+	u32 type;
+	u8 *payload = NULL;
+	struct hci_dev *hdev = NULL;
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	int i = 0;
+
+	ENTER();
+	if (priv->bt_dev.m_dev[BT_SEQ].spec_type == BLUEZ_SPEC)
+		hdev = (struct hci_dev *)priv->bt_dev.m_dev[BT_SEQ].dev_pointer;
+	if (!card || !card->func) {
+		PRINTM(ERROR, "BT: card or function is NULL!\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+
+	do {
+		/* Read the length of data to be transferred */
+		ret = sd_read_rx_len(priv, &buf_len);
+		if (ret < 0) {
+			i++;
+			PRINTM(ERROR, "BT: Read scratch reg failed (%d)\n", i);
+			if (i >= MAX_CMD52_RETRY) {
+				ret = BT_STATUS_FAILURE;
+				goto exit;
+			}
+			udelay(20);
+		}
+	}
+	while (ret == BT_STATUS_FAILURE);
+
+	/* Allocate buffer */
+	blksz = SD_BLOCK_SIZE;
+	buf_block_len = (buf_len + blksz - 1) / blksz;
+	if (buf_len <= BT_HEADER_LEN ||
+	    (buf_block_len * blksz) > ALLOC_BUF_SIZE) {
+		PRINTM(ERROR, "BT: card_to_host, invalid packet length: %d\n",
+		       buf_len);
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+	skb = bt_skb_alloc(buf_block_len * blksz + DMA_ALIGNMENT, GFP_ATOMIC);
+	if (skb == NULL) {
+		PRINTM(WARN, "BT: No free skb\n");
+		goto exit;
+	}
+	if ((t_ptr)skb->data & (DMA_ALIGNMENT - 1)) {
+		skb_put(skb,
+			DMA_ALIGNMENT -
+			((t_ptr)skb->data & (DMA_ALIGNMENT - 1)));
+		skb_pull(skb,
+			 DMA_ALIGNMENT -
+			 ((t_ptr)skb->data & (DMA_ALIGNMENT - 1)));
+	}
+
+	payload = skb->data;
+	i = 0;
+	do {
+		ret = sdio_readsb(card->func, payload, priv->bt_dev.ioport,
+				  buf_block_len * blksz);
+		if (ret < 0) {
+			i++;
+			PRINTM(ERROR,
+			       "BT: card_to_host, read iomem (%d) failed: %d\n",
+			       i, ret);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+			/* issue abort cmd52 command through F0 */
+			sdio_f0_writeb(card->func, 0x01, SDIO_CCCR_ABORT, &ret);
+#endif
+			sdio_writeb(card->func, HOST_TERM_CMD53,
+				    CONFIGURATION_REG, &ret);
+			udelay(20);
+			ret = BT_STATUS_FAILURE;
+			if (i >= MAX_CMD53_RETRY) {
+				kfree_skb(skb);
+				skb = NULL;
+				goto exit;
+			}
+		}
+	} while (ret == BT_STATUS_FAILURE);
+	/* This is SDIO specific header length: byte[2][1][0], * type: byte[3]
+	   (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor) */
+	buf_len = payload[0];
+	buf_len |= (u16) payload[1] << 8;
+	type = payload[3];
+	PRINTM(DATA, "BT: SDIO Blk Rd %s: len=%d type=%d\n", hdev->name,
+	       buf_len, type);
+	if (buf_len > buf_block_len * blksz) {
+		PRINTM(ERROR,
+		       "BT: Drop invalid rx pkt, len in hdr=%d, cmd53 length=%d\n",
+		       buf_len, buf_block_len * blksz);
+		ret = BT_STATUS_FAILURE;
+		kfree_skb(skb);
+		skb = NULL;
+		goto exit;
+	}
+	DBG_HEXDUMP(DAT_D, "BT: SDIO Blk Rd", payload, buf_len);
+	switch (type) {
+	case HCI_ACLDATA_PKT:
+		bt_cb(skb)->pkt_type = type;
+		skb_put(skb, buf_len);
+		skb_pull(skb, BT_HEADER_LEN);
+		if (*(u16 *) skb->data == 0xffff) {
+			bt_store_firmware_dump(priv, skb->data, skb->len);
+			dev_kfree_skb_any(skb);
+			break;
+		}
+		bt_recv_frame(priv, skb);
+		break;
+	case HCI_SCODATA_PKT:
+		bt_cb(skb)->pkt_type = type;
+		skb_put(skb, buf_len);
+		skb_pull(skb, BT_HEADER_LEN);
+		bt_recv_frame(priv, skb);
+		break;
+	case HCI_EVENT_PKT:
+		/** add EVT Demux */
+		bt_cb(skb)->pkt_type = type;
+		skb_put(skb, buf_len);
+		skb_pull(skb, BT_HEADER_LEN);
+		if (BT_STATUS_SUCCESS == check_evtpkt(priv, skb))
+			break;
+		switch (skb->data[0]) {
+		case 0x0E:
+			/** cmd complete */
+			bt_recv_frame(priv, skb);
+			break;
+		case 0x0F:
+			/** cmd status */
+			bt_recv_frame(priv, skb);
+			break;
+		case 0xFF:
+			/** Vendor specific pkt */
+			bt_recv_frame(priv, skb);
+			break;
+		default:
+			bt_recv_frame(priv, skb);
+			break;
+		}
+		break;
+	case MRVL_VENDOR_PKT:
+		/* Just think here need to back compatible FM */
+		bt_cb(skb)->pkt_type = HCI_VENDOR_PKT;
+		skb_put(skb, buf_len);
+		skb_pull(skb, BT_HEADER_LEN);
+		if (BT_STATUS_SUCCESS != bt_process_event(priv, skb))
+			bt_recv_frame(priv, skb);
+		break;
+	default:
+		/* Driver specified event and command resp should be handle
+		   here */
+		PRINTM(INFO, "BT: Unknown PKT type:%d\n", type);
+		kfree_skb(skb);
+		skb = NULL;
+		break;
+	}
+exit:
+	if (ret) {
+		if (hdev)
+			hdev->stat.err_rx++;
+		PRINTM(ERROR, "error when recv pkt!\n");
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function removes the card
+ *
+ *  @param func    A pointer to sdio_func structure
+ *  @return        N/A
+ */
+static void
+sd_remove_card(struct sdio_func *func)
+{
+	struct sdio_mmc_card *card;
+
+	ENTER();
+
+	if (func) {
+		card = sdio_get_drvdata(func);
+		if (card) {
+			bt_remove_card(card->priv);
+			kfree(card);
+		}
+	}
+
+	LEAVE();
+}
+
+/**
+ *  @brief This function handles the interrupt.
+ *
+ *  @param func  A pointer to sdio_func structure
+ *  @return      N/A
+ */
+static void
+sd_interrupt(struct sdio_func *func)
+{
+	bt_private *priv;
+	struct m_dev *m_dev = NULL;
+	struct sdio_mmc_card *card;
+	int ret = BT_STATUS_SUCCESS;
+	u8 ireg = 0;
+	u8 host_intstatus_reg = HOST_INTSTATUS_REG;
+
+	ENTER();
+
+	card = sdio_get_drvdata(func);
+	if (!card || !card->priv) {
+		PRINTM(INFO,
+		       "BT: %s: sbi_interrupt(%p) card or priv is NULL, card=%p\n",
+		       __func__, func, card);
+		LEAVE();
+		return;
+	}
+	priv = card->priv;
+	m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+	ret = sdio_readsb(card->func, priv->adapter->hw_regs, 0, SD_BLOCK_SIZE);
+	/* ignore CRC error from bus driver */
+	if (ret && ret != -EILSEQ) {
+		PRINTM(ERROR,
+		       "BT: sdio_read_ioreg: cmd53 read int status register failed %d\n",
+		       ret);
+		goto done;
+	}
+	ireg = priv->adapter->hw_regs[host_intstatus_reg];
+	if (ireg != 0) {
+		/*
+		 * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+		 * Clear the interrupt status register and re-enable
+		 * the interrupt
+		 */
+		PRINTM(INTR, "BT: INT %s: sdio_ireg = 0x%x\n", m_dev->name,
+		       ireg);
+		priv->adapter->irq_recv = ireg;
+	} else {
+		PRINTM(ERROR, "BT: ERR: ireg=0\n");
+	}
+	OS_INT_DISABLE;
+	priv->adapter->sd_ireg |= ireg;
+	OS_INT_RESTORE;
+	bt_interrupt(m_dev);
+done:
+	LEAVE();
+}
+
+/**
+ *  @brief This function checks if the interface is ready to download
+ *  or not while other download interfaces are present
+ *
+ *  @param priv   A pointer to bt_private structure
+ *  @param val    Winner status (0: winner)
+ *  @return       BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_check_winner_status(bt_private *priv, u8 *val)
+{
+
+	int ret = BT_STATUS_SUCCESS;
+	u8 winner = 0;
+	struct sdio_mmc_card *cardp = (struct sdio_mmc_card *)priv->bt_dev.card;
+	u8 card_fw_status0_reg = CARD_FW_STATUS0_REG;
+
+	ENTER();
+	winner = sdio_readb(cardp->func, card_fw_status0_reg, &ret);
+	if (ret != BT_STATUS_SUCCESS) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	*val = winner;
+
+	LEAVE();
+	return ret;
+}
+
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+/** @brief This function tells lower driver that BT is suspended
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        None
+ */
+void
+bt_is_suspended(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	priv->adapter->is_suspended = TRUE;
+	sdio_func_suspended(card->func);
+}
+#endif
+
+/** @brief This function handles client driver suspend
+ *
+ *  @param dev	   A pointer to device structure
+ *  @return        BT_STATUS_SUCCESS or other error no.
+ */
+int
+bt_sdio_suspend(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	mmc_pm_flag_t pm_flags = 0;
+	bt_private *priv = NULL;
+	struct sdio_mmc_card *cardp;
+	struct m_dev *m_dev = NULL;
+	struct hci_dev *hcidev;
+
+	ENTER();
+
+	pm_flags = sdio_get_host_pm_caps(func);
+	PRINTM(CMD, "BT: %s: suspend: PM flags = 0x%x\n", sdio_func_id(func),
+	       pm_flags);
+	if (!(pm_flags & MMC_PM_KEEP_POWER)) {
+		PRINTM(ERROR,
+		       "BT: %s: cannot remain alive while host is suspended\n",
+		       sdio_func_id(func));
+		return -ENOSYS;
+	}
+	cardp = sdio_get_drvdata(func);
+	if (!cardp || !cardp->priv) {
+		PRINTM(ERROR, "BT: Card or priv structure is not valid\n");
+		LEAVE();
+		return BT_STATUS_SUCCESS;
+	}
+
+	priv = cardp->priv;
+
+	m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+	PRINTM(CMD, "BT %s: SDIO suspend\n", m_dev->name);
+	hcidev = (struct hci_dev *)m_dev->dev_pointer;
+	hci_suspend_dev(hcidev);
+	skb_queue_purge(&priv->adapter->tx_queue);
+
+	if ((mbt_pm_keep_power) && (priv->adapter->hs_state != HS_ACTIVATED)) {
+
+		if (BT_STATUS_SUCCESS != bt_enable_hs(priv, FALSE)) {
+			PRINTM(CMD, "BT: HS not actived, suspend fail!\n");
+			if (BT_STATUS_SUCCESS != bt_enable_hs(priv, FALSE)) {
+				PRINTM(CMD,
+				       "BT: HS not actived the second time, force to suspend!\n");
+			}
+		}
+	}
+
+	priv->adapter->is_suspended = TRUE;
+
+#ifdef SDIO_OOB_IRQ
+	mrvl_sdio_suspend(func);
+#endif
+	LEAVE();
+	/* We will keep the power when hs enabled successfully */
+	if ((mbt_pm_keep_power) && (priv->adapter->hs_state == HS_ACTIVATED)) {
+#ifdef MMC_PM_SKIP_RESUME_PROBE
+		PRINTM(CMD, "BT: suspend with MMC_PM_KEEP_POWER and "
+		       "MMC_PM_SKIP_RESUME_PROBE\n");
+		return sdio_set_host_pm_flags(func,
+					      MMC_PM_KEEP_POWER |
+					      MMC_PM_SKIP_RESUME_PROBE);
+#else
+		PRINTM(CMD, "BT: suspend with MMC_PM_KEEP_POWER\n");
+		return sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+#endif
+	} else {
+		PRINTM(CMD, "BT: suspend without MMC_PM_KEEP_POWER\n");
+		return BT_STATUS_SUCCESS;
+	}
+}
+
+void
+bt_sdio_shutdown(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	mmc_pm_flag_t pm_flags = 0;
+	bt_private *priv = NULL;
+	struct sdio_mmc_card *cardp;
+
+	ENTER();
+
+	pm_flags = sdio_get_host_pm_caps(func);
+	PRINTM(CMD, "BT: %s: shutdown: PM flags = 0x%x\n", sdio_func_id(func),
+	       pm_flags);
+	if (!(pm_flags & MMC_PM_KEEP_POWER)) {
+		PRINTM(ERROR,
+		       "BT: %s: cannot remain alive while host is shutdown\n",
+		       sdio_func_id(func));
+		return;
+	}
+	cardp = sdio_get_drvdata(func);
+	if (!cardp || !cardp->priv) {
+		PRINTM(ERROR, "BT: Card or priv structure is not valid\n");
+		LEAVE();
+		return;
+	}
+
+	priv = cardp->priv;
+
+	if ((mbt_pm_keep_power) && (priv->adapter->hs_state != HS_ACTIVATED)) {
+
+		if (BT_STATUS_SUCCESS != bt_enable_hs(priv, TRUE)) {
+			PRINTM(CMD, "BT: HS not actived, shutdown fail!\n");
+			if (BT_STATUS_SUCCESS != bt_enable_hs(priv, TRUE)) {
+				PRINTM(CMD,
+				       "BT: HS not actived the second time, force to shutdown!\n");
+			}
+		}
+	}
+	LEAVE();
+}
+
+/** @brief This function handles client driver resume
+ *
+ *  @param dev	   A pointer to device structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+int
+bt_sdio_resume(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	mmc_pm_flag_t pm_flags = 0;
+	bt_private *priv = NULL;
+	struct sdio_mmc_card *cardp;
+	struct m_dev *m_dev = NULL;
+	struct hci_dev *hcidev;
+
+	ENTER();
+	pm_flags = sdio_get_host_pm_caps(func);
+	PRINTM(CMD, "BT: %s: resume: PM flags = 0x%x\n", sdio_func_id(func),
+	       pm_flags);
+	cardp = sdio_get_drvdata(func);
+	if (!cardp || !cardp->priv) {
+		PRINTM(ERROR, "BT: Card or priv structure is not valid\n");
+		LEAVE();
+		return BT_STATUS_SUCCESS;
+	}
+
+	priv = cardp->priv;
+	priv->adapter->is_suspended = FALSE;
+#ifdef SDIO_OOB_IRQ
+	mrvl_sdio_resume(func);
+#endif
+	m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+	PRINTM(CMD, "BT %s: SDIO resume\n", m_dev->name);
+	hcidev = (struct hci_dev *)m_dev->dev_pointer;
+	hci_resume_dev(hcidev);
+	sbi_wakeup_firmware(priv);
+	priv->adapter->hs_state = HS_DEACTIVATED;
+	PRINTM(CMD, "BT:%s: HS DEACTIVATED in Resume!\n", m_dev->name);
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+#endif
+#endif
+
+/********************************************************
+		Global Functions
+********************************************************/
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+static const struct dev_pm_ops bt_sdio_pm_ops = {
+	.suspend = bt_sdio_suspend,
+	.resume = bt_sdio_resume,
+};
+#endif
+#endif
+static struct sdio_driver sdio_bt = {
+	.name = "sdio_bt",
+	.id_table = bt_ids,
+	.probe = sd_probe_card,
+	.remove = sd_remove_card,
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+	.drv = {
+		.pm = &bt_sdio_pm_ops,
+		.shutdown = bt_sdio_shutdown,
+		}
+#endif
+#endif
+};
+
+/**
+ *  @brief This function registers the bt module in bus driver.
+ *
+ *  @return	   An int pointer that keeps returned value
+ */
+int *
+sbi_register(void)
+{
+	int *ret;
+
+	ENTER();
+
+	if (sdio_register_driver(&sdio_bt) != 0) {
+		PRINTM(FATAL, "BT: SD Driver Registration Failed\n");
+		LEAVE();
+		return NULL;
+	} else
+		ret = (int *)1;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function de-registers the bt module in bus driver.
+ *
+ *  @return        N/A
+ */
+void
+sbi_unregister(void)
+{
+	ENTER();
+	sdio_unregister_driver(&sdio_bt);
+	LEAVE();
+}
+
+/**
+ *  @brief This function registers the device.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_register_dev(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 reg;
+	u8 chiprev;
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	struct sdio_func *func;
+	u8 host_intstatus_reg = HOST_INTSTATUS_REG;
+	u8 host_int_rsr_reg = HOST_INT_RSR_REG;
+	u8 card_misc_cfg_reg = CARD_MISC_CFG_REG;
+	u8 card_revision_reg = CARD_REVISION_REG;
+	u8 io_port_0_reg = IO_PORT_0_REG;
+	u8 io_port_1_reg = IO_PORT_1_REG;
+	u8 io_port_2_reg = IO_PORT_2_REG;
+	u8 card_magic_reg = CARD_MAGIC_REG;
+	u8 magic_val = 0;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		PRINTM(ERROR, "BT: Error: card or function is NULL!\n");
+		goto failed;
+	}
+	func = card->func;
+	priv->hotplug_device = &func->dev;
+
+	/* Initialize the private structure */
+	strncpy(priv->bt_dev.name, "bt_sdio0", sizeof(priv->bt_dev.name));
+	priv->bt_dev.ioport = 0;
+	priv->bt_dev.fn = func->num;
+
+	sdio_claim_host(func);
+#ifdef SDIO_OOB_IRQ
+	ret = mrvl_sdio_claim_irq(func, sd_interrupt);
+#else
+	ret = sdio_claim_irq(func, sd_interrupt);
+#endif
+	if (ret) {
+		PRINTM(FATAL, ": sdio_claim_irq failed: ret=%d\n", ret);
+		goto release_host;
+	}
+	ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE);
+	if (ret) {
+		PRINTM(FATAL, ": %s: cannot set SDIO block size\n", __func__);
+		goto release_irq;
+	}
+
+	/* read Revision Register to get the chip revision number */
+	chiprev = sdio_readb(func, card_revision_reg, &ret);
+	if (ret) {
+		PRINTM(FATAL, ": cannot read CARD_REVISION_REG\n");
+		goto release_irq;
+	}
+	priv->adapter->chip_rev = chiprev;
+	PRINTM(INFO, "revision=%#x\n", chiprev);
+
+	magic_val = sdio_readb(func, card_magic_reg, &ret);
+	if (ret) {
+		PRINTM(FATAL, ": cannot read CARD_MAGIC_REG\n");
+		goto release_irq;
+	}
+	priv->adapter->magic_val = magic_val;
+	PRINTM(INFO, "magic_val=%#x\n", magic_val);
+
+	/*
+	 * Read the HOST_INTSTATUS_REG for ACK the first interrupt got
+	 * from the bootloader. If we don't do this we get a interrupt
+	 * as soon as we register the irq.
+	 */
+	reg = sdio_readb(func, host_intstatus_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+
+	/* Read the IO port */
+	reg = sdio_readb(func, io_port_0_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	else
+		priv->bt_dev.ioport |= reg;
+
+	reg = sdio_readb(func, io_port_1_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	else
+		priv->bt_dev.ioport |= (reg << 8);
+
+	reg = sdio_readb(func, io_port_2_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	else
+		priv->bt_dev.ioport |= (reg << 16);
+
+	PRINTM(INFO, ": SDIO FUNC%d IO port: 0x%x\n", priv->bt_dev.fn,
+	       priv->bt_dev.ioport);
+
+#define SDIO_INT_MASK       0x3F
+	/* Set Host interrupt reset to read to clear */
+	reg = sdio_readb(func, host_int_rsr_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	sdio_writeb(func, reg | SDIO_INT_MASK, host_int_rsr_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	/* Set auto re-enable */
+	reg = sdio_readb(func, card_misc_cfg_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+	sdio_writeb(func, reg | AUTO_RE_ENABLE_INT, card_misc_cfg_reg, &ret);
+	if (ret < 0)
+		goto release_irq;
+
+	sdio_set_drvdata(func, card);
+	sdio_release_host(func);
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+release_irq:
+#ifdef SDIO_OOB_IRQ
+	mrvl_sdio_release_irq(func);
+#else
+	sdio_release_irq(func);
+#endif
+release_host:
+	sdio_release_host(func);
+failed:
+
+	LEAVE();
+	return BT_STATUS_FAILURE;
+}
+
+/**
+ *  @brief This function de-registers the device.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+
+	ENTER();
+
+	if (card && card->func) {
+		sdio_claim_host(card->func);
+#ifdef SDIO_OOB_IRQ
+		mrvl_sdio_release_irq(card->func);
+#else
+		sdio_release_irq(card->func);
+#endif
+		sdio_disable_func(card->func);
+		sdio_release_host(card->func);
+		sdio_set_drvdata(card->func, NULL);
+	}
+
+	LEAVE();
+	return BT_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function enables the host interrupts.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_enable_host_int(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	int ret;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	sdio_claim_host(card->func);
+	ret = sd_enable_host_int_mask(priv, HIM_ENABLE);
+	sd_get_rx_unit(priv);
+	sdio_release_host(card->func);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function disables the host interrupts.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sbi_disable_host_int(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	int ret;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	sdio_claim_host(card->func);
+	ret = sbi_disable_host_int_mask(priv, HIM_DISABLE);
+	sdio_release_host(card->func);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sends data to the card.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb      Length of data/cmd
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(bt_private *priv, u8 *payload, u16 nb)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+#ifdef DEBUG_LEVEL1
+	struct m_dev *m_dev = &(priv->bt_dev.m_dev[BT_SEQ]);
+#endif
+	int ret = BT_STATUS_SUCCESS;
+	int buf_block_len;
+	int blksz;
+	int i = 0;
+	u8 *buf = NULL;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		PRINTM(ERROR, "BT: card or function is NULL!\n");
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	buf = payload;
+
+	blksz = SD_BLOCK_SIZE;
+	buf_block_len = (nb + blksz - 1) / blksz;
+	/* Allocate buffer and copy payload */
+	if ((t_ptr)payload & (DMA_ALIGNMENT - 1)) {
+		if (nb > MAX_TX_BUF_SIZE) {
+			PRINTM(ERROR, "BT: Invalid tx packet, size=%d\n", nb);
+			LEAVE();
+			return BT_STATUS_FAILURE;
+		}
+		/* Ensure 8-byte aligned CMD buffer */
+		buf = priv->adapter->tx_buf;
+		memcpy(buf, payload, nb);
+	}
+	sdio_claim_host(card->func);
+	do {
+		/* Transfer data to card */
+		ret = sdio_writesb(card->func, priv->bt_dev.ioport, buf,
+				   buf_block_len * blksz);
+		if (ret < 0) {
+			i++;
+			PRINTM(ERROR,
+			       "BT: host_to_card, write iomem (%d) failed: %d\n",
+			       i, ret);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+			/* issue abort cmd52 command through F0 */
+			sdio_f0_writeb(card->func, 0x01, SDIO_CCCR_ABORT, &ret);
+#endif
+			sdio_writeb(card->func, HOST_TERM_CMD53,
+				    CONFIGURATION_REG, &ret);
+			udelay(20);
+			ret = BT_STATUS_FAILURE;
+			if (i >= MAX_CMD53_RETRY)
+				goto exit;
+		} else {
+			PRINTM(DATA, "BT: SDIO Blk Wr %s: len=%d\n",
+			       m_dev->name, nb);
+			DBG_HEXDUMP(DAT_D, "BT: SDIO Blk Wr", payload, nb);
+		}
+	} while (ret == BT_STATUS_FAILURE);
+	priv->bt_dev.tx_dnld_rdy = FALSE;
+exit:
+	sdio_release_host(card->func);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function downloads firmware
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_download_fw(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	int ret = BT_STATUS_SUCCESS;
+	u8 winner = 0;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		PRINTM(ERROR, "BT: card or function is NULL!\n");
+		ret = BT_STATUS_FAILURE;
+		goto exit;
+	}
+
+	sdio_claim_host(card->func);
+	if (BT_STATUS_SUCCESS == sd_verify_fw_download(priv, 1)) {
+		PRINTM(MSG, "BT: FW already downloaded!\n");
+		sdio_release_host(card->func);
+		sbi_enable_host_int(priv);
+		if (BT_STATUS_FAILURE == sbi_register_conf_dpc(priv)) {
+			PRINTM(ERROR,
+			       "BT: sbi_register_conf_dpc failed. Terminating download\n");
+			ret = BT_STATUS_FAILURE;
+			goto err_register;
+		}
+		goto exit;
+	}
+	/* Check if other interface is downloading */
+	ret = sd_check_winner_status(priv, &winner);
+	if (ret == BT_STATUS_FAILURE) {
+		PRINTM(FATAL, "BT read winner status failed!\n");
+		goto done;
+	}
+	if (winner) {
+		PRINTM(MSG, "BT is not the winner (0x%x). Skip FW download\n",
+		       winner);
+		/* check if the fimware is downloaded successfully or not */
+		if (sd_verify_fw_download(priv, MAX_MULTI_INTERFACE_POLL_TRIES)) {
+			PRINTM(FATAL, "BT: FW failed to be active in time!\n");
+			ret = BT_STATUS_FAILURE;
+			goto done;
+		}
+		sdio_release_host(card->func);
+		sbi_enable_host_int(priv);
+		if (BT_STATUS_FAILURE == sbi_register_conf_dpc(priv)) {
+			PRINTM(ERROR,
+			       "BT: sbi_register_conf_dpc failed. Terminating download\n");
+			ret = BT_STATUS_FAILURE;
+			goto err_register;
+		}
+		goto exit;
+	}
+
+	get_monotonic_time(&priv->req_fw_time);
+	/* Download the main firmware via the helper firmware */
+	if (sd_download_firmware_w_helper(priv)) {
+		PRINTM(INFO, "BT: FW download failed!\n");
+		ret = BT_STATUS_FAILURE;
+	}
+	goto exit;
+done:
+	sdio_release_host(card->func);
+exit:
+	LEAVE();
+	return ret;
+err_register:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+int
+sbi_get_int_status(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	u8 sdio_ireg = 0;
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+
+	ENTER();
+
+	OS_INT_DISABLE;
+	sdio_ireg = priv->adapter->sd_ireg;
+	priv->adapter->sd_ireg = 0;
+	OS_INT_RESTORE;
+	sdio_claim_host(card->func);
+	priv->adapter->irq_done = sdio_ireg;
+	if (sdio_ireg & DN_LD_HOST_INT_STATUS) {	/* tx_done INT */
+		if (priv->bt_dev.tx_dnld_rdy) {	/* tx_done already received */
+			PRINTM(INFO,
+			       "BT: warning: tx_done already received: tx_dnld_rdy=0x%x int status=0x%x\n",
+			       priv->bt_dev.tx_dnld_rdy, sdio_ireg);
+		} else {
+			priv->bt_dev.tx_dnld_rdy = TRUE;
+		}
+	}
+	if (sdio_ireg & UP_LD_HOST_INT_STATUS)
+		sd_card_to_host(priv);
+
+	ret = BT_STATUS_SUCCESS;
+	sdio_release_host(card->func);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function wakeup firmware
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sbi_wakeup_firmware(bt_private *priv)
+{
+	struct sdio_mmc_card *card = priv->bt_dev.card;
+	int ret = BT_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!card || !card->func) {
+		PRINTM(ERROR, "BT: card or function is NULL!\n");
+		LEAVE();
+		return BT_STATUS_FAILURE;
+	}
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
+	sdio_release_host(card->func);
+	PRINTM(CMD, "BT wake up firmware\n");
+
+	LEAVE();
+	return ret;
+}
+
+#define INIT_START_REG  0xF1
+#define INIT_END_REG 0xF6
+
+/** @brief This function dump the SDIO register
+ *
+ *  @param priv     A Pointer to the bt_private structure
+ *
+ *  @return         N/A
+ */
+void
+bt_dump_sdio_regs(bt_private *priv)
+{
+	int ret = BT_STATUS_SUCCESS;
+	char buf[256], *ptr;
+	u8 loop, func, data;
+	unsigned int reg, reg_start, reg_end;
+	u8 loop_num = 2;
+	unsigned int init_reg_start = 0;
+	unsigned int init_reg_end = 0;
+	init_reg_start = INIT_START_REG;
+	init_reg_end = INIT_END_REG;
+
+	if (priv->adapter->ps_state)
+		sbi_wakeup_firmware(priv);
+
+	for (loop = 0; loop < loop_num; loop++) {
+		memset(buf, 0, sizeof(buf));
+		ptr = buf;
+		if (loop == 0) {
+			/* Read the registers of SDIO function0 */
+			func = loop;
+			reg_start = 0;
+			reg_end = 9;
+
+		} else {
+			func = 2;
+			reg_start = 0;
+			reg_end = 0x09;
+		}
+		ptr += sprintf(ptr, "SDIO Func%d (%#x-%#x): ", func, reg_start,
+			       reg_end);
+		for (reg = reg_start; reg <= reg_end;) {
+			if (func == 0)
+				ret = sd_f0_read_reg(priv, reg, &data);
+			else
+				ret = sd_read_reg(priv, reg, &data);
+			if (!ret)
+				ptr += sprintf(ptr, "%02x ", data);
+			else {
+				ptr += sprintf(ptr, "ERR");
+				break;
+			}
+			reg++;
+		}
+		PRINTM(MSG, "%s\n", buf);
+	}
+
+	if (init_reg_start) {
+		memset(buf, 0, sizeof(buf));
+		ptr = buf;
+		ptr += sprintf(ptr, "Init Status Reg (%#x-%#x): ",
+			       init_reg_start, init_reg_end);
+		for (reg = init_reg_start; reg <= init_reg_end;) {
+			ret = sd_read_reg(priv, reg, &data);
+			if (!ret)
+				ptr += sprintf(ptr, "%02x ", data);
+			else {
+				ptr += sprintf(ptr, "ERR");
+				break;
+			}
+			reg++;
+		}
+		PRINTM(MSG, "%s\n", buf);
+	}
+}
+
+module_param(fw_name, charp, 0);
+MODULE_PARM_DESC(fw_name, "Firmware name");
+module_param(bt_req_fw_nowait, int, 0);
+MODULE_PARM_DESC(bt_req_fw_nowait,
+		 "0: Use request_firmware API; 1: Use request_firmware_nowait API");
+module_param(multi_fn, int, 0);
+MODULE_PARM_DESC(multi_fn, "Bit 2: FN2;");
diff --git a/drivers/bluetooth/mbtex_8997/bt/hci_wrapper.h b/drivers/bluetooth/mbtex_8997/bt/hci_wrapper.h
new file mode 100755
index 000000000000..dd3c61817b5c
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/hci_wrapper.h
@@ -0,0 +1,166 @@
+/** @file hci_wrapper.h
+ *  @brief This file contains HCI related definitions
+ *
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _HCI_WRAPPER_H_
+#define _HCI_WRAPPER_H_
+
+#include <linux/module.h>
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+/**  Define Seq num */
+#define BT_SEQ      0
+
+/** Define dev type */
+#define BT_TYPE     1
+#define BT_AMP_TYPE 2
+
+/** Define spec type */
+#define BLUEZ_SPEC     1
+#define IANYWHERE_SPEC 2
+#define GENERIC_SPEC   3
+
+/** Define lock/unlock wrapper */
+#define mdev_req_lock(d)		down(&d->req_lock)
+#define mdev_req_unlock(d)		up(&d->req_lock)
+
+/** Length of device name */
+#define DEV_NAME_LEN				32
+
+/** Define struct m_dev */
+struct m_dev {
+	char name[DEV_NAME_LEN];
+	int index;
+	unsigned long flags;
+	spinlock_t lock;
+	struct semaphore req_lock;
+	struct sk_buff_head rx_q;
+	wait_queue_head_t req_wait_q;
+	struct hci_dev_stats stat;
+	struct module *owner;
+	void *dev_pointer;
+	int dev_type;
+	int spec_type;
+	void *driver_data;
+	int wait_rx_complete;
+	int rx_complete_flag;
+	wait_queue_head_t rx_wait_q;
+	spinlock_t rxlock;
+	atomic_t extra_cnt;
+
+	struct sk_buff *evt_skb;
+	struct sk_buff *acl_skb;
+	struct sk_buff *sco_skb;
+
+	int (*open) (struct m_dev * m_dev);
+	int (*close) (struct m_dev * m_dev);
+	int (*flush) (struct m_dev * m_dev);
+	int (*send) (struct m_dev * m_dev, struct sk_buff * skb);
+	void (*destruct) (struct m_dev * m_dev);
+	void (*notify) (struct m_dev * m_dev, unsigned int evt);
+	int (*ioctl) (struct m_dev * m_dev, unsigned int cmd, void *arg);
+	void (*query) (struct m_dev * m_dev, void *arg);
+
+};
+
+/** Define struct mbt_dev */
+struct mbt_dev {
+	/** maybe could add some private member later */
+	char name[DEV_NAME_LEN];
+	unsigned long flags;
+	__u8 type;
+
+	__u16 pkt_type;
+	__u16 esco_type;
+	__u16 link_policy;
+	__u16 link_mode;
+
+	__u32 idle_timeout;
+	__u16 sniff_min_interval;
+	__u16 sniff_max_interval;
+
+	struct sk_buff *reassembly[3];
+
+	atomic_t promisc;
+};
+
+/** This function frees m_dev allocation */
+void free_m_dev(struct m_dev *m_dev);
+
+/**
+ *  @brief This function receives frames
+ *
+ *  @param skb	A pointer to struct sk_buff
+ *  @return	0--success otherwise error code
+ */
+static inline int
+mdev_recv_frame(struct sk_buff *skb)
+{
+	struct m_dev *m_dev = (struct m_dev *)skb->dev;
+	if (!m_dev || (!test_bit(HCI_UP, &m_dev->flags)
+		       && !test_bit(HCI_INIT, &m_dev->flags))) {
+		kfree_skb(skb);
+		return -ENXIO;
+	}
+
+	/* Incomming skb */
+	bt_cb(skb)->incoming = 1;
+
+	/* Time stamp */
+	__net_timestamp(skb);
+
+	/* Put type byte before the data */
+	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
+
+	/* Queue frame for rx task */
+	skb_queue_tail(&m_dev->rx_q, skb);
+
+	/* Wakeup rx thread */
+	wake_up_interruptible(&m_dev->req_wait_q);
+
+	return 0;
+}
+
+/**
+ *  @brief mbt dev suspend handler
+ *
+ *  @param m_dev   A pointer to struct m_dev
+ *  @return        0
+ */
+static inline int
+mbt_hci_suspend_dev(struct m_dev *m_dev)
+{
+	return 0;
+}
+
+/**
+ *  @brief mbt dev resume handler
+ *
+ *  @param m_dev   A pointer to struct m_dev
+ *  @return        0
+ */
+static inline int
+mbt_hci_resume_dev(struct m_dev *m_dev)
+{
+	return 0;
+}
+
+#endif /* _HCI_WRAPPER_H_ */
diff --git a/drivers/bluetooth/mbtex_8997/bt/mbt_char.c b/drivers/bluetooth/mbtex_8997/bt/mbt_char.c
new file mode 100755
index 000000000000..9934b7df71c1
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/mbt_char.c
@@ -0,0 +1,791 @@
+/** @file mbt_char.c
+ *
+ *  @brief This file contains the char device function calls
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+
+#include "bt_drv.h"
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
+#include "mbt_char.h"
+
+#ifndef MIN
+/** Find minimum value */
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif /* MIN */
+
+static LIST_HEAD(char_dev_list);
+
+static DEFINE_SPINLOCK(char_dev_list_lock);
+
+static int mbtchar_major = MBTCHAR_MAJOR_NUM;
+
+/**
+ *	@brief  Gets char device structure
+ *
+ *	@param dev		A pointer to char_dev
+ *
+ *	@return			kobject structure
+ */
+struct kobject *
+chardev_get(struct char_dev *dev)
+{
+	struct kobject *kobj;
+
+	kobj = bt_priv_get(dev->m_dev->driver_data);
+	if (!kobj)
+		return NULL;
+	PRINTM(INFO, "dev get kobj\n");
+	kobj = kobject_get(&dev->kobj);
+	if (!kobj)
+		bt_priv_put(dev->m_dev->driver_data);
+	return kobj;
+}
+
+/**
+ *	@brief  Prints char device structure
+ *
+ *	@param dev		A pointer to char_dev
+ *
+ *	@return			N/A
+ */
+void
+chardev_put(struct char_dev *dev)
+{
+	if (dev) {
+		struct m_dev *m_dev = dev->m_dev;
+		PRINTM(INFO, "dev put kobj\n");
+		kobject_put(&dev->kobj);
+		if (m_dev)
+			bt_priv_put(m_dev->driver_data);
+	}
+}
+
+#if 0
+/**
+ *	@brief Changes permissions of the dev
+ *
+ *	@param name	pointer to character
+ *	@param mode		mode_t type data
+ *	@return			0--success otherwise failure
+ */
+int
+mbtchar_chmod(char *name, mode_t mode)
+{
+	struct path path;
+	struct inode *inode;
+	struct iattr newattrs;
+	int ret;
+	int retrycount = 0;
+
+	ENTER();
+	do {
+		os_sched_timeout(30);
+		ret = kern_path(name, LOOKUP_FOLLOW, &path);
+		if (++retrycount >= 10) {
+			PRINTM(ERROR,
+			       "mbtchar_chmod(): fail to get kern_path\n");
+			LEAVE();
+			return -EFAULT;
+		}
+	} while (ret);
+	inode = path.dentry->d_inode;
+
+	ret = mnt_want_write(path.mnt);
+	if (ret)
+		goto out_unlock;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	mutex_lock(&inode->i_mutex);
+#else
+	inode_lock(inode);
+#endif
+	newattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);
+	newattrs.ia_valid = ATTR_MODE | ATTR_CTIME;
+	if (inode->i_op->setattr)
+		ret = inode->i_op->setattr(path.dentry, &newattrs);
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		ret = simple_setattr(path.dentry, &newattrs);
+#else
+		ret = inode_setattr(inode, &newattrs);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+
+	path_put(&path);
+	LEAVE();
+	return ret;
+out_unlock:
+	mnt_drop_write(path.mnt);
+	path_put(&path);
+	return ret;
+}
+
+/**
+ *	@brief Changes ownership of the dev
+ *
+ *	@param name	pointer to character
+ *	@param user		uid_t type data
+ *	@param group	gid_t type data
+ *	@return			0--success otherwise failure
+ */
+int
+mbtchar_chown(char *name, uid_t user, gid_t group)
+{
+	struct path path;
+	struct inode *inode = NULL;
+	struct iattr newattrs;
+	int ret = 0;
+	int retrycount = 0;
+
+	ENTER();
+	do {
+		os_sched_timeout(30);
+		ret = kern_path(name, LOOKUP_FOLLOW, &path);
+		if (++retrycount >= 10) {
+			PRINTM(ERROR,
+			       "mbtchar_chown(): fail to get kern_path\n");
+			LEAVE();
+			return -EFAULT;
+		}
+	} while (ret);
+	inode = path.dentry->d_inode;
+	ret = mnt_want_write(path.mnt);
+	if (ret)
+		goto out_unlock;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	mutex_lock(&inode->i_mutex);
+#else
+	inode_lock(inode);
+#endif
+	newattrs.ia_valid = ATTR_CTIME;
+	if (user != (uid_t) (-1)) {
+		newattrs.ia_valid |= ATTR_UID;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		newattrs.ia_uid = user;
+#else
+		newattrs.ia_uid = KUIDT_INIT(user);
+#endif
+	}
+	if (group != (gid_t) (-1)) {
+		newattrs.ia_valid |= ATTR_GID;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0)
+		newattrs.ia_gid = group;
+#else
+		newattrs.ia_gid = KGIDT_INIT(group);
+#endif
+	}
+	if (!S_ISDIR(inode->i_mode))
+		newattrs.ia_valid |=
+			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
+	if (inode->i_op->setattr)
+		ret = inode->i_op->setattr(path.dentry, &newattrs);
+	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+		ret = simple_setattr(path.dentry, &newattrs);
+#else
+		ret = inode_setattr(inode, &newattrs);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+	mutex_unlock(&inode->i_mutex);
+#else
+	inode_unlock(inode);
+#endif
+	mnt_drop_write(path.mnt);
+
+	path_put(&path);
+	LEAVE();
+	return ret;
+out_unlock:
+	mnt_drop_write(path.mnt);
+	path_put(&path);
+	return ret;
+}
+#endif
+/**
+ *	@brief write handler for char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param buf		pointer to char buffer
+ *	@param count	size of receive buffer
+ *	@param f_pos	pointer to loff_t type data
+ *	@return			number of bytes written
+ */
+ssize_t
+chardev_write(struct file * filp, const char *buf, size_t count, loff_t * f_pos)
+{
+	int nwrite = 0;
+	struct sk_buff *skb;
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+
+	ENTER();
+
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	if (!test_bit(HCI_UP, &m_dev->flags)) {
+		LEAVE();
+		return -EBUSY;
+	}
+	nwrite = count;
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
+	if (!skb) {
+		PRINTM(ERROR, "mbtchar_write(): fail to alloc skb\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	if (copy_from_user((void *)skb_put(skb, count), buf, count)) {
+		PRINTM(ERROR, "mbtchar_write(): cp_from_user failed\n");
+		kfree_skb(skb);
+		nwrite = -EFAULT;
+		goto exit;
+	}
+
+	skb->dev = (void *)m_dev;
+	bt_cb(skb)->pkt_type = *((unsigned char *)skb->data);
+	skb_pull(skb, 1);
+
+	PRINTM(DATA, "Write: pkt_type: 0x%x, len=%d @%lu\n",
+	       bt_cb(skb)->pkt_type, skb->len, jiffies);
+	DBG_HEXDUMP(DAT_D, "chardev_write", skb->data, skb->len);
+
+	/* Send skb to the hci wrapper layer */
+	if (m_dev->send(m_dev, skb)) {
+		PRINTM(ERROR, "Write: Fail\n");
+		nwrite = 0;
+		/* Send failed */
+		kfree_skb(skb);
+	}
+exit:
+	LEAVE();
+	return nwrite;
+}
+
+/**
+ *	@brief read handler for BT char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param buf		pointer to char buffer
+ *	@param count	size of receive buffer
+ *	@param f_pos	pointer to loff_t type data
+ *	@return			number of bytes read
+ */
+ssize_t
+chardev_read(struct file * filp, char *buf, size_t count, loff_t * f_pos)
+{
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t ret = 0;
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	/* Wait for rx data */
+	add_wait_queue(&m_dev->req_wait_q, &wait);
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		skb = skb_dequeue(&m_dev->rx_q);
+		if (skb)
+			break;
+		if (!test_bit(HCI_UP, &m_dev->flags)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		if (filp->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			break;
+		}
+		if (signal_pending(current)) {
+			ret = -EINTR;
+			break;
+		}
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&m_dev->req_wait_q, &wait);
+
+	if (!skb)
+		goto out;
+
+	PRINTM(DATA, "BT: chardev_read count=%d pkt_type: 0x%x, len=%d %p\n",
+	       (int)count, bt_cb(skb)->pkt_type, skb->len, skb);
+	DBG_HEXDUMP(DAT_D, "chardev_read", skb->data,
+		    MIN((int)count, skb->len));
+	if (skb->len > count) {
+		/* user data length is smaller than the skb length */
+		if (copy_to_user(buf, skb->data, count)) {
+			ret = -EFAULT;
+			goto outf;
+		}
+		skb_pull(skb, count);
+		skb_queue_head(&m_dev->rx_q, skb);
+		wake_up_interruptible(&m_dev->req_wait_q);
+		ret = count;
+		goto out;
+	} else {
+		if (copy_to_user(buf, skb->data, skb->len)) {
+			ret = -EFAULT;
+			goto outf;
+		}
+		ret = skb->len;
+		PRINTM(DATA, "BT: chardev_read complete %p\n", skb);
+	}
+outf:
+	kfree_skb(skb);
+out:
+	if (m_dev->wait_rx_complete && skb_queue_empty(&m_dev->rx_q)) {
+		m_dev->rx_complete_flag = TRUE;
+		wake_up_interruptible(&m_dev->rx_wait_q);
+	}
+	LEAVE();
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+/**
+ *	@brief ioctl common handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+int
+char_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, void *arg)
+#else
+/**
+ *	@brief ioctl common handler for char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+long
+char_ioctl(struct file *filp, unsigned int cmd, void *arg)
+#endif
+{
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+
+	ENTER();
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+	PRINTM(INFO, "IOCTL: cmd=%d\n", cmd);
+	switch (cmd) {
+	case MBTCHAR_IOCTL_RELEASE:
+		m_dev->close(m_dev);
+		break;
+	case MBTCHAR_IOCTL_QUERY_TYPE:
+		m_dev->query(m_dev, arg);
+		break;
+	default:
+		m_dev->ioctl(m_dev, cmd, arg);
+		break;
+	}
+	LEAVE();
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+/**
+ *	@brief ioctl handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_ioctl(struct inode *inode, struct file *filp,
+	      unsigned int cmd, unsigned long arg)
+#else
+/**
+ *	@brief ioctl handler for char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+long
+chardev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+	return char_ioctl(inode, filp, cmd, (void *)arg);
+#else
+	return char_ioctl(filp, cmd, (void *)arg);
+#endif
+}
+
+#ifdef CONFIG_COMPAT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+/**
+ *	@brief compat ioctl handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_ioctl_compat(struct inode *inode, struct file *filp,
+		     unsigned int cmd, unsigned long arg)
+#else
+/**
+ *	@brief compat ioctl handler for char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param cmd		contains the IOCTL
+ *	@param arg		contains the arguement
+ *	@return			0--success otherwise failure
+ */
+long
+chardev_ioctl_compat(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+	return char_ioctl(inode, filp, cmd, compat_ptr(arg));
+#else
+	return char_ioctl(filp, cmd, compat_ptr(arg));
+#endif
+}
+#endif /* CONFIG_COMPAT */
+
+/**
+ *	@brief open handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp	pointer to structure file
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct char_dev *dev = NULL;
+	struct m_dev *m_dev = NULL;
+	struct char_dev *cdev = NULL;
+	struct list_head *p = NULL;
+	ENTER();
+
+	list_for_each(p, &char_dev_list) {
+		cdev = list_entry(p, struct char_dev, list);
+		if (mbtchar_major == MAJOR(inode->i_cdev->dev) &&
+		    cdev->minor == MINOR(inode->i_cdev->dev)) {
+			dev = cdev;
+			break;
+		}
+	}
+	if (!dev) {
+		PRINTM(ERROR, "cannot find dev from inode\n");
+		LEAVE();
+		return -ENXIO;
+	}
+	if (!chardev_get(dev)) {
+		LEAVE();
+		return -ENXIO;
+	}
+	filp->private_data = dev;	/* for other methods */
+	m_dev = dev->m_dev;
+	mdev_req_lock(m_dev);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 0)
+	if (test_bit(HCI_UP, &m_dev->flags)) {
+		atomic_inc(&m_dev->extra_cnt);
+		goto done;
+	}
+#endif
+	if (m_dev->open(m_dev)) {
+		ret = -EIO;
+		goto done;
+	}
+	set_bit(HCI_UP, &m_dev->flags);
+
+done:
+	mdev_req_unlock(m_dev);
+	if (ret)
+		chardev_put(dev);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief release handler for char dev
+ *
+ *	@param inode	pointer to structure inode
+ *	@param filp	pointer to structure file
+ *	@return			0--success otherwise failure
+ */
+int
+chardev_release(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+	ENTER();
+	if (!dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+	m_dev = dev->m_dev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 7, 0)
+	if (m_dev && (atomic_dec_if_positive(&m_dev->extra_cnt) >= 0)) {
+		LEAVE();
+		return ret;
+	}
+#endif
+	if (m_dev)
+		ret = dev->m_dev->close(dev->m_dev);
+	filp->private_data = NULL;
+	chardev_put(dev);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief poll handler for char dev
+ *
+ *	@param filp	pointer to structure file
+ *	@param wait		pointer to poll_table structure
+ *	@return			mask
+ */
+static unsigned int
+chardev_poll(struct file *filp, poll_table * wait)
+{
+	unsigned int mask;
+	struct char_dev *dev = (struct char_dev *)filp->private_data;
+	struct m_dev *m_dev = NULL;
+	ENTER();
+	if (!dev || !dev->m_dev) {
+		LEAVE();
+		return -ENXIO;
+	}
+
+	m_dev = dev->m_dev;
+	poll_wait(filp, &m_dev->req_wait_q, wait);
+	mask = POLLOUT | POLLWRNORM;
+	if (skb_peek(&m_dev->rx_q))
+		mask |= POLLIN | POLLRDNORM;
+	if (!test_bit(HCI_UP, &(m_dev->flags)))
+		mask |= POLLHUP;
+	PRINTM(INFO, "poll mask=0x%x\n", mask);
+	LEAVE();
+	return mask;
+}
+
+/* File ops for the Char driver */
+const struct file_operations chardev_fops = {
+	.owner = THIS_MODULE,
+	.read = chardev_read,
+	.write = chardev_write,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+	.ioctl = chardev_ioctl,
+#else
+	.unlocked_ioctl = chardev_ioctl,
+#endif
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = chardev_ioctl_compat,
+#endif
+	.open = chardev_open,
+	.release = chardev_release,
+	.poll = chardev_poll,
+};
+
+/**
+ *	@brief This function creates the char dev
+ *
+ *	@param dev			A pointer to structure char_dev
+ *  @param char_class	A pointer to class struct
+ *  @param mod_name		A pointer to char
+ *  @param dev_name		A pointer to char
+ *	@return				0--success otherwise failure
+ */
+int
+register_char_dev(struct char_dev *dev, struct class *char_class,
+		  char *mod_name, char *dev_name)
+{
+	int ret = 0, dev_num;
+	unsigned long flags;
+	ENTER();
+	/* create the chrdev region */
+	if (mbtchar_major) {
+		dev_num = MKDEV(mbtchar_major, dev->minor);
+		ret = register_chrdev_region(dev_num, 1, mod_name);
+	} else {
+		PRINTM(INFO, "chardev: no major # yet\n");
+		ret = alloc_chrdev_region((dev_t *) & dev_num, dev->minor, 1,
+					  mod_name);
+	}
+
+	if (ret) {
+		PRINTM(ERROR, "chardev: create chrdev_region failed\n");
+		LEAVE();
+		return ret;
+	}
+	if (!mbtchar_major) {
+		/* Store the allocated dev major # */
+		mbtchar_major = MAJOR(dev_num);
+	}
+	dev->cdev = cdev_alloc();
+	dev->cdev->ops = &chardev_fops;
+	dev->cdev->owner = chardev_fops.owner;
+	dev_num = MKDEV(mbtchar_major, dev->minor);
+
+	if (cdev_add(dev->cdev, dev_num, 1)) {
+		PRINTM(ERROR, "chardev: cdev_add failed\n");
+		ret = -EFAULT;
+		goto free_cdev_region;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	if ((dev->dev_type == BT_TYPE) || (dev->dev_type == BT_AMP_TYPE)) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), NULL, dev_name);
+	}
+#else
+	if ((dev->dev_type == BT_TYPE) || (dev->dev_type == BT_AMP_TYPE)) {
+		device_create(char_class, NULL,
+			      MKDEV(mbtchar_major, dev->minor), dev_name);
+	}
+#endif
+	PRINTM(INFO, "register char dev=%s\n", dev_name);
+
+	/** modify later */
+
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	list_add_tail(&dev->list, &char_dev_list);
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+
+	LEAVE();
+	return ret;
+free_cdev_region:
+	unregister_chrdev_region(MKDEV(mbtchar_major, dev->minor), 1);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *	@brief This function deletes the char dev
+ *
+ *  @param dev			A pointer to structure char_dev
+ *  @param char_class	A pointer to class struct
+ *  @param dev_name		A pointer to char
+ *  @return				0--success otherwise failure
+ */
+int
+unregister_char_dev(struct char_dev *dev, struct class *char_class,
+		    char *dev_name)
+{
+	ENTER();
+	device_destroy(char_class, MKDEV(mbtchar_major, dev->minor));
+	cdev_del(dev->cdev);
+	unregister_chrdev_region(MKDEV(mbtchar_major, dev->minor), 1);
+	PRINTM(INFO, "unregister char dev=%s\n", dev_name);
+
+	LEAVE();
+	return 0;
+}
+
+/**
+ *	@brief This function cleans module
+ *
+ *  @param char_class	A pointer to class struct
+ *  @return				N/A
+ */
+void
+chardev_cleanup(struct class *char_class)
+{
+	unsigned long flags;
+	struct list_head *p = NULL;
+	struct char_dev *dev = NULL;
+	ENTER();
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	do {
+		dev = NULL;
+		list_for_each(p, &char_dev_list) {
+			dev = list_entry(p, struct char_dev, list);
+			list_del(p);
+			spin_unlock_irqrestore(&char_dev_list_lock, flags);
+			unregister_char_dev(dev, char_class, dev->m_dev->name);
+			kobject_put(&dev->kobj);
+			spin_lock_irqsave(&char_dev_list_lock, flags);
+			break;
+		}
+	} while (dev);
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+	class_destroy(char_class);
+	LEAVE();
+}
+
+/**
+ *	@brief This function cleans module
+ *
+ *  @param m_dev	A pointer to m_dev struct
+ *  @param char_class	A pointer to class struct
+ *  @return			N/A
+ */
+void
+chardev_cleanup_one(struct m_dev *m_dev, struct class *char_class)
+{
+	unsigned long flags;
+	struct list_head *p = NULL;
+	struct char_dev *dev = NULL;
+	ENTER();
+	spin_lock_irqsave(&char_dev_list_lock, flags);
+	list_for_each(p, &char_dev_list) {
+		dev = list_entry(p, struct char_dev, list);
+		if (dev->minor == m_dev->index) {
+			list_del(p);
+			spin_unlock_irqrestore(&char_dev_list_lock, flags);
+			dev->m_dev = NULL;
+			unregister_char_dev(dev, char_class, m_dev->name);
+			kobject_put(&dev->kobj);
+			spin_lock_irqsave(&char_dev_list_lock, flags);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&char_dev_list_lock, flags);
+	LEAVE();
+}
diff --git a/drivers/bluetooth/mbtex_8997/bt/mbt_char.h b/drivers/bluetooth/mbtex_8997/bt/mbt_char.h
new file mode 100755
index 000000000000..b9e9f9ff0e38
--- /dev/null
+++ b/drivers/bluetooth/mbtex_8997/bt/mbt_char.h
@@ -0,0 +1,68 @@
+/** @file mbt_char.h
+ *
+ *  @brief This file contains mbtchar driver specific defines etc
+ *
+ *  Copyright 2014-2020 NXP
+ *
+ *  This software file (the File) is distributed by NXP
+ *  under the terms of the GNU General Public License Version 2, June 1991
+ *  (the License).  You may use, redistribute and/or modify the File in
+ *  accordance with the terms and conditions of the License, a copy of which
+ *  is available by writing to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ *  worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ *  this warranty disclaimer.
+ *
+ */
+#ifndef __MBT_CHAR_H__
+#define __MBT_CHAR_H__
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+
+/** Define ioctl */
+#define MBTCHAR_IOCTL_RELEASE       _IO('M', 1)
+#define MBTCHAR_IOCTL_QUERY_TYPE    _IO('M', 2)
+#define MBTCHAR_IOCTL_BT_FW_DUMP _IO('M', 6)
+
+#define MBTCHAR_MAJOR_NUM            (0)
+
+/** Interface specific macros */
+#define FMCHAR_MINOR_BASE            (10)
+#define NFCCHAR_MINOR_BASE           (20)
+
+/** Declaration of char_dev struct */
+struct char_dev {
+	struct list_head list;
+	int minor;
+	int dev_type;
+	struct cdev *cdev;
+	struct m_dev *m_dev;
+	struct kobject kobj;
+};
+
+/** Changes permissions of the dev */
+int mbtchar_chmod(char *name, mode_t mode);
+
+/** Changes ownership of the dev */
+int mbtchar_chown(char *name, uid_t user, gid_t group);
+
+/**	This function creates the char dev */
+int register_char_dev(struct char_dev *dev, struct class *char_class,
+		      char *mod_name, char *dev_name);
+
+/**	This function deletes the char dev */
+int unregister_char_dev(struct char_dev *dev, struct class *char_class,
+			char *dev_name);
+
+/**	This function cleans module */
+void chardev_cleanup(struct class *char_class);
+
+/**	This function cleans module */
+void chardev_cleanup_one(struct m_dev *m_dev, struct class *char_class);
+
+#endif /*__MBT_CHAR_H__*/
